<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Worst Eleven</title>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=DM+Sans:wght@300;400;500;600&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --black: #0a0a0a;
    --white: #ffffff;
    --off-white: #f7f6f3;
    --card-bg: #ffffff;
    --border: #e8e6e1;
    --muted: #9b9690;
    --red: #e8290b;
    --green: #1a7a4a;
    --yellow: #f5a623;
    --blue: #1a3fc4;
    --home-colour: #6cabdd;
    --home-colour-dark: #1c5493;
    --home-colour-light: #eef2ff;
    --home-colour-border: #c7d2fe;
    --away-colour: #fbee23;
    --away-colour-dark: #c8a000;
    --away-colour-light: #fffbea;
    --away-colour-border: #fde68a;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'DM Sans', sans-serif;
    background: var(--off-white);
    color: var(--black);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* ─── SCREENS ─── */
  .screen { display: none; min-height: 100vh; }
  .screen.active { display: flex; flex-direction: column; }

  /* ─── HEADER ─── */
  .game-header {
    background: var(--black);
    padding: 16px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: sticky;
    top: 0;
    z-index: 100;
  }
  .logo {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 28px;
    color: var(--white);
    letter-spacing: 2px;
  }
  .logo span { color: var(--red); }
  .match-badge {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  /* ─── HOME SCREEN ─── */
  #screen-home {
    background: var(--black);
    align-items: center;
    justify-content: flex-start;
    text-align: center;
    padding: 28px 24px 24px;
    overflow-y: auto;
  }
  .home-logo {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(52px, 12vw, 80px);
    color: var(--white);
    letter-spacing: 4px;
    line-height: 0.88;
    margin-bottom: 8px;
  }
  .home-logo span { color: var(--red); }
  .home-tagline {
    font-size: 15px;
    color: var(--muted);
    margin-bottom: 20px;
    letter-spacing: 0.5px;
  }
  .home-tagline .tagline-score {
    color: white;
    font-weight: 700;
  }
  .match-preview-card {
    background: #141414;
    border: 1px solid #2a2a2a;
    border-radius: 16px;
    padding: 28px 32px;
    max-width: 380px;
    width: 100%;
    margin: 0 auto 32px;
  }
  .match-preview-label {
    font-size: 12px;
    color: var(--muted);
    font-weight: 500;
    margin-bottom: 0;
  }
  .match-teams {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 8px 12px;
  }
  .match-team-crest-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    flex: 1;
  }
  .team-crest {
    width: 60px;
    height: 60px;
    object-fit: contain;
  }
  .crest-fallback {
    width: 60px;
    height: 60px;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 38px;
  }
  .match-vs-col {
    font-size: 14px;
    font-weight: 500;
    color: var(--muted);
    flex-shrink: 0;
    padding: 0 12px;
    margin-bottom: 26px;
  }
  .match-team-name {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 28px;
    font-weight: 400;
    color: var(--black);
    letter-spacing: 1px;
  }
  .match-team-name.city { color: #6CABDD; }
  .match-team-name.watford { color: #FBEE23; text-shadow: 0 0 1px #aaa; }
  .match-score-display {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 48px;
    color: var(--white);
    line-height: 1;
  }
  .btn-primary {
    background: var(--white);
    color: var(--black);
    border: none;
    border-radius: 12px;
    padding: 18px 48px;
    font-family: 'DM Sans', sans-serif;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    letter-spacing: 0.3px;
    transition: all 0.15s;
    display: inline-block;
  }
  .btn-primary:hover { background: #e8e6e1; transform: translateY(-1px); }
  .btn-primary:disabled {
    background: #1e1e1e;
    color: #444;
    cursor: default;
    transform: none;
    border: 1.5px solid #2a2a2a;
  }
  .btn-primary:disabled:hover { background: #1e1e1e; transform: none; }
  .btn-primary.dark {
    background: var(--black);
    color: var(--white);
  }
  .btn-primary.dark:hover { background: #222; }
  .btn-primary.red { background: var(--red); color: white; }
  .btn-primary.red:hover { background: #c5230a; }
  .home-rules {
    background: #111;
    border-radius: 16px;
    padding: 14px 14px;
    margin-bottom: 14px;
    width: 100%;
  }
  .home-rules-title {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #555;
    margin-bottom: 12px;
  }
  .home-rule-step {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    margin-bottom: 9px;
    font-size: 12px;
    color: #aaa;
    line-height: 1.45;
  }
  .home-rule-step:last-child { margin-bottom: 0; }
  .home-rule-step strong { color: #ddd; }
  .home-rule-num {
    flex-shrink: 0;
    width: 20px;
    height: 20px;
    background: #1e1e1e;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 700;
    color: #555;
    margin-top: 1px;
  }
  .home-scoring {
    width: 100%;
    padding: 16px 0 8px;
  }
  .home-scoring-title {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #555;
    margin-bottom: 10px;
  }
  .home-scoring-row {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 13px;
    color: #888;
    margin-bottom: 6px;
  }
  .score-pill {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    font-weight: 700;
    padding: 2px 7px;
    border-radius: 6px;
    flex-shrink: 0;
    min-width: 44px;
    text-align: center;
  }
  .score-pill.pos { background: #1a2e1a; color: #4ade80; }
  .score-pill.neg { background: #2e1a1a; color: #f87171; }

  /* ─── DRAFT SCREEN ─── */
  #screen-draft {
    background: var(--off-white);
    flex-direction: column;
    height: 100dvh;
    max-height: 100dvh;
    overflow: hidden;
  }
  .draft-layout {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 10px 12px;
    gap: 8px;
    max-width: 600px;
    width: 100%;
    margin: 0 auto;
    min-height: 0;
    overflow: hidden;
  }

  /* Opponent zone */
  .zone-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 4px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .zone-label .dot {
    width: 6px; height: 6px;
    border-radius: 50%;
  }
  .dot.opponent { background: var(--red); }
  .dot.yours { background: var(--blue); }

  .slots-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 4px;
  }
  .player-slot {
    background: white;
    border: 1.5px solid var(--border);
    border-radius: 8px;
    padding: 0 4px;
    text-align: center;
    height: 50px;
    min-height: 50px;
    max-height: 50px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: background 0.2s, border-color 0.2s;
  }
  .player-slot.filled { border-color: transparent; }
  .player-slot.filled.opponent-slot { background: #fff5f4; border-color: #ffd5d0; }
  .player-slot.filled.your-slot { background: #f4f6ff; border-color: #d0d8ff; }
  .player-slot .slot-pos {
    font-family: 'DM Mono', monospace;
    font-size: 8px;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    line-height: 1;
  }
  .player-slot .slot-name {
    font-size: 10px;
    font-weight: 600;
    line-height: 1.2;
    margin-top: 1px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
  }
  .player-slot .slot-team {
    font-size: 9px;
    line-height: 1;
    margin-top: 1px;
  }
  .player-slot.empty-slot .slot-pos { color: #ccc; font-size: 9px; }

  /* Middle carousel */
  .draft-middle {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 7px;
    min-height: 0;
  }

  /* Combined bottom action row */
  .draft-action-row {
    display: flex;
    align-items: center;
    gap: 8px;
    width: 100%;
    flex-shrink: 0;
  }
  .turn-pill {
    display: flex;
    align-items: center;
    gap: 8px;
    background: var(--black);
    color: white;
    border-radius: 10px;
    padding: 8px 12px;
    flex: 1;
    min-width: 0;
  }
  .turn-text {
    font-size: 12px;
    font-weight: 500;
    flex: 1;
    min-width: 0;
    line-height: 1.3;
  }
  .turn-text em { font-style: normal; color: #aaa; }
  .btn-confirm {
    flex-shrink: 0;
    width: 130px;
    padding: 11px 0;
    border-radius: 10px;
    border: none;
    font-size: 13px;
    font-weight: 700;
    cursor: pointer;
    transition: background 0.15s;
    background: var(--blue);
    color: white;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .btn-confirm:disabled { opacity: 0.4; cursor: not-allowed; }
  .btn-confirm:not(:disabled):hover { background: #1535a8; }
  .timer-ring {
    width: 30px; height: 30px;
    position: relative;
    flex-shrink: 0;
  }
  .timer-ring svg {
    position: absolute;
    inset: 0;
    transform: rotate(-90deg);
    width: 100%;
    height: 100%;
  }
  .timer-ring circle {
    fill: none;
    stroke: #333;
    stroke-width: 3;
  }
  .timer-ring .progress {
    stroke: var(--yellow);
    stroke-linecap: round;
    transition: stroke-dashoffset 1s linear;
  }
  .timer-num {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    font-weight: 600;
    color: white;
    line-height: 1;
  }

  /* Team toggle */
  .team-toggle {
    display: flex;
    background: white;
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 3px;
    gap: 3px;
  }
  .team-toggle button {
    border: none;
    background: none;
    padding: 8px 16px;
    border-radius: 7px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
    color: var(--muted);
  }
  .team-toggle button.active {
    background: var(--black);
    color: white;
  }

  /* Sabotage bar hidden */
  .sabotage-bar { display: none; }

  /* Player cards carousel */
  .carousel-container {
    width: 100%;
    overflow-x: auto;
    overflow-y: visible;
    position: relative;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }
  .carousel-container::-webkit-scrollbar { display: none; }
  .carousel-track {
    display: flex;
    gap: 10px;
    padding: 4px;
    width: max-content;
  }
  .player-card {
    flex-shrink: 0;
    width: 96px;
    background: white;
    border: 2px solid var(--border);
    border-radius: 10px;
    padding: 8px 8px;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    position: relative;
  }
  .player-card:hover { border-color: var(--black); transform: translateY(-2px); box-shadow: 0 4px 16px rgba(0,0,0,0.1); }
  .player-card.selected { border-color: var(--blue); background: #f4f6ff; }
  .player-card .card-pos {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--muted);
    margin-bottom: 3px;
  }
  .player-card .card-name {
    font-size: 12px;
    font-weight: 700;
    line-height: 1.2;
    margin-bottom: 3px;
  }
  .player-card .card-team {
    font-size: 10px;
    color: var(--muted);
  }
  .player-card .chaos-score { display: none; }
  .card-team-dot {
    display: inline-block;
    width: 6px; height: 6px;
    border-radius: 50%;
    margin-right: 3px;
    vertical-align: middle;
    margin-top: -1px;
  }
  .home-dot { background: var(--home-colour); }
  .away-dot { background: var(--away-colour); }

  .btn-pick-me {
    background: var(--blue);
    border-color: var(--blue);
    color: white;
  }
  .btn-pick-me:hover { background: #1535a8; }
  .btn-sabotage { display: none; }

  /* Auto-scroll hint */
  .carousel-hint {
    font-size: 11px;
    color: var(--muted);
    text-align: center;
  }

  /* ─── SIMULATION SCREEN ─── */
  /* ─── CAPTAIN SCREEN ─── */
  #screen-captain {
    background: white;
    flex-direction: column;
    min-height: 100dvh;
    padding-bottom: 100px;
  }
  .captain-header {
    padding: 20px 24px 12px;
    text-align: center;
  }
  .captain-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 32px;
    color: var(--black);
    letter-spacing: 2px;
    line-height: 1;
    margin-bottom: 4px;
  }
  .captain-sub {
    font-size: 12px;
    color: var(--muted);
    line-height: 1.4;
  }
  .captain-grid {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 7px;
    padding: 0 12px;
    flex: 1;
  }
  .captain-tile {
    background: var(--off-white);
    border: 2px solid var(--border);
    border-radius: 12px;
    padding: 8px 10px;
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    flex-direction: column;
    gap: 2px;
    position: relative;
    overflow: hidden;
    min-height: 0;
  }
  .captain-tile:active { transform: scale(0.96); }
  .captain-tile.selected {
    border-color: #f5a623;
    background: #fff8ed;
  }
  .captain-tile.selected::after {
    content: 'C';
    font-family: 'Bebas Neue', sans-serif;
    font-size: 11px;
    letter-spacing: 1px;
    position: absolute;
    top: 6px;
    right: 8px;
    color: #f5a623;
  }
  .captain-tile.random-tile {
    grid-column: span 2;
    background: #f5f5f5;
    border-style: dashed;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
  .captain-tile.random-tile.selected {
    border-color: #f5a623;
    background: #fff8ed;
    border-style: solid;
  }
  .captain-tile-pos {
    font-family: 'DM Mono', monospace;
    font-size: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #aaa;
  }
  .captain-tile-name {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 17px;
    color: var(--black);
    letter-spacing: 0.5px;
    line-height: 1;
  }
  .captain-tile.selected .captain-tile-name { color: #f5a623; }
  .captain-tile.random-tile .captain-tile-name {
    font-size: 13px;
    color: #888;
    text-align: center;
    font-family: 'DM Mono', monospace;
    letter-spacing: 0;
  }
  .captain-tile-team {
    font-size: 10px;
    color: #bbb;
  }
  .captain-tile-dot {
    display: inline-block;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    margin-right: 3px;
    vertical-align: middle;
  }
  .captain-footer {
    position: fixed;
    bottom: 0;
    left: 0; right: 0;
    background: white;
    border-top: 1px solid var(--border);
    padding: 10px 20px 24px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 7px;
  }
  .captain-hint {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: #aaa;
    text-align: center;
    letter-spacing: 1px;
    text-transform: uppercase;
    transition: color 0.2s;
  }
  .captain-hint.chosen { color: #f5a623; }
  .captain-confirm {
    width: 100%;
    max-width: 360px;
    font-size: 15px;
    padding: 16px 32px;
  }

  #screen-sim {
    background: white;
    flex-direction: column;
    height: 100dvh;
    max-height: 100dvh;
    overflow: hidden;
  }
  .sim-header {
    background: var(--black);
    padding: 10px 16px 8px;
    flex-shrink: 0;
  }
  .sim-scoreboard {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 6px;
  }
  .sim-player-score {
    text-align: center;
    max-width: 90px;
    min-width: 0;
  }
  .sim-player-label {
    font-size: 10px;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-family: 'DM Mono', monospace;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 90px;
  }
  .sim-score-status {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 22px;
    line-height: 1.1;
    letter-spacing: 1px;
    min-height: 26px;
    white-space: nowrap;
  }
  .sim-score-status.winning  { color: #4ade80; }
  .sim-score-status.losing   { color: #f87171; }
  .sim-score-status.level    { color: #888; }
  .sim-opp-pts {
    font-family: 'DM Mono', monospace;
    font-size: 13px;
    color: #666;
    min-height: 20px;
    white-space: nowrap;
  }
  .sim-middle {
    text-align: center;
    flex: 1;
    min-width: 0;
    padding: 0 6px;
  }
  .sim-gap-line {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: #666;
    line-height: 1.4;
    white-space: nowrap;
  }

  /* ─── PREDICTION OVERLAY ─── */
  .prediction-overlay {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    background: var(--black);
    padding: 16px 20px 32px;
    z-index: 100;
    animation: pred-slide-up 0.25s ease;
  }
  @keyframes pred-slide-up {
    from { transform: translateY(100%); opacity: 0; }
    to   { transform: translateY(0);    opacity: 1; }
  }
  .prediction-question {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 22px;
    letter-spacing: 1px;
    color: white;
    text-align: center;
    margin-bottom: 10px;
    line-height: 1.3;
  }
  .prediction-timer-bar {
    height: 3px;
    background: #333;
    border-radius: 2px;
    overflow: hidden;
    margin-bottom: 14px;
  }
  .prediction-timer-fill {
    height: 100%;
    background: #f5a623;
    border-radius: 2px;
    width: 100%;
    transition: width 3s linear;
  }
  .prediction-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }
  .pred-btn {
    padding: 14px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
    transition: transform 0.1s, opacity 0.1s;
  }
  .pred-btn:active { transform: scale(0.96); }
  .pred-yes { background: #16a34a; color: white; }
  .pred-no  { background: #dc2626; color: white; }
  .pred-btn.selected { outline: 3px solid white; }
  .pred-btn:disabled { opacity: 0.4; pointer-events: none; }

  /* ─── REVEAL TIP CARD ─── */
  .reveal-tip-card {
    margin: 14px 0 8px;
    border: 1.5px solid #333;
    border-radius: 12px;
    padding: 12px 16px;
    text-align: center;
    width: 100%;
    box-sizing: border-box;
  }
  .reveal-tip-btn {
    background: none;
    border: none;
    color: #f5a623;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    width: 100%;
    padding: 0;
  }
  .reveal-tip-btn:disabled {
    color: #555;
    cursor: default;
  }
  .reveal-tip-cost {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: #555;
    margin-top: 4px;
    letter-spacing: 1px;
  }
  .reveal-tip-content {
    margin-top: 10px;
    font-size: 13px;
    color: #ccc;
    line-height: 1.5;
    border-top: 1px solid #333;
    padding-top: 10px;
  }
  .reveal-tip-content strong { color: white; }
  .reveal-tip-taken {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: #f5a623;
    margin-top: 6px;
    letter-spacing: 1px;
  }

  /* ─── HALF TIME OVERLAY ─── */
  .ht-overlay {
    position: fixed;
    inset: 0;
    background: #111;
    z-index: 150;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 10px;
    animation: ht-fade-in 0.3s ease;
  }
  @keyframes ht-fade-in {
    from { opacity: 0; }
    to   { opacity: 1; }
  }
  .ht-whistle {
    font-size: 52px;
    margin-bottom: 4px;
  }
  .ht-label {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 52px;
    letter-spacing: 4px;
    color: #f5c842;
    line-height: 1;
  }
  .ht-score {
    font-family: 'DM Mono', monospace;
    font-size: 14px;
    color: #888;
    letter-spacing: 2px;
    margin-top: 4px;
  }
  .ht-sub {
    font-size: 13px;
    color: #555;
    font-style: italic;
    margin-top: 8px;
  }

  /* ─── PREDICTION RESULT FLASH ─── */
  .pred-result-flash {
    position: fixed;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: #111;
    color: white;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 34px;
    letter-spacing: 3px;
    padding: 18px 32px;
    border-radius: 14px;
    z-index: 300;
    opacity: 0;
    transition: opacity 0.18s ease, transform 0.18s ease;
    pointer-events: none;
    text-align: center;
    border: 3px solid transparent;
  }
  .pred-result-flash.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
  .pred-result-flash.correct { border-color: #16a34a; color: #4ade80; }
  .pred-result-flash.wrong   { border-color: #dc2626; color: #f87171; }
  .pred-result-flash.timeout { border-color: #555; }

  /* ─── LOBBY SCREEN ─── */
  #screen-lobby {
    background: var(--black);
    flex-direction: column;
    min-height: 100dvh;
    color: white;
  }
  .lobby-inner {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 24px 24px 48px;
    width: 100%;
    max-width: 420px;
    margin: 0 auto;
    box-sizing: border-box;
    gap: 0;
  }
  .lobby-phase {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    gap: 16px;
    animation: phase-in 0.3s ease;
  }
  .lobby-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 40px;
    letter-spacing: 2px;
    color: white;
    text-align: center;
    margin-top: 16px;
  }
  .lobby-sub {
    font-size: 14px;
    color: #888;
    text-align: center;
    line-height: 1.6;
    max-width: 300px;
  }
  .lobby-btn {
    background: white;
    color: var(--black);
    border: none;
    border-radius: 14px;
    padding: 16px 32px;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
    width: 100%;
    max-width: 280px;
    transition: opacity 0.15s;
  }
  .lobby-btn:active { opacity: 0.8; }
  .lobby-btn-sm {
    background: white;
    color: var(--black);
    border: none;
    border-radius: 10px;
    padding: 12px 20px;
    font-size: 15px;
    font-weight: 700;
    cursor: pointer;
    white-space: nowrap;
    flex-shrink: 0;
  }
  .lobby-divider {
    font-size: 12px;
    color: #444;
    letter-spacing: 2px;
  }
  .lobby-join-row {
    display: flex;
    gap: 10px;
    width: 100%;
    max-width: 280px;
  }
  .lobby-code-input {
    flex: 1;
    background: #1a1a1a;
    border: 1.5px solid #333;
    border-radius: 10px;
    color: white;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 28px;
    letter-spacing: 8px;
    padding: 10px 16px;
    text-align: center;
    outline: none;
    min-width: 0;
  }
  .lobby-code-input:focus { border-color: #555; }
  .lobby-code-display {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 72px;
    letter-spacing: 12px;
    color: white;
    line-height: 1;
    margin: 8px 0;
  }
  .lobby-waiting-status {
    background: #111;
    border-radius: 14px;
    padding: 16px 20px;
    width: 100%;
    max-width: 280px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    box-sizing: border-box;
  }
  .lobby-player-row {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 14px;
    color: #ccc;
  }
  .lobby-player-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  .lobby-player-dot.ready   { background: #16a34a; }
  .lobby-player-dot.waiting { background: #444; animation: dot-pulse 1.5s ease-in-out infinite; }
  @keyframes dot-pulse {
    0%, 100% { opacity: 0.3; }
    50%       { opacity: 1; }
  }
  .lobby-ready-tag {
    margin-left: auto;
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    letter-spacing: 1px;
    color: #16a34a;
  }
  .lobby-hint {
    font-size: 12px;
    color: #444;
    text-align: center;
    font-style: italic;
  }
  .lobby-error {
    font-size: 13px;
    color: #f87171;
    text-align: center;
  }

  /* ─── HOME SCREEN mp button ─── */
  #mp-btn { margin-top: 10px; }
  .score-bar-track {
    height: 3px;
    background: #222;
    border-radius: 2px;
    position: relative;
    overflow: hidden;
  }
  .score-bar-fill {
    position: absolute;
    top: 0; bottom: 0; left: 0;
    background: #7c9fff;
    transition: width 0.5s ease;
  }

  /* Match clock */
  .match-clock {
    text-align: center;
    padding: 5px 8px;
    font-family: 'DM Mono', monospace;
    font-size: 12px;
    font-weight: 700;
    color: var(--muted);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }

  /* Team view toggle */
  .sim-view-toggle {
    display: flex;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .sim-view-toggle button {
    flex: 1;
    padding: 8px;
    border: none;
    background: none;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    color: var(--muted);
    border-bottom: 2px solid transparent;
    transition: all 0.15s;
  }
  .sim-view-toggle button.active {
    color: var(--black);
    border-bottom-color: var(--black);
  }

  /* Player list during sim — this is the only scrolling zone */
  .sim-players {
    flex: 1;
    overflow-y: auto;
    padding: 6px 12px;
    min-height: 0;
  }
  .sim-player-row {
    display: flex;
    align-items: center;
    padding: 6px 10px;
    border-radius: 8px;
    margin-bottom: 4px;
    border: 1.5px solid transparent;
    transition: all 0.3s;
    position: relative;
  }
  .sim-player-row.team-home    { background: var(--home-colour-light); border-color: var(--home-colour-border); }
  .sim-player-row.team-away { background: var(--away-colour-light); border-color: var(--away-colour-border); }
  .sim-player-row.flash-positive { border-color: #22c55e !important; background: #f0fdf4 !important; animation: flash-pulse 0.7s ease; }
  .sim-player-row.flash-negative { border-color: #ef4444 !important; background: #fff1f1 !important; animation: flash-pulse 0.7s ease; }
  .sim-player-row.subbed-off   { opacity: 0.45; }
  @keyframes flash-pulse {
    0% { transform: scale(1.02); }
    100% { transform: scale(1); }
  }
  .sim-player-pos {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: var(--muted);
    width: 26px;
    text-transform: uppercase;
  }
  .sim-player-name {
    flex: 1;
    font-size: 13px;
    font-weight: 500;
  }
  .sim-player-events {
    display: flex;
    gap: 3px;
    align-items: center;
  }
  .event-icon {
    font-size: 13px;
    animation: pop-in 0.3s ease;
  }
  @keyframes pop-in {
    0% { transform: scale(0); opacity: 0; }
    70% { transform: scale(1.3); }
    100% { transform: scale(1); opacity: 1; }
  }
  .sim-player-pts {
    font-family: 'DM Mono', monospace;
    font-size: 12px;
    font-weight: 500;
    width: 44px;
    text-align: right;
  }
  .pts-positive { color: var(--red); }
  .pts-negative { color: var(--green); }
  .pts-neutral { color: var(--muted); }

  /* Delta popups */
  .delta-popup {
    position: absolute;
    right: 12px;
    top: -8px;
    font-family: 'DM Mono', monospace;
    font-size: 13px;
    font-weight: 700;
    animation: float-up 1.2s ease forwards;
    pointer-events: none;
    z-index: 10;
  }
  .delta-popup.positive { color: var(--red); }
  .delta-popup.negative { color: var(--green); }
  @keyframes float-up {
    0% { opacity: 1; transform: translateY(0); }
    100% { opacity: 0; transform: translateY(-24px); }
  }

  /* Live actual scoreline */
  .live-scoreline {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 16px;
    background: #111;
    border-top: 1px solid #222;
    flex-shrink: 0;
  }
  .live-left {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .live-pill {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    font-weight: 700;
    letter-spacing: 1.5px;
    color: #fff;
    background: var(--red);
    padding: 2px 6px;
    border-radius: 4px;
    animation: live-pulse 1.5s ease-in-out infinite;
  }
  @keyframes live-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  .live-teams {
    font-size: 12px;
    color: #aaa;
    font-weight: 400;
  }
  .live-teams strong { color: white; font-weight: 700; }
  .live-clock {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    font-weight: 700;
    color: #aaa;
  }
  .autocomplete-btn {
    background: none;
    border: none;
    color: #666;
    font-size: 18px;
    padding: 2px 4px;
    cursor: pointer;
    line-height: 1;
    transition: color 0.15s;
    flex-shrink: 0;
  }
  .autocomplete-btn:hover { color: #fff; }

  /* Commentary feed — pinned to bottom */
  .commentary-feed {
    background: var(--black);
    padding: 10px 16px;
    min-height: 48px;
    max-height: 48px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    flex-shrink: 0;
    transition: max-height 0.4s ease, padding 0.4s ease, background 0.3s ease;
    overflow: hidden;
  }
  .commentary-feed.feed-building {
    max-height: 120px;
    padding: 14px 16px;
    background: #0a0a0a;
  }
  .commentary-feed.feed-building .commentary-line {
    font-size: 15px;
    color: #e0e0e0;
  }
  .commentary-feed.feed-halftime {
    background: #1a1400;
    max-height: 56px;
  }
  .commentary-feed.feed-halftime .commentary-line {
    color: #f5c842;
    font-style: normal;
    font-weight: 600;
    font-size: 13px;
  }
  .commentary-line {
    font-size: 13px;
    color: #ccc;
    line-height: 1.4;
    font-style: italic;
    transition: opacity 0.3s;
    min-width: 0;
  }
  .commentary-lines {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  .commentary-line-sub {
    font-size: 11px;
    color: #666;
    font-style: italic;
    opacity: 0;
    transition: opacity 0.5s ease 0.2s;
  }
  .feed-building .commentary-line-sub { opacity: 1; }
  .commentary-line strong { color: white; font-style: normal; }
  .commentary-line-sub strong { color: #999; font-style: normal; }
  .commentary-feed.feed-flash-pos {
    animation: flash-green 1.6s ease forwards;
  }
  .commentary-feed.feed-flash-neg {
    animation: flash-red 1.6s ease forwards;
  }
  @keyframes flash-green {
    0%   { background: #14532d; }
    10%  { background: #14532d; }
    20%  { background: #111; }
    30%  { background: #14532d; }
    40%  { background: #111; }
    50%  { background: #14532d; }
    60%  { background: #111; }
    70%  { background: #14532d; }
    80%  { background: #111; }
    90%  { background: #14532d; }
    100% { background: #111; }
  }
  @keyframes flash-red {
    0%   { background: #7f1d1d; }
    10%  { background: #7f1d1d; }
    20%  { background: #111; }
    30%  { background: #7f1d1d; }
    40%  { background: #111; }
    50%  { background: #7f1d1d; }
    60%  { background: #111; }
    70%  { background: #7f1d1d; }
    80%  { background: #111; }
    90%  { background: #7f1d1d; }
    100% { background: #111; }
  }
  .commentary-emoji {
    font-size: 20px;
    flex-shrink: 0;
    transition: opacity 0.3s;
    min-width: 24px;
    text-align: center;
  }

  /* ─── RESULTS SCREEN ─── */
  #screen-results {
    background: var(--off-white);
  }
  .results-header {
    background: var(--black);
    padding: 32px 24px 24px;
    text-align: center;
  }
  .result-headline {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 52px;
    color: white;
    letter-spacing: 2px;
    line-height: 1;
    margin-bottom: 4px;
  }
  .result-sub {
    font-size: 14px;
    color: var(--muted);
  }
  .results-scores {
    padding: 20px 24px 8px;
    max-width: 600px;
    margin: 0 auto;
  }
  .result-score-card {
    background: white;
    border-radius: 20px;
    padding: 28px 24px 24px;
    text-align: center;
    border: 2px solid var(--border);
    width: 100%;
  }
  .result-score-card.full { display: block; }
  .result-score-card.winner { border-color: #22c55e; }
  .result-score-card.loser  { border-color: #ef4444; }
  .result-score-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
  }
  .result-score-emoji {
    font-size: 48px;
    line-height: 1;
    margin-bottom: 8px;
  }
  .result-outcome {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 56px;
    line-height: 1;
    margin: 4px 0 10px;
  }
  .result-score-card.winner .result-outcome { color: #16a34a; }
  .result-score-card.loser  .result-outcome { color: #dc2626; }
  .result-score-card.tied   .result-outcome { color: #888; }
  .result-score-detail {
    font-size: 14px;
    color: #555;
    margin-top: 2px;
    line-height: 1.5;
  }
  .result-score-card.winner .result-score-detail { color: #15803d; }
  .result-score-card.loser  .result-score-detail { color: #b91c1c; }

  .results-body {
    padding: 0 24px 24px;
    max-width: 600px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .result-section {
    background: white;
    border-radius: 16px;
    padding: 20px;
    border: 1px solid var(--border);
  }
  .result-section-title {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 14px;
  }

  /* ── Stats table ── */
  .stats-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
  }
  .stats-header {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    margin-bottom: 10px;
  }
  .stats-team-name {
    font-family: 'Bebas Neue', cursive;
    font-size: 16px;
    letter-spacing: 1px;
    color: #222;
  }
  .stats-team-name:last-child { text-align: right; }
  .stat-row {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    padding: 7px 0;
    border-bottom: 1px solid var(--border);
  }
  .stat-row:last-child { border-bottom: none; }
  .stat-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--muted);
    text-align: center;
    padding: 0 12px;
    white-space: nowrap;
  }
  .stat-home { text-align: left; }
  .stat-away { text-align: right; }
  .stat-val-active {
    font-family: 'Bebas Neue', cursive;
    font-size: 22px;
    color: #111;
    line-height: 1;
  }
  .stat-val-zero {
    font-size: 14px;
    color: #ccc;
  }

  /* ── Good, Bad & Ugly ── */
  .gbu-grid {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .gbu-tile {
    border-radius: 12px;
    padding: 14px 16px;
    border-left: 4px solid transparent;
  }
  .gbu-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 8px;
    font-weight: 700;
  }
  .gbu-text {
    font-size: 13px;
    line-height: 1.6;
    color: #333;
  }
  .gbu-text strong { font-weight: 700; }
  .gbu-text em { font-style: italic; }
  .gbu-good {
    background: #f0fdf4;
    border-left-color: #86efac;
  }
  .gbu-good .gbu-label { color: #16a34a; }
  .gbu-bad {
    background: #fefce8;
    border-left-color: #fde047;
  }
  .gbu-bad .gbu-label { color: #ca8a04; }
  .gbu-ugly {
    background: #fff1f2;
    border-left-color: #fca5a5;
  }
  .gbu-ugly .gbu-label { color: #dc2626; }

  .chaos-rating {
    text-align: center;
    padding: 8px;
  }
  .chaos-pct {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 48px;
    color: var(--red);
    line-height: 1;
  }
  .chaos-desc { font-size: 14px; color: var(--muted); margin-top: 4px; }

  .contributor-row {
    display: flex;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid var(--border);
  }
  .contributor-row:last-child { border-bottom: none; }
  .contributor-pos {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: var(--muted);
    width: 28px;
    text-transform: uppercase;
  }
  .contributor-name { flex: 1; font-size: 14px; font-weight: 500; }
  .contributor-team { font-size: 11px; color: var(--muted); }
  .contributor-pts {
    font-family: 'DM Mono', monospace;
    font-size: 14px;
    font-weight: 700;
    color: var(--red);
  }

  .moment-row {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    padding: 8px 0;
    border-bottom: 1px solid var(--border);
  }
  .moment-row:last-child { border-bottom: none; }
  .moment-icon { font-size: 20px; flex-shrink: 0; }
  .moment-text { font-size: 13px; line-height: 1.5; color: #333; }
  .moment-text strong { font-weight: 600; }
  .moment-swing {
    font-family: 'DM Mono', monospace;
    font-size: 12px;
    color: var(--red);
    font-weight: 700;
    margin-left: auto;
    flex-shrink: 0;
  }

  .badges-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .badge {
    background: var(--off-white);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 10px 14px;
    text-align: center;
    min-width: 100px;
  }
  .badge-icon { font-size: 24px; display: block; margin-bottom: 4px; }
  .badge-name { font-size: 11px; font-weight: 600; display: block; }
  .badge-desc { font-size: 10px; color: var(--muted); display: block; }

  .cta-row {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }
  .cta-row button {
    flex: 1;
    min-width: 120px;
    padding: 14px 20px;
    border-radius: 12px;
    border: none;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
  }
  .cta-rematch { background: var(--black); color: white; }
  .cta-rematch:hover { background: #222; }
  .cta-share { background: white; color: var(--black); border: 1.5px solid var(--border) !important; border: none; }
  .cta-share:hover { background: var(--off-white); }

  /* ─── TEAM NAME CARD ─── */
  .team-name-card {
    background: white;
    border: 1.5px solid var(--border);
    border-radius: 16px;
    padding: 12px 16px;
    width: 100%;
    max-width: 360px;
    margin-bottom: 12px;
  }
  .team-name-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 10px;
  }
  .team-name-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .emoji-pick-btn {
    font-size: 28px;
    background: var(--off-white);
    border: 1.5px solid var(--border);
    border-radius: 10px;
    width: 52px;
    height: 52px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    flex-shrink: 0;
    transition: background 0.15s;
    line-height: 1;
  }
  .emoji-pick-btn:hover { background: #e8e8e8; }
  .team-name-input {
    flex: 1;
    border: 1.5px solid var(--border);
    border-radius: 10px;
    padding: 12px 14px;
    font-size: 16px;
    font-family: 'DM Sans', sans-serif;
    font-weight: 600;
    outline: none;
    transition: border-color 0.15s;
    color: var(--black);
  }
  .team-name-input:focus { border-color: var(--black); }
  .team-name-input::placeholder { color: #ccc; font-weight: 400; }
  .emoji-hint {
    font-size: 11px;
    color: #bbb;
    margin-top: 7px;
  }
  .emoji-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 6px;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border);
  }
  .emoji-grid-item {
    font-size: 24px;
    background: var(--off-white);
    border: 1.5px solid transparent;
    border-radius: 8px;
    padding: 6px 0;
    text-align: center;
    cursor: pointer;
    transition: all 0.12s;
    line-height: 1;
  }
  .emoji-grid-item:hover { background: #e8e8e8; }
  .emoji-grid-item.selected { border-color: var(--black); background: #f0f0f0; }

  /* ─── PRE-MATCH REPORT ─── */
  .prematch-report {
    font-size: 13px;
    line-height: 1.65;
    color: #aaa;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #333;
  }
  .prematch-report strong { color: white; }

  /* Notification toast */
  .toast {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--black);
    color: white;
    padding: 12px 24px;
    border-radius: 10px;
    font-size: 14px;
    z-index: 999;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
  }
  .toast.show { opacity: 1; }

  /* ─── HOME SCREEN — PROFILE FIRST ─── */
  .home-profile-section {
    width: 100%;
    max-width: 360px;
    margin-bottom: 12px;
  }
  .profile-pick-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 8px;
  }
  .profile-cards-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 8px;
  }
  .profile-card {
    background: white;
    border: 2px solid var(--border);
    border-radius: 14px;
    padding: 12px 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 12px;
    transition: all 0.15s;
  }
  .profile-card:active { transform: scale(0.98); }
  .profile-card.active-profile {
    border-color: var(--black);
    background: var(--off-white);
  }
  .profile-card-emoji { font-size: 28px; flex-shrink: 0; }
  .profile-card-info { flex: 1; min-width: 0; }
  .profile-card-name {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 20px;
    letter-spacing: 1px;
    color: var(--black);
    line-height: 1;
  }
  .profile-card-stats {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: var(--muted);
    margin-top: 2px;
  }
  .profile-card-form { display: flex; gap: 3px; margin-top: 5px; }
  .form-pip {
    width: 14px; height: 14px; border-radius: 3px;
    font-size: 8px; font-weight: 700; color: white;
    display: flex; align-items: center; justify-content: center;
  }
  .form-pip.W { background: #16a34a; }
  .form-pip.L { background: #dc2626; }
  .form-pip.D { background: #888; }
  .form-pip.empty { background: #e5e5e5; }
  .profile-card-arrow {
    font-size: 18px;
    color: #ccc;
    flex-shrink: 0;
  }
  .profile-card-viewbtn {
    background: none;
    border: none;
    font-size: 11px;
    color: var(--muted);
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 6px;
    flex-shrink: 0;
    text-decoration: underline;
  }
  .profile-new-btn {
    width: 100%;
    background: none;
    border: 1.5px dashed #ccc;
    border-radius: 14px;
    padding: 12px;
    font-family: 'DM Mono', monospace;
    font-size: 12px;
    color: #aaa;
    cursor: pointer;
    transition: all 0.15s;
    letter-spacing: 1px;
  }
  .profile-new-btn:hover { border-color: #999; color: #666; }
  .profile-new-form {
    background: white;
    border: 2px solid var(--black);
    border-radius: 14px;
    padding: 14px 16px;
    display: none;
    flex-direction: column;
    gap: 10px;
  }
  .profile-new-form.open { display: flex; }
  .profile-new-row { display: flex; gap: 8px; align-items: center; }
  .profile-new-input {
    flex: 1;
    border: 1.5px solid var(--border);
    border-radius: 8px;
    padding: 10px 12px;
    font-size: 15px;
    font-family: 'DM Sans', sans-serif;
    outline: none;
  }
  .profile-new-input:focus { border-color: var(--black); }
  .profile-new-save {
    background: var(--black);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 10px 16px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
  }

  /* ─── PROFILE SCREEN ─── */
  #screen-profile {
    background: var(--off-white);
    flex-direction: column;
    min-height: 100dvh;
  }
  .profile-header {
    background: var(--black);
    padding: 20px 20px 24px;
    color: white;
  }
  .profile-back-btn {
    background: none;
    border: none;
    color: #666;
    font-size: 13px;
    cursor: pointer;
    padding: 0;
    margin-bottom: 12px;
    display: block;
    font-family: 'DM Mono', monospace;
    letter-spacing: 1px;
  }
  .profile-header-main {
    display: flex;
    align-items: center;
    gap: 14px;
  }
  .profile-header-emoji { font-size: 42px; }
  .profile-name-big {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 38px;
    letter-spacing: 2px;
    line-height: 1;
    color: white;
  }
  .profile-header-sub {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: #555;
    margin-top: 4px;
    letter-spacing: 1px;
    text-transform: uppercase;
  }
  .profile-body {
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 14px;
  }
  .profile-stat-row {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 10px;
  }
  .profile-stat-card {
    background: white;
    border-radius: 14px;
    padding: 14px 10px;
    text-align: center;
    border: 1.5px solid var(--border);
  }
  .profile-stat-num {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 32px;
    color: var(--black);
    line-height: 1;
  }
  .profile-stat-label {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--muted);
    margin-top: 3px;
  }
  .profile-section {
    background: white;
    border-radius: 14px;
    padding: 14px 16px;
    border: 1.5px solid var(--border);
  }
  .profile-section-title {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 10px;
  }
  .profile-form-strip {
    display: flex;
    gap: 6px;
  }
  .profile-form-pill {
    width: 36px; height: 36px;
    border-radius: 8px;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 16px;
    color: white;
    display: flex; align-items: center; justify-content: center;
  }
  .profile-form-pill.W { background: #16a34a; }
  .profile-form-pill.L { background: #dc2626; }
  .profile-form-pill.D { background: #888; }
  .profile-form-pill.empty { background: #f0f0f0; color: #ccc; }
  .profile-archive-bar-wrap { display: flex; flex-direction: column; gap: 8px; }
  .profile-archive-bar {
    height: 8px;
    background: #f0f0f0;
    border-radius: 4px;
    overflow: hidden;
  }
  .profile-archive-fill {
    height: 100%;
    background: var(--black);
    border-radius: 4px;
    transition: width 0.6s ease;
  }
  .profile-archive-label {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: var(--muted);
  }
  .profile-history-row {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 0;
    border-bottom: 1px solid var(--border);
  }
  .profile-history-row:last-child { border-bottom: none; }
  .profile-history-result {
    width: 28px; height: 28px;
    border-radius: 6px;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 14px;
    color: white;
    display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
  }
  .profile-history-result.W { background: #16a34a; }
  .profile-history-result.L { background: #dc2626; }
  .profile-history-result.D { background: #888; }
  .profile-history-match { flex: 1; min-width: 0; }
  .profile-history-matchname {
    font-size: 13px;
    font-weight: 600;
    color: var(--black);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .profile-history-meta {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: var(--muted);
    margin-top: 1px;
  }
  .profile-history-score {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: var(--muted);
    flex-shrink: 0;
  }
  .profile-badges-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
  }
  .profile-badge {
    background: var(--off-white);
    border: 1.5px solid var(--border);
    border-radius: 12px;
    padding: 12px 8px;
    text-align: center;
  }
  .profile-badge.earned { border-color: #f5a623; background: #fff8ed; }
  .profile-badge.locked { opacity: 0.4; }
  .profile-badge-icon { font-size: 26px; display: block; margin-bottom: 4px; }
  .profile-badge-name { font-size: 10px; font-weight: 700; display: block; color: var(--black); }
  .profile-badge-desc { font-size: 9px; color: var(--muted); display: block; margin-top: 2px; }

  /* ─── POST-MATCH FORM TILE ─── */
  .result-form-tile {
    background: white;
    border: 1.5px solid var(--border);
    border-radius: 16px;
    padding: 16px;
    margin-bottom: 0;
  }
  .result-form-title {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 10px;
  }
  .result-form-row {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
  }
  .result-form-stats {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: var(--muted);
    margin-top: 8px;
  }
  .result-view-profile-btn {
    width: 100%;
    margin-top: 10px;
    background: var(--black);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 12px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.15s;
  }
  .result-view-profile-btn:hover { background: #222; }

  /* Coin flip screen — full loading/reveal experience */
  #screen-coin {
    background: var(--black);
    color: white;
  }
  .coin-screen-inner {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px 24px;
    text-align: center;
    width: 100%;
    box-sizing: border-box;
  }
  .coin-phase {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    animation: phase-in 0.4s ease;
  }
  @keyframes phase-in {
    from { opacity: 0; transform: translateY(10px); }
    to   { opacity: 1; transform: translateY(0); }
  }
  .coin-phase-label {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    letter-spacing: 2px;
    color: #666;
    text-transform: uppercase;
    margin-bottom: 20px;
  }
  .coin-loading-tape {
    font-size: 64px;
    margin-bottom: 20px;
    animation: tape-wobble 1s ease-in-out infinite;
  }
  @keyframes tape-wobble {
    0%, 100% { transform: rotate(-4deg); }
    50%       { transform: rotate(4deg); }
  }
  .coin-loading-lines {
    font-family: 'DM Mono', monospace;
    font-size: 13px;
    color: #555;
    min-height: 20px;
  }
  .coin-reveal-matchup {
    font-family: 'Bebas Neue', cursive;
    font-size: 34px;
    letter-spacing: 1px;
    line-height: 1.1;
    color: white;
    margin-bottom: 6px;
  }
  .coin-reveal-date {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: #666;
    margin-bottom: 20px;
    letter-spacing: 1px;
  }
  .coin-reveal-blurb {
    font-size: 14px;
    line-height: 1.7;
    color: #ccc;
    max-width: 340px;
    text-align: left;
    margin-bottom: 28px;
  }
  .coin-reveal-blurb strong { color: white; }
  .coin-countdown-bar {
    width: 100%;
    max-width: 320px;
    height: 3px;
    background: #222;
    border-radius: 2px;
    overflow: hidden;
    margin-bottom: 10px;
  }
  .coin-countdown-fill {
    height: 100%;
    background: #555;
    width: 100%;
    transition: width 1s linear;
  }
  .coin-countdown-label {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: #555;
    letter-spacing: 1px;
  }

  /* Updated match preview for dynamic content */
  .match-team-name.home-team { color: #6CABDD; }
  .match-team-name.away-team { color: #FBEE23; text-shadow: 0 0 1px #aaa; }
</style>
<!-- ═══════════════════════ FIREBASE ═══════════════════════ -->
<!-- Replace the firebaseConfig object below with your own   -->
<!-- from Firebase Console → Project Settings → Your apps    -->
<script type="module">
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
  import { getDatabase, ref, set, get, update, onValue, off, serverTimestamp }
    from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js';

  const firebaseConfig = {
    apiKey:            "AIzaSyCUy5gY30n7DNLg2V20gZm05HKHk2RNIic",
    authDomain:        "worst-eleven.firebaseapp.com",
    databaseURL:       "https://worst-eleven-default-rtdb.europe-west1.firebasedatabase.app",
    projectId:         "worst-eleven",
    storageBucket:     "worst-eleven.firebasestorage.app",
    messagingSenderId: "340747531029",
    appId:             "1:340747531029:web:aad6a3cdbdc08e95aaef1c",
    measurementId:     "G-6F5HPEH1S4",
  };

  let app, db;
  try {
    app = initializeApp(firebaseConfig);
    db  = getDatabase(app);
    window._fbReady = true;
  } catch(e) {
    console.warn('Firebase not configured — multiplayer disabled.', e.message);
    window._fbReady = false;
  }

  // Expose Firebase helpers on window so the main (non-module) script can reach them
  window._fb = {
    ref:             (path)           => ref(db, path),
    set:             (r, v)           => set(r, v),
    get:             (r)              => get(r),
    update:          (r, v)           => update(r, v),
    onValue:         (r, cb)          => onValue(r, cb),
    off:             (r)              => off(r),
    serverTimestamp: ()               => serverTimestamp(),
  };
</script>
</head>
<body>

<!-- ═══════════════════════════════════════ HOME ═══════════════════════════════════════ -->
<div id="screen-home" class="screen active">
  <div style="margin-bottom: 16px;">
    <div class="home-logo">WORST<br><span>ELEVEN</span></div>
    <div class="home-tagline">Draft the worst. <span class="tagline-score">Score the most. 😈</span></div>
  </div>

  <!-- How to play — shown first -->
  <div class="home-rules">
    <div class="home-rules-title">How to play</div>
    <div class="home-rule-step">
      <span class="home-rule-num">1</span>
      <span><strong>Pick your team name and crest</strong> below, then hit Go to Draft.</span>
    </div>
    <div class="home-rule-step">
      <span class="home-rule-num">2</span>
      <span><strong>A mystery match from the archives</strong> will fire up — you won't know the score.</span>
    </div>
    <div class="home-rule-step">
      <span class="home-rule-num">3</span>
      <span><strong>A coin toss</strong> decides who picks goalkeeper first. The other keeper goes straight to your opponent.</span>
    </div>
    <div class="home-rule-step">
      <span class="home-rule-num">4</span>
      <span><strong>Draft the worst eleven</strong> you can remember from that game. Who stank the place out?</span>
    </div>
    <div class="home-rule-step">
      <span class="home-rule-num">5</span>
      <span><strong>Sabotage your opponent</strong> — your first 3 picks go to <em>their</em> squad. Send them the stars.</span>
    </div>
  </div>

  <!-- Profile selector — pick or create, this IS the first step -->
  <div class="home-profile-section">
    <div class="profile-pick-label">Your Profile</div>

    <!-- Existing profiles list (populated by JS) -->
    <div class="profile-cards-list" id="home-profiles-list"></div>

    <!-- New profile creation -->
    <button class="profile-new-btn" id="profile-new-btn" onclick="openNewProfileForm()">+ Create new profile</button>
    <div class="profile-new-form" id="profile-new-form">
      <div class="profile-new-row">
        <button class="emoji-pick-btn" id="emoji-btn" onclick="toggleEmojiPicker()">⚽</button>
        <input class="profile-new-input" id="team-name-input" type="text" placeholder="Team name…" maxlength="24" oninput="onTeamNameInput()"/>
        <button class="profile-new-save" id="profile-save-btn" onclick="saveNewProfile()" disabled>Save</button>
      </div>
      <div class="emoji-hint">Tap the crest to pick · <span style="cursor:pointer;text-decoration:underline;" onclick="randomEmoji()">randomise</span></div>
      <div class="emoji-grid" id="emoji-grid" style="display:none;"></div>
    </div>
  </div>

  <button class="btn-primary" id="start-btn" onclick="startGame()" style="font-size: 18px; padding: 20px 60px;" disabled>
    Go to Draft →
  </button>
  <button class="btn-primary dark" id="mp-btn" onclick="openLobby()" style="font-size:15px;padding:14px 40px;margin-top:0;" disabled>
    ⚽ Play vs Friend
  </button>

  <!-- Scoring mechanics — brief, below the button -->
  <div class="home-scoring">
    <div class="home-scoring-title">Scoring</div>
    <div class="home-scoring-row"><span class="score-pill pos">+20</span> GK red card</div>
    <div class="home-scoring-row"><span class="score-pill pos">+10</span> Red card (outfield)</div>
    <div class="home-scoring-row"><span class="score-pill pos">+10</span> Own goal / missed pen</div>
    <div class="home-scoring-row"><span class="score-pill pos">+8</span> GK yellow card</div>
    <div class="home-scoring-row"><span class="score-pill pos">+4</span> Yellow card (outfield)</div>
    <div class="home-scoring-row"><span class="score-pill pos">+1–5</span> Subbed off early</div>
    <div class="home-scoring-row"><span class="score-pill neg">−3</span> Playing the full 90'</div>
    <div class="home-scoring-row"><span class="score-pill neg">−3–6</span> Goal scored</div>
    <div class="home-scoring-row"><span class="score-pill neg">−3–6</span> Assist</div>
    <div class="home-scoring-row" style="color:#777;font-size:11px;margin-top:4px;">Higher score wins · goals &amp; assists hurt you</div>
  </div>
</div>

<!-- ═══════════════════════════════════════ LOBBY ═══════════════════════════════════════ -->
<div id="screen-lobby" class="screen">
  <div class="lobby-inner">

    <button class="profile-back-btn" onclick="leaveLobby()" style="align-self:flex-start;margin-bottom:8px;">← Back</button>

    <!-- Phase: choose create or join -->
    <div id="lobby-phase-choose" class="lobby-phase">
      <div class="lobby-title">Play vs Friend</div>
      <div class="lobby-sub">You'll both watch the same match and draft live against each other.</div>
      <button class="lobby-btn" onclick="createGame()">🏟️ Create a game</button>
      <div class="lobby-divider">or</div>
      <div class="lobby-join-row">
        <input class="lobby-code-input" id="join-code-input" type="text" maxlength="4"
          placeholder="Enter code" oninput="this.value=this.value.toUpperCase()"/>
        <button class="lobby-btn-sm" onclick="joinGame()">Join →</button>
      </div>
      <div class="lobby-error" id="lobby-error" style="display:none"></div>
    </div>

    <!-- Phase: waiting room (host) -->
    <div id="lobby-phase-waiting" class="lobby-phase" style="display:none">
      <div class="lobby-title">Game Created</div>
      <div class="lobby-sub">Share this code with your friend</div>
      <div class="lobby-code-display" id="lobby-code-display">—</div>
      <div class="lobby-waiting-status" id="lobby-waiting-status">
        <div class="lobby-player-row">
          <div class="lobby-player-dot ready"></div>
          <span id="lobby-name-a">You</span>
          <span class="lobby-ready-tag">Ready</span>
        </div>
        <div class="lobby-player-row">
          <div class="lobby-player-dot waiting"></div>
          <span id="lobby-name-b">Waiting for opponent…</span>
        </div>
      </div>
      <div class="lobby-hint">Game starts automatically when your friend joins</div>
    </div>

    <!-- Phase: joined (guest) -->
    <div id="lobby-phase-joined" class="lobby-phase" style="display:none">
      <div class="lobby-title">Joined!</div>
      <div class="lobby-sub" id="lobby-joined-sub">Waiting for host to start…</div>
      <div class="lobby-waiting-status" id="lobby-joined-status">
        <div class="lobby-player-row">
          <div class="lobby-player-dot ready"></div>
          <span id="lobby-joined-name-a">Host</span>
          <span class="lobby-ready-tag">Ready</span>
        </div>
        <div class="lobby-player-row">
          <div class="lobby-player-dot ready"></div>
          <span id="lobby-joined-name-b">You</span>
          <span class="lobby-ready-tag">Ready</span>
        </div>
      </div>
      <div class="lobby-hint">Starting shortly…</div>
    </div>

  </div>
</div>

<!-- ═══════════════════════════════════════ PROFILE ═══════════════════════════════════════ -->
<div id="screen-profile" class="screen">
  <div class="profile-header">
    <button class="profile-back-btn" onclick="showScreen('home')">← Back</button>
    <div class="profile-header-main">
      <div class="profile-header-emoji" id="profile-header-emoji">⚽</div>
      <div>
        <div class="profile-name-big" id="profile-name-big">—</div>
        <div class="profile-header-sub" id="profile-header-sub">Member since —</div>
      </div>
    </div>
  </div>
  <div class="profile-body">
    <div class="profile-stat-row">
      <div class="profile-stat-card">
        <div class="profile-stat-num" id="profile-wins">0</div>
        <div class="profile-stat-label">Wins</div>
      </div>
      <div class="profile-stat-card">
        <div class="profile-stat-num" id="profile-played">0</div>
        <div class="profile-stat-label">Played</div>
      </div>
      <div class="profile-stat-card">
        <div class="profile-stat-num" id="profile-winpct">—</div>
        <div class="profile-stat-label">Win %</div>
      </div>
    </div>

    <div class="profile-section">
      <div class="profile-section-title">Form — last 5</div>
      <div class="profile-form-strip" id="profile-form-strip"></div>
    </div>

    <div class="profile-section">
      <div class="profile-section-title">Archive Progress</div>
      <div class="profile-archive-bar-wrap">
        <div class="profile-archive-bar"><div class="profile-archive-fill" id="profile-archive-fill"></div></div>
        <div class="profile-archive-label" id="profile-archive-label">0 / 7 matches played</div>
      </div>
    </div>


    <div class="profile-section">
      <div class="profile-section-title">Badges</div>
      <div class="profile-badges-grid" id="profile-badges-grid"></div>
    </div>
  </div>
</div>

<!-- ═══════════════════════════════════════ COIN FLIP ═══════════════════════════════════════ -->
<div id="screen-coin" class="screen">
  <div class="coin-screen-inner">

    <!-- Phase 1: Loading -->
    <div id="coin-phase-loading" class="coin-phase">
      <div class="coin-phase-label">Loading match…</div>
      <div class="coin-loading-tape">📼</div>
      <div class="coin-loading-lines" id="coin-loading-lines">Searching the archives…</div>
    </div>

    <!-- Phase 2: Match reveal -->
    <div id="coin-phase-reveal" class="coin-phase" style="display:none;">
      <div class="coin-phase-label">Today's Match</div>
      <div class="coin-reveal-matchup" id="coin-reveal-matchup"></div>
      <div class="coin-reveal-date" id="coin-reveal-date"></div>
      <div class="coin-reveal-blurb" id="coin-reveal-blurb"></div>

      <!-- Reveal tip card -->
      <div class="reveal-tip-card" id="reveal-tip-card">
        <button class="reveal-tip-btn" id="reveal-tip-btn" onclick="revealTip()">
          <span>🔍</span> Reveal a tip
        </button>
        <div class="reveal-tip-cost">−5 pts penalty if you look</div>
        <div class="reveal-tip-content" id="reveal-tip-content" style="display:none"></div>
      </div>

      <div class="coin-countdown-bar">
        <div class="coin-countdown-fill" id="coin-countdown-fill"></div>
      </div>
      <div class="coin-countdown-label" id="coin-countdown-label">Coin flip in 10…</div>
    </div>

    <!-- Phase 3: Coin flip -->
    <div id="coin-phase-flip" class="coin-phase" style="display:none;">
      <div class="coin-phase-label">Coin Flip</div>
      <div id="coin" style="width:100px;height:100px;border-radius:50%;background:white;display:flex;align-items:center;justify-content:center;font-size:48px;transition:transform 0.1s;box-shadow:0 0 0 6px #222;margin:0 auto 32px;">🪙</div>
      <div id="coin-status" style="font-family:'Bebas Neue',sans-serif;font-size:42px;color:white;letter-spacing:2px;min-height:52px;text-align:center;"></div>
      <div id="coin-sub" style="font-size:14px;color:var(--muted);margin-top:8px;min-height:20px;text-align:center;"></div>
    </div>

  </div>
</div>

<!-- ═══════════════════════════════════════ DRAFT ═══════════════════════════════════════ -->
<div id="screen-draft" class="screen">
  <div class="game-header">
    <div class="logo">WORST <span>XI</span></div>
    <div class="match-badge" id="match-badge">DRAFT</div>
  </div>
  <div class="draft-layout">
    <!-- Opponent slots -->
    <div>
      <div class="zone-label"><span class="dot opponent"></span> Opponent's XI</div>
      <div class="slots-grid" id="opp-slots"></div>
    </div>

    <!-- Middle: carousel + controls -->
    <div class="draft-middle">

      <div class="team-toggle">
        <button class="active" onclick="setTeamFilter('home')" id="toggle-home">Home</button>
        <button onclick="setTeamFilter('away')" id="toggle-away">Away</button>
      </div>

      <div class="sabotage-bar">
        <div class="sabotage-pips" id="sabotage-pips"></div>
        <span id="sabotage-label">3 sabotages remaining</span>
      </div>

      <div class="carousel-container" id="carousel-container">
        <div class="carousel-track" id="carousel-track"></div>
      </div>
      <div class="carousel-hint">← scroll to browse · select to pick</div>

      <!-- Bottom action row: status pill + button side by side -->
      <div class="draft-action-row">
        <div class="turn-pill">
          <div class="turn-text" id="turn-text">Your pick</div>
          <div class="timer-ring">
            <svg width="30" height="30" viewBox="0 0 36 36">
              <circle cx="18" cy="18" r="15.9"/>
              <circle class="progress" id="timer-circle" cx="18" cy="18" r="15.9"
                stroke-dasharray="100" stroke-dashoffset="0"/>
            </svg>
            <div class="timer-num" id="timer-num">30</div>
          </div>
        </div>
        <button class="btn-confirm" onclick="draftPlayer()" id="btn-me">Pick for Me</button>
        <button style="display:none" id="btn-sabotage"></button>
      </div>

    </div>

    <!-- Your slots -->
    <div>
      <div class="zone-label" id="my-zone-label"><span class="dot yours"></span> Your XI</div>
      <div class="slots-grid" id="my-slots"></div>
    </div>
  </div>
</div>

<!-- ═══════════════════════════════════════ CAPTAIN ═══════════════════════════════════════ -->
<div id="screen-captain" class="screen">
  <div class="captain-header">
    <div class="captain-title">Pick Your Captain</div>
    <div class="captain-sub">Their points will be doubled. Choose wisely — or don't. 😈</div>
  </div>
  <div class="captain-grid" id="captain-grid"></div>
  <div class="captain-footer">
    <div class="captain-hint" id="captain-hint">Tap a player to nominate</div>
    <button class="btn-primary captain-confirm" id="captain-confirm-btn" onclick="confirmCaptain()" disabled>
      Confirm Captain →
    </button>
  </div>
</div>

<!-- ═══════════════════════════════════════ SIMULATION ═══════════════════════════════════════ -->
<div id="screen-sim" class="screen">
  <div class="sim-header">
    <div class="sim-scoreboard">
      <div class="sim-player-score">
        <div class="sim-player-label" id="sim-my-label">You</div>
        <div class="sim-score-status" id="sim-my-status">–</div>
      </div>
      <div class="sim-middle">
        <div class="sim-gap-line" id="sim-gap-line"></div>
      </div>
      <div class="sim-player-score" style="text-align:right">
        <div class="sim-player-label">Opponent</div>
        <div class="sim-opp-pts" id="sim-opp-pts"></div>
      </div>
    </div>
    <div class="score-bar-track">
      <div class="score-bar-fill" id="score-bar-fill" style="width:50%"></div>
    </div>
  </div>

  <div class="sim-view-toggle">
    <button class="active" onclick="setSimView('me')" id="sim-tab-me">Your XI</button>
    <button onclick="setSimView('opp')" id="sim-tab-opp">Their XI</button>
  </div>

  <div class="sim-players" id="sim-players-list"></div>

  <div class="live-scoreline">
    <span class="live-pill">LIVE</span>
    <span class="live-teams">Man City <strong id="live-home-score">0</strong> – <strong id="live-away-score">0</strong> Watford</span>
    <span class="live-clock" id="match-clock">0'</span>
    <button class="autocomplete-btn" id="autocomplete-btn" onclick="autoCompleteMatch()" title="Skip to result">⏭</button>
  </div>

  <div class="commentary-feed" id="commentary-feed">
    <div class="commentary-lines">
      <div class="commentary-line commentary-line-sub" id="commentary-sub" style="display:none"></div>
      <div class="commentary-line" id="commentary">Man City vs Watford kicks off...</div>
    </div>
    <div class="commentary-emoji" id="commentary-emoji">⚽</div>
  </div>

  <!-- Prediction overlay — sits over commentary feed when a moment fires -->
  <div class="prediction-overlay" id="prediction-overlay" style="display:none">
    <div class="prediction-question" id="prediction-question">Does he score?</div>
    <div class="prediction-timer-bar"><div class="prediction-timer-fill" id="prediction-timer-fill"></div></div>
    <div class="prediction-buttons">
      <button class="pred-btn pred-yes" onclick="submitPrediction(true)">✅ Yes</button>
      <button class="pred-btn pred-no"  onclick="submitPrediction(false)">❌ No</button>
    </div>
  </div>
</div>

<!-- ═══════════════════════════════════════ RESULTS ═══════════════════════════════════════ -->
<div id="screen-results" class="screen">
  <div class="results-header">
    <div class="result-headline" id="result-headline">OMNISHAMBLES</div>
    <div class="result-sub" id="result-sub">Man City 8-0 Watford · 2019</div>
  </div>

  <div class="results-scores">
    <div class="result-score-card full" id="my-score-card">
      <div class="result-score-label" id="my-score-label">You</div>
      <div class="result-score-emoji" id="my-result-emoji">😬</div>
      <div class="result-outcome" id="my-result-outcome">—</div>
      <div class="result-score-detail" id="my-score-detail"></div>
    </div>
  </div>

  <div class="results-body">
    <div class="result-section">
      <div class="result-section-title">Match Report</div>
      <div id="match-report" style="font-size:14px;line-height:1.7;color:#333;"></div>
    </div>

    <div class="result-section">
      <div class="result-section-title">Worst Eleven</div>
      <div id="contributors-list"></div>
    </div>

    <div class="result-section">
      <div class="result-section-title">Badges Earned</div>
      <div class="badges-row" id="badges-list"></div>
    </div>

    <div class="result-section" id="result-form-section" style="display:none">
      <div class="result-section-title" id="result-form-section-title">Your Record</div>
      <div class="result-form-tile">
        <div class="result-form-title">Form — last 5</div>
        <div class="result-form-row" id="result-form-strip"></div>
        <div class="result-form-stats" id="result-form-stats"></div>
        <button class="result-view-profile-btn" onclick="viewActiveProfile()">View Full Profile →</button>
      </div>
    </div>

    <div class="cta-row">
      <button class="cta-rematch" onclick="restart()">↩ Rematch</button>
      <button class="cta-share" onclick="shareResult()">Share Result</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>
<div class="pred-result-flash" id="pred-result-flash"></div>
<!-- Half-time interstitial — at root so position:fixed is never clipped -->
<div class="ht-overlay" id="ht-overlay" style="display:none">
  <div class="ht-whistle">🟡</div>
  <div class="ht-label">HALF TIME</div>
  <div class="ht-score" id="ht-score"></div>
  <div class="ht-sub">Second half kicks off shortly…</div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
// MATCH ARCHIVE — 7 historic Premier League matches
// ═══════════════════════════════════════════════════════════════
const ALL_MATCHES = [

  // ── MATCH 1: Man City 8-0 Watford, 21 Sep 2019 ───────────────
  {
    id: 'mci_8-0_wat_2019',
    meta: {
      home: 'Man City', away: 'Watford', score: '8-0', homeColour: '#6CABDD', awayColour: '#FBEE23',
      date: '21 Sep 2019', label: 'Premier League · Sat 21 Sep 2019 · 3:00pm BST',
      blurb: 'The Etihad, 3pm. <strong>Man City sit 2nd</strong> (W4 D1 L1, 13 pts) after a shock home loss to Norwich last weekend. <strong>Watford are rock bottom</strong> — winless in six, just 2 points all season. Bernardo Silva and De Bruyne have been in electric form. Deeney leads the line for a Hornets side desperate for a response.',
      finalCommentary: '<strong>Full time.</strong> Eight goals. A historic, record-equalling rout.',
      lateCommentary: 'Late pressure. Time running out for Watford.',
    },
    players: [
      { id: 1, name: 'Ederson',     pos: 'GK', team: 'home', teamName: 'Man City' },
      { id: 2, name: 'Cancelo',     pos: 'RB', team: 'home', teamName: 'Man City' },
      { id: 3, name: 'Otamendi',    pos: 'CB', team: 'home', teamName: 'Man City' },
      { id: 4, name: 'Fernandinho', pos: 'CB', team: 'home', teamName: 'Man City' },
      { id: 5, name: 'Mendy',       pos: 'LB', team: 'home', teamName: 'Man City' },
      { id: 6, name: 'Gündogan',    pos: 'CM', team: 'home', teamName: 'Man City' },
      { id: 7, name: 'Rodri',       pos: 'CM', team: 'home', teamName: 'Man City' },
      { id: 8, name: 'De Bruyne',   pos: 'AM', team: 'home', teamName: 'Man City' },
      { id: 9, name: 'Bernardo',    pos: 'RW', team: 'home', teamName: 'Man City' },
      { id:10, name: 'Agüero',      pos: 'ST', team: 'home', teamName: 'Man City' },
      { id:11, name: 'Mahrez',      pos: 'LW', team: 'home', teamName: 'Man City' },
      { id:12, name: 'Foster',      pos: 'GK', team: 'away', teamName: 'Watford' },
      { id:13, name: 'Femenia',     pos: 'RB', team: 'away', teamName: 'Watford' },
      { id:14, name: 'Kabasele',    pos: 'CB', team: 'away', teamName: 'Watford' },
      { id:15, name: 'Cathcart',    pos: 'CB', team: 'away', teamName: 'Watford' },
      { id:16, name: 'Masina',      pos: 'LB', team: 'away', teamName: 'Watford' },
      { id:17, name: 'Doucoure',    pos: 'CM', team: 'away', teamName: 'Watford' },
      { id:18, name: 'Capoue',      pos: 'CM', team: 'away', teamName: 'Watford' },
      { id:19, name: 'Hughes',      pos: 'AM', team: 'away', teamName: 'Watford' },
      { id:20, name: 'Pereyra',     pos: 'RW', team: 'away', teamName: 'Watford' },
      { id:21, name: 'Deeney',      pos: 'ST', team: 'away', teamName: 'Watford' },
      { id:22, name: 'Deulofeu',    pos: 'LW', team: 'away', teamName: 'Watford' },
    ],
    events: [
      { min: 12, type: 'goal',    playerId: 10 },
      { min: 21, type: 'assist',  playerId:  8 },
      { min: 21, type: 'goal',    playerId: 10 },
      { min: 24, type: 'goal',    playerId:  9 },
      { min: 34, type: 'yellow',  playerId: 17 },
      { min: 38, type: 'own_goal',playerId: 14 },
      { min: 40, type: 'sub',     playerId: 14 },
      { min: 50, type: 'goal',    playerId:  8 },
      { min: 59, type: 'goal',    playerId: 10 },
      { min: 65, type: 'goal',    playerId: 11 },
      { min: 70, type: 'sub',     playerId: 22 },
      { min: 72, type: 'sub',     playerId: 19 },
      { min: 76, type: 'yellow',  playerId: 21 },
      { min: 80, type: 'goal',    playerId: 10 },
      { min: 85, type: 'goal',    playerId:  9 },
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 2: Leicester 5-3 Man United, 21 Sep 2014 ───────────
  {
    id: 'lei_5-3_mun_2014',
    meta: {
      home: 'Leicester', away: 'Man United', score: '5-3', homeColour: '#003090', awayColour: '#DA291C',
      date: '21 Sep 2014', label: 'Premier League · Sun 21 Sep 2014 · 4:00pm BST',
      blurb: 'King Power Stadium. <strong>Van Gaal\'s United</strong> (W2 D2 L1) have splashed £150m in the summer — Falcao, Di Maria and Van Persie all start. <strong>Leicester sit 16th</strong>, battling to stay up. Vardy has scored once all season. Cambiasso, Schmeichel and Ulloa are the Foxes\' best hopes of causing an upset.',
      finalCommentary: '<strong>Full time.</strong> Leicester 5 United 3. Van Gaal\'s worst nightmare.',
      lateCommentary: 'Blackett is off! Ten men for United. Leicester smell blood.',
    },
    players: [
      { id: 1, name: 'Schmeichel',  pos: 'GK', team: 'home', teamName: 'Leicester' },
      { id: 2, name: 'De Laet',     pos: 'RB', team: 'home', teamName: 'Leicester' },
      { id: 3, name: 'Morgan',      pos: 'CB', team: 'home', teamName: 'Leicester' },
      { id: 4, name: 'Moore',       pos: 'CB', team: 'home', teamName: 'Leicester' },
      { id: 5, name: 'Konchesky',   pos: 'LB', team: 'home', teamName: 'Leicester' },
      { id: 6, name: 'Hammond',     pos: 'CM', team: 'home', teamName: 'Leicester' },
      { id: 7, name: 'Drinkwater',  pos: 'CM', team: 'home', teamName: 'Leicester' },
      { id: 8, name: 'Cambiasso',   pos: 'AM', team: 'home', teamName: 'Leicester' },
      { id: 9, name: 'Nugent',      pos: 'RW', team: 'home', teamName: 'Leicester' },
      { id:10, name: 'Ulloa',       pos: 'ST', team: 'home', teamName: 'Leicester' },
      { id:11, name: 'Vardy',       pos: 'LW', team: 'home', teamName: 'Leicester' },
      { id:12, name: 'De Gea',      pos: 'GK', team: 'away', teamName: 'Man United' },
      { id:13, name: 'Blackett',    pos: 'RB', team: 'away', teamName: 'Man United' },
      { id:14, name: 'Evans',       pos: 'CB', team: 'away', teamName: 'Man United' },
      { id:15, name: 'Smalling',    pos: 'CB', team: 'away', teamName: 'Man United' },
      { id:16, name: 'Rojo',        pos: 'LB', team: 'away', teamName: 'Man United' },
      { id:17, name: 'Blind',       pos: 'CM', team: 'away', teamName: 'Man United' },
      { id:18, name: 'Herrera',     pos: 'CM', team: 'away', teamName: 'Man United' },
      { id:19, name: 'Di Maria',    pos: 'RW', team: 'away', teamName: 'Man United' },
      { id:20, name: 'Rooney',      pos: 'AM', team: 'away', teamName: 'Man United' },
      { id:21, name: 'Van Persie',  pos: 'ST', team: 'away', teamName: 'Man United' },
      { id:22, name: 'Falcao',      pos: 'LW', team: 'away', teamName: 'Man United' },
    ],
    events: [
      { min: 13, type: 'goal',     playerId: 21 },
      { min: 16, type: 'assist',   playerId: 20 },
      { min: 16, type: 'goal',     playerId: 19 },
      { min: 17, type: 'goal',     playerId: 10 },
      { min: 57, type: 'goal',     playerId: 18 },
      { min: 62, type: 'goal',     playerId:  9 },  // pen
      { min: 64, type: 'goal',     playerId:  8 },
      { min: 72, type: 'sub',      playerId: 22 },
      { min: 75, type: 'sub',      playerId:  9 },
      { min: 76, type: 'sub',      playerId: 19 },
      { min: 79, type: 'assist',   playerId:  2 },
      { min: 79, type: 'goal',     playerId: 11 },
      { min: 83, type: 'red',      playerId: 13 },
      { min: 83, type: 'goal',     playerId: 10 },  // pen
      { min: 85, type: 'sub',      playerId: 11 },
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 3: Arsenal 2-8 Man United, 28 Aug 2011 ─────────────
  {
    id: 'ars_2-8_mun_2011',
    meta: {
      home: 'Arsenal', away: 'Man United', score: '2-8', homeColour: '#EF0107', awayColour: '#DA291C',
      date: '28 Aug 2011', label: 'Premier League · Sun 28 Aug 2011 · 4:00pm BST',
      blurb: 'The Emirates. <strong>Arsenal are missing eight first-teamers</strong> through injury — Fabregas, Nasri, Rosický, Diaby and more. <strong>Ferguson\'s United</strong> sit 2nd and are in ruthless early-season form. Young and Welbeck have been sharp all summer. Arsenal\'s young, depleted backline faces a stern test.',
      finalCommentary: '<strong>Full time.</strong> Arsenal 2 United 8. The most humiliating home defeat in Arsenal\'s modern history.',
      lateCommentary: 'Arsenal are broken. United smell more blood.',
    },
    players: [
      { id: 1, name: 'Szczesny',   pos: 'GK', team: 'home', teamName: 'Arsenal' },
      { id: 2, name: 'Jenkinson',  pos: 'RB', team: 'home', teamName: 'Arsenal' },
      { id: 3, name: 'Djourou',    pos: 'CB', team: 'home', teamName: 'Arsenal' },
      { id: 4, name: 'Koscielny',  pos: 'CB', team: 'home', teamName: 'Arsenal' },
      { id: 5, name: 'Traore',     pos: 'LB', team: 'home', teamName: 'Arsenal' },
      { id: 6, name: 'Coquelin',   pos: 'CM', team: 'home', teamName: 'Arsenal' },
      { id: 7, name: 'Ramsey',     pos: 'CM', team: 'home', teamName: 'Arsenal' },
      { id: 8, name: 'Walcott',    pos: 'RW', team: 'home', teamName: 'Arsenal' },
      { id: 9, name: 'Rosicky',    pos: 'AM', team: 'home', teamName: 'Arsenal' },
      { id:10, name: 'Arshavin',   pos: 'LW', team: 'home', teamName: 'Arsenal' },
      { id:11, name: 'Van Persie', pos: 'ST', team: 'home', teamName: 'Arsenal' },
      { id:12, name: 'De Gea',     pos: 'GK', team: 'away', teamName: 'Man United' },
      { id:13, name: 'Smalling',   pos: 'RB', team: 'away', teamName: 'Man United' },
      { id:14, name: 'Jones',      pos: 'CB', team: 'away', teamName: 'Man United' },
      { id:15, name: 'Evans',      pos: 'CB', team: 'away', teamName: 'Man United' },
      { id:16, name: 'Evra',       pos: 'LB', team: 'away', teamName: 'Man United' },
      { id:17, name: 'Anderson',   pos: 'CM', team: 'away', teamName: 'Man United' },
      { id:18, name: 'Cleverley',  pos: 'CM', team: 'away', teamName: 'Man United' },
      { id:19, name: 'Nani',       pos: 'RW', team: 'away', teamName: 'Man United' },
      { id:20, name: 'Young',      pos: 'AM', team: 'away', teamName: 'Man United' },
      { id:21, name: 'Rooney',     pos: 'ST', team: 'away', teamName: 'Man United' },
      { id:22, name: 'Welbeck',    pos: 'LW', team: 'away', teamName: 'Man United' },
    ],
    events: [
      { min: 22, type: 'goal',    playerId: 22 },
      { min: 28, type: 'assist',  playerId: 16 },
      { min: 28, type: 'goal',    playerId: 20 },
      { min: 34, type: 'sub',     playerId: 22 },  // Welbeck off injured
      { min: 41, type: 'goal',    playerId: 21 },  // free kick
      { min: 45, type: 'goal',    playerId:  8 },  // Walcott pulls one back
      { min: 64, type: 'goal',    playerId: 21 },  // free kick
      { min: 67, type: 'goal',    playerId: 19 },
      { min: 67, type: 'sub',     playerId: 17 },  // Anderson off
      { min: 70, type: 'goal',    playerId: 20 },  // Young gets one
      { min: 74, type: 'goal',    playerId: 11 },  // Van Persie pulls one back
      { min: 82, type: 'goal',    playerId: 21 },  // pen — hat-trick
      { min: 83, type: 'red',     playerId:  2 },  // Jenkinson red
      { min: 83, type: 'sub',     playerId: 11 },  // Van Persie off
      { min: 90, type: 'goal',    playerId: 20 },  // Young completes 8
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 4: Liverpool 4-3 Newcastle, 3 Apr 1996 ─────────────
  {
    id: 'liv_4-3_new_1996',
    meta: {
      home: 'Liverpool', away: 'Newcastle', score: '4-3', homeColour: '#C8102E', awayColour: '#241F20',
      date: '3 Apr 1996', label: 'Premier League · Wed 3 Apr 1996 · 8:00pm BST',
      blurb: 'Anfield, April 1996. <strong>Newcastle lead the title race by a point</strong> with five games left — Keegan\'s men have been imperious all season. <strong>Liverpool sit 3rd</strong>, out of the title hunt but dangerous at home. Fowler has 28 goals. Asprilla and Ferdinand up top for the Magpies. A top-four clash with huge implications.',
      finalCommentary: '<strong>Full time.</strong> Liverpool 4 Newcastle 3. Collymore wheels away. Keegan sinks to his knees.',
      lateCommentary: 'Collymore breaks away — GOAL! The stadium erupts!',
    },
    players: [
      { id: 1, name: 'James',       pos: 'GK', team: 'home', teamName: 'Liverpool' },
      { id: 2, name: 'Jones',       pos: 'RB', team: 'home', teamName: 'Liverpool' },
      { id: 3, name: 'Scales',      pos: 'CB', team: 'home', teamName: 'Liverpool' },
      { id: 4, name: 'Wright',      pos: 'CB', team: 'home', teamName: 'Liverpool' },
      { id: 5, name: 'Bjornebye',   pos: 'LB', team: 'home', teamName: 'Liverpool' },
      { id: 6, name: 'McAteer',     pos: 'CM', team: 'home', teamName: 'Liverpool' },
      { id: 7, name: 'Redknapp',    pos: 'CM', team: 'home', teamName: 'Liverpool' },
      { id: 8, name: 'Barnes',      pos: 'AM', team: 'home', teamName: 'Liverpool' },
      { id: 9, name: 'McManaman',   pos: 'RW', team: 'home', teamName: 'Liverpool' },
      { id:10, name: 'Fowler',      pos: 'ST', team: 'home', teamName: 'Liverpool' },
      { id:11, name: 'Collymore',   pos: 'LW', team: 'home', teamName: 'Liverpool' },
      { id:12, name: 'Srnicek',     pos: 'GK', team: 'away', teamName: 'Newcastle' },
      { id:13, name: 'Watson',      pos: 'RB', team: 'away', teamName: 'Newcastle' },
      { id:14, name: 'Howey',       pos: 'CB', team: 'away', teamName: 'Newcastle' },
      { id:15, name: 'Albert',      pos: 'CB', team: 'away', teamName: 'Newcastle' },
      { id:16, name: 'Beresford',   pos: 'LB', team: 'away', teamName: 'Newcastle' },
      { id:17, name: 'Batty',       pos: 'CM', team: 'away', teamName: 'Newcastle' },
      { id:18, name: 'Lee',         pos: 'CM', team: 'away', teamName: 'Newcastle' },
      { id:19, name: 'Beardsley',   pos: 'AM', team: 'away', teamName: 'Newcastle' },
      { id:20, name: 'Ginola',      pos: 'RW', team: 'away', teamName: 'Newcastle' },
      { id:21, name: 'Ferdinand',   pos: 'ST', team: 'away', teamName: 'Newcastle' },
      { id:22, name: 'Asprilla',    pos: 'LW', team: 'away', teamName: 'Newcastle' },
    ],
    events: [
      { min:  2, type: 'goal',    playerId: 10 },  // Fowler heads in
      { min:  2, type: 'assist',  playerId:  7 },  // Redknapp — cross from Collymore, but Redknapp started move
      { min: 10, type: 'goal',    playerId: 21 },  // Ferdinand equalises
      { min: 14, type: 'goal',    playerId: 20 },  // Ginola — Newcastle lead
      { min: 35, type: 'yellow',  playerId: 19 },  // Beardsley booked
      { min: 40, type: 'yellow',  playerId: 17 },  // Batty booked — foul on McManaman
      { min: 45, type: 'sub',     playerId:  4 },  // Wright off at half time (replaced by Harkness)
      { min: 55, type: 'goal',    playerId: 10 },  // Fowler levels — 2-2
      { min: 55, type: 'assist',  playerId:  6 },  // McAteer played it to McManaman who found Fowler
      { min: 57, type: 'goal',    playerId: 22 },  // Asprilla — Newcastle ahead again
      { min: 68, type: 'goal',    playerId: 11 },  // Collymore 3-3
      { min: 68, type: 'assist',  playerId:  6 },  // McAteer's curling cross
      { min: 76, type: 'sub',     playerId:  2 },  // Rob Jones off — Rush on
      { min: 90, type: 'goal',    playerId: 11 },  // Collymore winner — 4-3
      { min: 90, type: 'assist',  playerId:  8 },  // Barnes played it to Collymore
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 5: West Ham 2-3 Tottenham, 23 Nov 2019 ─────────────
  {
    id: 'whu_2-3_tot_2019',
    meta: {
      home: 'West Ham', away: 'Tottenham', score: '2-3', homeColour: '#7A263A', awayColour: '#132257',
      date: '23 Nov 2019', label: 'Premier League · Sat 23 Nov 2019 · 3:00pm BST',
      blurb: 'London Stadium. <strong>Jose Mourinho was appointed Spurs manager 48 hours ago.</strong> He inherits a squad that hasn\'t won away in the league since January. <strong>West Ham sit 17th</strong> and need a result badly. Son, Kane and Moura lead Spurs\' attack. Antonio is West Ham\'s most dangerous outlet.',
      finalCommentary: '<strong>Full time.</strong> West Ham 2 Tottenham 3. Jose\'s first game. Three points. Pandemonium.',
      lateCommentary: 'Ogbonna scrambles one back — West Ham alive! But is it too late?',
    },
    players: [
      { id: 1, name: 'Roberto',     pos: 'GK', team: 'home', teamName: 'West Ham' },
      { id: 2, name: 'Fredericks',  pos: 'RB', team: 'home', teamName: 'West Ham' },
      { id: 3, name: 'Diop',        pos: 'CB', team: 'home', teamName: 'West Ham' },
      { id: 4, name: 'Ogbonna',     pos: 'CB', team: 'home', teamName: 'West Ham' },
      { id: 5, name: 'Cresswell',   pos: 'LB', team: 'home', teamName: 'West Ham' },
      { id: 6, name: 'Rice',        pos: 'CM', team: 'home', teamName: 'West Ham' },
      { id: 7, name: 'Noble',       pos: 'CM', team: 'home', teamName: 'West Ham' },
      { id: 8, name: 'Snodgrass',   pos: 'RW', team: 'home', teamName: 'West Ham' },
      { id: 9, name: 'Anderson',    pos: 'AM', team: 'home', teamName: 'West Ham' },
      { id:10, name: 'Yarmolenko',  pos: 'LW', team: 'home', teamName: 'West Ham' },
      { id:11, name: 'Haller',      pos: 'ST', team: 'home', teamName: 'West Ham' },
      { id:12, name: 'Gazzaniga',   pos: 'GK', team: 'away', teamName: 'Tottenham' },
      { id:13, name: 'Aurier',      pos: 'RB', team: 'away', teamName: 'Tottenham' },
      { id:14, name: 'Alderweireld',pos: 'CB', team: 'away', teamName: 'Tottenham' },
      { id:15, name: 'Sanchez',     pos: 'CB', team: 'away', teamName: 'Tottenham' },
      { id:16, name: 'Davies',      pos: 'LB', team: 'away', teamName: 'Tottenham' },
      { id:17, name: 'Dier',        pos: 'CM', team: 'away', teamName: 'Tottenham' },
      { id:18, name: 'Winks',       pos: 'CM', team: 'away', teamName: 'Tottenham' },
      { id:19, name: 'Moura',       pos: 'RW', team: 'away', teamName: 'Tottenham' },
      { id:20, name: 'Alli',        pos: 'AM', team: 'away', teamName: 'Tottenham' },
      { id:21, name: 'Son',         pos: 'LW', team: 'away', teamName: 'Tottenham' },
      { id:22, name: 'Kane',        pos: 'ST', team: 'away', teamName: 'Tottenham' },
    ],
    events: [
      { min: 36, type: 'assist',  playerId: 20 },
      { min: 36, type: 'goal',    playerId: 21 },  // Son
      { min: 43, type: 'goal',    playerId: 19 },  // Moura
      { min: 49, type: 'goal',    playerId: 22 },  // Kane header
      { min: 65, type: 'sub',     playerId:  9 },  // Anderson off
      { min: 73, type: 'goal',    playerId:  4 },  // Ogbonna own goal — actually Antonio, fix below
      { min: 73, type: 'yellow',  playerId:  3 },  // Diop
      { min: 85, type: 'sub',     playerId: 18 },  // Winks off
      { min: 90, type: 'goal',    playerId:  4 },  // Ogbonna — 2-3
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 6: Newcastle 5-1 Sunderland, 31 Oct 2010 ───────────
  {
    id: 'new_5-1_sun_2010',
    meta: {
      home: 'Newcastle', away: 'Sunderland', score: '5-1', homeColour: '#241F20', awayColour: '#EB172B',
      date: '31 Oct 2010', label: 'Premier League · Sun 31 Oct 2010 · 1:30pm GMT',
      blurb: 'St James\' Park, Halloween. <strong>The Tyne-Wear derby.</strong> Newcastle sit 11th, Sunderland 10th — just two points between them. <strong>Nolan has been Newcastle\'s talisman</strong> all season, leading the line with Carroll. Darren Bent has been sharp for Sunderland. These derbies always produce drama.',
      finalCommentary: '<strong>Full time.</strong> Newcastle 5 Sunderland 1. Happy Halloween, Mackems.',
      lateCommentary: 'Nolan completes his hat-trick. St James\' Park is delirious.',
    },
    players: [
      { id: 1, name: 'Krul',        pos: 'GK', team: 'home', teamName: 'Newcastle' },
      { id: 2, name: 'Simpson',     pos: 'RB', team: 'home', teamName: 'Newcastle' },
      { id: 3, name: 'Coloccini',   pos: 'CB', team: 'home', teamName: 'Newcastle' },
      { id: 4, name: 'Williamson',  pos: 'CB', team: 'home', teamName: 'Newcastle' },
      { id: 5, name: 'Enrique',     pos: 'LB', team: 'home', teamName: 'Newcastle' },
      { id: 6, name: 'Barton',      pos: 'CM', team: 'home', teamName: 'Newcastle' },
      { id: 7, name: 'Tiote',       pos: 'CM', team: 'home', teamName: 'Newcastle' },
      { id: 8, name: 'Gutierrez',   pos: 'AM', team: 'home', teamName: 'Newcastle' },
      { id: 9, name: 'Nolan',       pos: 'RW', team: 'home', teamName: 'Newcastle' },
      { id:10, name: 'Ameobi',      pos: 'ST', team: 'home', teamName: 'Newcastle' },
      { id:11, name: 'Carroll',     pos: 'LW', team: 'home', teamName: 'Newcastle' },
      { id:12, name: 'Mignolet',    pos: 'GK', team: 'away', teamName: 'Sunderland' },
      { id:13, name: 'Bardsley',    pos: 'RB', team: 'away', teamName: 'Sunderland' },
      { id:14, name: 'Bramble',     pos: 'CB', team: 'away', teamName: 'Sunderland' },
      { id:15, name: 'Onuoha',      pos: 'CB', team: 'away', teamName: 'Sunderland' },
      { id:16, name: 'Turner',      pos: 'LB', team: 'away', teamName: 'Sunderland' },
      { id:17, name: 'Cattermole',  pos: 'CM', team: 'away', teamName: 'Sunderland' },
      { id:18, name: 'Henderson',   pos: 'CM', team: 'away', teamName: 'Sunderland' },
      { id:19, name: 'Elmohamady', pos: 'RW', team: 'away', teamName: 'Sunderland' },
      { id:20, name: 'Malbranque',  pos: 'AM', team: 'away', teamName: 'Sunderland' },
      { id:21, name: 'Bent',        pos: 'ST', team: 'away', teamName: 'Sunderland' },
      { id:22, name: 'Welbeck',     pos: 'LW', team: 'away', teamName: 'Sunderland' },
    ],
    events: [
      { min: 26, type: 'goal',    playerId:  9 },  // Nolan 1
      { min: 34, type: 'goal',    playerId:  9 },  // Nolan 2
      { min: 40, type: 'sub',     playerId: 19 },  // Elmohamady off
      { min: 45, type: 'goal',    playerId: 10 },  // Ameobi pen
      { min: 55, type: 'red',     playerId: 14 },  // Bramble red
      { min: 55, type: 'sub',     playerId: 22 },  // Welbeck off
      { min: 70, type: 'goal',    playerId: 10 },  // Ameobi
      { min: 75, type: 'goal',    playerId:  9 },  // Nolan hat-trick
      { min: 76, type: 'sub',     playerId: 17 },  // Cattermole off
      { min: 86, type: 'sub',     playerId: 10 },  // Ameobi off
      { min: 90, type: 'goal',    playerId: 21 },  // Bent consolation
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 7: Newcastle 4-4 Arsenal, 5 Feb 2011 ───────────────
  {
    id: 'new_4-4_ars_2011',
    meta: {
      home: 'Newcastle', away: 'Arsenal', score: '4-4', homeColour: '#241F20', awayColour: '#EF0107',
      date: '5 Feb 2011', label: 'Premier League · Sat 5 Feb 2011 · 3:00pm GMT',
      blurb: 'St James\' Park, February 2011. <strong>Arsenal sit top of the Premier League</strong> (W16 D4 L2) chasing their first title since the Invincibles. Van Persie and Walcott are in blistering form. <strong>Newcastle are 12th</strong> but feisty at home — Nolan and Tiote in the engine room, Carroll leading the line. Diaby starts for the Gunners.',
      finalCommentary: '<strong>Full time.</strong> Newcastle 4 Arsenal 4. Tiote\'s volley. They\'ll talk about this forever.',
      lateCommentary: 'TIOTE! What a volley! 4-4! St James\' Park has lost its mind!',
    },
    players: [
      { id: 1, name: 'Harper',      pos: 'GK', team: 'home', teamName: 'Newcastle' },
      { id: 2, name: 'Simpson',     pos: 'RB', team: 'home', teamName: 'Newcastle' },
      { id: 3, name: 'Coloccini',   pos: 'CB', team: 'home', teamName: 'Newcastle' },
      { id: 4, name: 'Williamson',  pos: 'CB', team: 'home', teamName: 'Newcastle' },
      { id: 5, name: 'Jose Enrique',pos: 'LB', team: 'home', teamName: 'Newcastle' },
      { id: 6, name: 'Barton',      pos: 'CM', team: 'home', teamName: 'Newcastle' },
      { id: 7, name: 'Tiote',       pos: 'CM', team: 'home', teamName: 'Newcastle' },
      { id: 8, name: 'Gutierrez',   pos: 'AM', team: 'home', teamName: 'Newcastle' },
      { id: 9, name: 'Nolan',       pos: 'RW', team: 'home', teamName: 'Newcastle' },
      { id:10, name: 'Best',        pos: 'ST', team: 'home', teamName: 'Newcastle' },
      { id:11, name: 'Carroll',     pos: 'LW', team: 'home', teamName: 'Newcastle' },
      { id:12, name: 'Szczesny',    pos: 'GK', team: 'away', teamName: 'Arsenal' },
      { id:13, name: 'Sagna',       pos: 'RB', team: 'away', teamName: 'Arsenal' },
      { id:14, name: 'Djourou',     pos: 'CB', team: 'away', teamName: 'Arsenal' },
      { id:15, name: 'Koscielny',   pos: 'CB', team: 'away', teamName: 'Arsenal' },
      { id:16, name: 'Clichy',      pos: 'LB', team: 'away', teamName: 'Arsenal' },
      { id:17, name: 'Song',        pos: 'CM', team: 'away', teamName: 'Arsenal' },
      { id:18, name: 'Wilshere',    pos: 'CM', team: 'away', teamName: 'Arsenal' },
      { id:19, name: 'Walcott',     pos: 'RW', team: 'away', teamName: 'Arsenal' },
      { id:20, name: 'Nasri',       pos: 'AM', team: 'away', teamName: 'Arsenal' },
      { id:21, name: 'Arshavin',    pos: 'LW', team: 'away', teamName: 'Arsenal' },
      { id:22, name: 'Van Persie',  pos: 'ST', team: 'away', teamName: 'Arsenal' },
    ],
    events: [
      { min:  3, type: 'goal',    playerId: 22 },  // Van Persie — Arsenal 0-1
      { min: 10, type: 'goal',    playerId: 21 },  // Arshavin — 0-2
      { min: 26, type: 'assist',  playerId: 22 },
      { min: 26, type: 'goal',    playerId: 19 },  // Walcott — 0-3
      { min: 38, type: 'goal',    playerId: 22 },  // Van Persie — 0-4 — Arsenal flying
      { min: 53, type: 'goal',    playerId:  9 },  // Nolan — 1-4
      { min: 68, type: 'goal',    playerId: 10 },  // Best — 2-4
      { min: 69, type: 'yellow',  playerId: 17 },  // Song booked
      { min: 75, type: 'goal',    playerId:  9 },  // Nolan — 3-4
      { min: 80, type: 'sub',     playerId: 11 },  // Carroll off
      { min: 87, type: 'goal',    playerId:  7 },  // Tiote screamer — 4-4!
      { min: 90, type: 'full_90' },
    ],
  },
];

// ── Active match globals — set by loadMatch() ─────────────────
let MATCH   = {};
let PLAYERS = [];
let EVENTS  = [];

function loadMatch(idx) {
  const m = ALL_MATCHES[idx];
  state.matchIdx = idx;

  MATCH = {
    home:  m.meta.home,
    away:  m.meta.away,
    score: m.meta.score,
    date:  m.meta.date,
  };

  // Re-number player IDs 1-22 so scoring logic stays simple
  PLAYERS = m.players.map((p, i) => ({
    ...p,
    id: i + 1,
    team: p.team === 'home' ? 'home' : 'away',
  }));

  // Remap event playerIds based on original id → new sequential id
  const idMap = {};
  m.players.forEach((p, i) => { idMap[p.id] = i + 1; });
  EVENTS = m.events.map(e => ({
    ...e,
    playerId: e.playerId !== undefined ? idMap[e.playerId] : undefined,
  }));

  // Apply team colours as CSS custom properties
  const root = document.documentElement;
  const hc = m.meta.homeColour || '#6CABDD';
  const ac = m.meta.awayColour || '#FBEE23';
  // Lighten colours for backgrounds
  root.style.setProperty('--home-colour', hc);
  root.style.setProperty('--home-colour-dark', hc);
  root.style.setProperty('--home-colour-light', hc + '18');
  root.style.setProperty('--home-colour-border', hc + '55');
  root.style.setProperty('--away-colour', ac);
  root.style.setProperty('--away-colour-dark', ac);
  root.style.setProperty('--away-colour-light', ac + '18');
  root.style.setProperty('--away-colour-border', ac + '55');

  // Update all hardcoded HTML references
  updateMatchHTML(m);
  computeChaosValues();
}

function updateMatchHTML(m) {
  // Match preview card
  const labelEl = document.querySelector('.match-preview-label');
  if (labelEl) labelEl.textContent = m.meta.label;

  const names = document.querySelectorAll('.match-team-name');
  if (names[0]) { names[0].textContent = m.meta.home; names[0].className = 'match-team-name home-team'; }
  if (names[1]) { names[1].textContent = m.meta.away; names[1].className = 'match-team-name away-team'; }

  const blurb = document.querySelector('.prematch-report');
  if (blurb) blurb.innerHTML = m.meta.blurb;

  // Draft header badge
  const badge = document.getElementById('match-badge');
  if (badge) badge.textContent = `${m.meta.home} vs ${m.meta.away} · DRAFT`;

  // Draft team filter tabs
  const tabHome = document.getElementById('toggle-home');
  const tabAway = document.getElementById('toggle-away');
  if (tabHome) tabHome.textContent = m.meta.home;
  if (tabAway) tabAway.textContent = m.meta.away;

  // Live scoreline
  const liveTeams = document.querySelector('.live-teams');
  if (liveTeams) liveTeams.innerHTML = `${m.meta.home} <strong id="live-home-score">0</strong> – <strong id="live-away-score">0</strong> ${m.meta.away}`;

  // Opening commentary line
  const commEl = document.getElementById('commentary');
  if (commEl) commEl.textContent = `${m.meta.home} vs ${m.meta.away} kicks off…`;

  // Result sub-header (will be overwritten by showResults too)
  const resSub = document.getElementById('result-sub');
  if (resSub) resSub.textContent = `${m.meta.home} ${m.meta.score} ${m.meta.away} · ${m.meta.date}`;
}

// ═══════════════════════════════════════════════════════════════
// SCORING SYSTEM
// ═══════════════════════════════════════════════════════════════

// Position group helper
function posGroup(pos) {
  if (pos === 'GK') return 'gk';
  if (['CB','RB','LB'].includes(pos)) return 'def';
  if (['CM','AM','DM'].includes(pos)) return 'mid';
  return 'fwd'; // ST, RW, LW
}

const SCORE_TABLE = {
  goal:       { fwd: -3,  mid: -4,  def: -6,  gk: -12 },
  assist:     { fwd: -3,  mid: -4,  def: -6,  gk: -10 },
  clean_sheet:{ fwd: -1,  mid: -2,  def: -2,  gk: -3  },
  full_90:    { fwd: -3,  mid: -3,  def: -3,  gk:  0  },
  yellow:     { fwd:  4,  mid:  4,  def:  4,  gk:  8  },
  red:        { fwd: 10,  mid: 10,  def: 10,  gk: 20  },
  own_goal:   10,
  missed_pen: 10,
  pen_save:  -10,
  concede_def: 1,   // per goal conceded (defender)
  concede_gk:  2,   // per goal conceded (GK)
  // subs — two tiers
  sub_halftime: { fwd: 5, mid: 5, def: 5, gk: 10 }, // subbed at or before HT (min <= 45)
  sub_before70: { fwd: 1, mid: 1, def: 2, gk:  5 }, // subbed 46–69
  // subbed 70+ = no bonus (zero)
};

function getScoreForEvent(eventType, player, extraData = {}) {
  const g = posGroup(player.pos);

  switch (eventType) {
    case 'goal': {
      const base = SCORE_TABLE.goal[g];
      // 3rd goal or assist = double
      const isThird = (extraData.nthEvent || 1) >= 3;
      return isThird ? base * 2 : base;
    }
    case 'assist': {
      const base = SCORE_TABLE.assist[g];
      const isThird = (extraData.nthEvent || 1) >= 3;
      return isThird ? base * 2 : base;
    }
    case 'yellow':     return SCORE_TABLE.yellow[g];
    case 'red':        return SCORE_TABLE.red[g];
    case 'own_goal':   return SCORE_TABLE.own_goal;
    case 'missed_pen': return SCORE_TABLE.missed_pen;
    case 'pen_save':   return SCORE_TABLE.pen_save;
    case 'clean_sheet':return SCORE_TABLE.clean_sheet[g];
    case 'full_90':    return SCORE_TABLE.full_90[g];
    case 'concede':
      return g === 'gk' ? SCORE_TABLE.concede_gk : (g === 'def' ? SCORE_TABLE.concede_def : 0);
    case 'sub': {
      const min = extraData.min || 90;
      if (min <= 45) return SCORE_TABLE.sub_halftime[g];
      if (min < 70)  return SCORE_TABLE.sub_before70[g];
      return 0;
    }
    default: return 0;
  }
}

// ═══════════════════════════════════════════════════════════════
// GAME STATE
// ═══════════════════════════════════════════════════════════════
let state = {
  myTeam: [],
  oppTeam: [],
  sequence: [],
  currentPick: 0,
  teamFilter: 'home',
  selectedPlayer: null,
  gkPickerIsMe: true,
  draftDone: false,
  myCaptain: null,
  oppCaptain: null,
  timerInterval: null,
  timerSecs: 30,
  simView: 'me',
  myScore: 0,
  oppScore: 0,
  playerData: {},
  teamName: '',
  teamEmoji: '',
  matchIdx: null,
  tipTaken: false,          // player looked at the reveal tip
  predictionPending: null,  // { resolve, isReal, eventType, playerName }
  predictionAnswer: null,   // true/false/null
  predictionTimerTimeout: null,
  autoPickLocked: false,    // prevents double auto-pick race condition
  mp: null,                 // multiplayer session object (null = single player)
};

function initPlayerData() {
  state.playerData = {};
  for (const p of PLAYERS) {
    state.playerData[p.id] = { pts: 0, events: [], subbed: false };
  }
}

// ═══════════════════════════════════════════════════════════════
// PROFILE SYSTEM
// ═══════════════════════════════════════════════════════════════

const PROFILE_STORAGE_KEY = 'worst-eleven-profiles';
const ARCHIVE_TOTAL = 7; // update as matches are added

// ── Badge definitions ─────────────────────────────────────────
const BADGE_DEFS = [
  { id: 'first_blood',   icon: '🩸', name: 'First Blood',    desc: 'Win your first game',           check: p => p.matches.some(m => m.result === 'W') },
  { id: 'hat_trick',     icon: '🎩', name: 'Hat Trick',      desc: 'Win 3 games',                   check: p => p.matches.filter(m => m.result === 'W').length >= 3 },
  { id: 'unstoppable',   icon: '💀', name: 'Unstoppable',    desc: 'Win 10 games',                  check: p => p.matches.filter(m => m.result === 'W').length >= 10 },
  { id: 'on_a_roll',     icon: '🔥', name: 'On a Roll',      desc: 'Win 3 in a row',                check: p => hasStreak(p, 'W', 3) },
  { id: 'hot_streak',    icon: '🌋', name: 'Hot Streak',     desc: 'Win 5 in a row',                check: p => hasStreak(p, 'W', 5) },
  { id: 'archivist',     icon: '📼', name: 'Archivist',      desc: 'Play all 7 archive matches',    check: p => uniqueMatchesPlayed(p) >= ARCHIVE_TOTAL },
  { id: 'half_way',      icon: '🗂️',  name: 'Half Way There', desc: 'Play 4 different matches',     check: p => uniqueMatchesPlayed(p) >= 4 },
  { id: 'century',       icon: '💯', name: 'Century',        desc: 'Win by 100+ total chaos pts',   check: p => p.matches.some(m => m.result === 'W' && (m.myScore - m.oppScore) >= 100) },
  { id: 'squeaky',       icon: '🤌', name: 'Squeaky',        desc: 'Win by 3 points or fewer',      check: p => p.matches.some(m => m.result === 'W' && (m.myScore - m.oppScore) <= 3) },
];

function hasStreak(profile, result, n) {
  const results = profile.matches.map(m => m.result);
  let streak = 0;
  for (const r of results) {
    streak = r === result ? streak + 1 : 0;
    if (streak >= n) return true;
  }
  return false;
}

function uniqueMatchesPlayed(profile) {
  return new Set(profile.matches.map(m => m.matchId)).size;
}

// ── Storage helpers ───────────────────────────────────────────
// Storage: localStorage is the expected persistence layer for this app
function loadProfiles() {
  try {
    const raw = localStorage.getItem(PROFILE_STORAGE_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch {
    return [];
  }
}

function saveProfiles(profiles) {
  try {
    localStorage.setItem(PROFILE_STORAGE_KEY, JSON.stringify(profiles));
  } catch (e) {
    console.warn('localStorage unavailable — profiles will not persist this session');
  }
}

// In-memory cache so we don't have to re-read localStorage everywhere
let _profiles = [];
let _activeProfileId = null;

function initProfiles() {
  _profiles = loadProfiles();
  renderHomeProfiles();
}

function getActiveProfile() {
  return _profiles.find(p => p.id === _activeProfileId) || null;
}

function createProfile(name, emoji) {
  const profile = {
    id: 'p_' + Date.now(),
    name,
    emoji,
    created: new Date().toISOString().slice(0, 10),
    matches: [],
  };
  _profiles.push(profile);
  saveProfiles(_profiles);
  return profile;
}

async function recordMatchResult({ matchId, matchLabel, result, myScore, oppScore, captainName }) {
  const profile = getActiveProfile();
  if (!profile) return;
  profile.matches.push({ matchId, matchLabel, result, myScore, oppScore, captainName, date: new Date().toISOString().slice(0, 10) });
  saveProfiles(_profiles);
}

// ── Home screen rendering ─────────────────────────────────────
function renderHomeProfiles() {
  const list = document.getElementById('home-profiles-list');
  if (!list) return;
  list.innerHTML = '';

  for (const p of _profiles) {
    const wins = p.matches.filter(m => m.result === 'W').length;
    const played = p.matches.length;
    const form = p.matches.slice(-5);

    const card = document.createElement('div');
    card.className = 'profile-card' + (p.id === _activeProfileId ? ' active-profile' : '');
    card.dataset.id = p.id;

    // Form pips
    const pipHtml = Array.from({ length: 5 }, (_, i) => {
      const m = form[form.length - 5 + i];
      if (!m) return `<div class="form-pip empty">·</div>`;
      return `<div class="form-pip ${m.result}">${m.result}</div>`;
    }).join('');

    card.innerHTML = `
      <div class="profile-card-emoji">${p.emoji}</div>
      <div class="profile-card-info">
        <div class="profile-card-name">${p.name}</div>
        <div class="profile-card-stats">${wins}W · ${played} played · ${played ? Math.round(wins/played*100) : 0}%</div>
        <div class="profile-card-form">${pipHtml}</div>
      </div>
      <button class="profile-card-viewbtn" onclick="event.stopPropagation();viewProfile('${p.id}')">Stats</button>
    `;
    card.addEventListener('click', () => selectProfile(p.id));
    list.appendChild(card);
  }

  // Update start button
  updateStartBtn();
}

function selectProfile(id) {
  _activeProfileId = id;
  const p = getActiveProfile();
  if (!p) return;

  // Pre-fill state
  state.teamName  = p.emoji + ' ' + p.name;
  state.teamEmoji = p.emoji;

  // Sync emoji button & name input for consistency
  const emojiBtn = document.getElementById('emoji-btn');
  const nameInput = document.getElementById('team-name-input');
  if (emojiBtn) emojiBtn.textContent = p.emoji;
  if (nameInput) nameInput.value = p.name;

  // Close new-profile form if open
  const form = document.getElementById('profile-new-form');
  if (form) form.classList.remove('open');

  renderHomeProfiles();
  updateStartBtn();
}

function updateStartBtn() {
  const btn   = document.getElementById('start-btn');
  const mpBtn = document.getElementById('mp-btn');
  if (btn)   btn.disabled   = !_activeProfileId;
  if (mpBtn) mpBtn.disabled = !_activeProfileId || !window._fbReady;
}

// ── New profile form ──────────────────────────────────────────
function openNewProfileForm() {
  _activeProfileId = null;
  renderHomeProfiles();
  updateStartBtn();
  const form = document.getElementById('profile-new-form');
  if (form) form.classList.add('open');
  const input = document.getElementById('team-name-input');
  if (input) { input.value = ''; input.focus(); }
  const saveBtn = document.getElementById('profile-save-btn');
  if (saveBtn) saveBtn.disabled = true;
}

function saveNewProfile() {
  const name = document.getElementById('team-name-input')?.value.trim();
  const emoji = document.getElementById('emoji-btn')?.textContent || '⚽';
  if (!name || name.length < 2) return;
  const p = createProfile(name, emoji);
  selectProfile(p.id);
  const form = document.getElementById('profile-new-form');
  if (form) form.classList.remove('open');
  renderHomeProfiles();
}

// ── Profile screen ────────────────────────────────────────────
function viewProfile(id) {
  _activeProfileId = id;
  const p = _profiles.find(pr => pr.id === id);
  if (!p) return;

  // Header
  document.getElementById('profile-header-emoji').textContent = p.emoji;
  document.getElementById('profile-name-big').textContent = p.name;
  document.getElementById('profile-header-sub').textContent = 'Since ' + p.created;

  // Stats
  const wins = p.matches.filter(m => m.result === 'W').length;
  const losses = p.matches.filter(m => m.result === 'L').length;
  const played = p.matches.length;
  document.getElementById('profile-wins').textContent = wins;
  document.getElementById('profile-played').textContent = played;
  document.getElementById('profile-winpct').textContent = played ? Math.round(wins/played*100) + '%' : '—';

  // Form strip (last 5)
  const formEl = document.getElementById('profile-form-strip');
  const form = p.matches.slice(-5);
  formEl.innerHTML = Array.from({ length: 5 }, (_, i) => {
    const m = form[form.length - 5 + i];
    if (!m) return `<div class="profile-form-pill empty">·</div>`;
    return `<div class="profile-form-pill ${m.result}">${m.result}</div>`;
  }).join('');

  // Archive progress
  const unique = uniqueMatchesPlayed(p);
  const pct = Math.round(unique / ARCHIVE_TOTAL * 100);
  document.getElementById('profile-archive-fill').style.width = pct + '%';
  document.getElementById('profile-archive-label').textContent = `${unique} / ${ARCHIVE_TOTAL} archive matches played (${pct}%)`;

  // Badges
  const badgesEl = document.getElementById('profile-badges-grid');
  badgesEl.innerHTML = BADGE_DEFS.map(b => {
    const earned = b.check(p);
    return `
      <div class="profile-badge ${earned ? 'earned' : 'locked'}">
        <span class="profile-badge-icon">${b.icon}</span>
        <span class="profile-badge-name">${b.name}</span>
        <span class="profile-badge-desc">${b.desc}</span>
      </div>
    `;
  }).join('');

  showScreen('profile');
}

function viewActiveProfile() {
  if (_activeProfileId) viewProfile(_activeProfileId);
}

// ── Post-match form tile ──────────────────────────────────────
function renderPostMatchFormTile() {
  const profile = getActiveProfile();
  const section = document.getElementById('result-form-section');
  if (!profile || !section) return;

  section.style.display = '';
  const title = document.getElementById('result-form-section-title');
  if (title) title.textContent = profile.emoji + ' ' + profile.name;

  const wins = profile.matches.filter(m => m.result === 'W').length;
  const played = profile.matches.length;
  const form = profile.matches.slice(-5);

  const stripEl = document.getElementById('result-form-strip');
  if (stripEl) {
    stripEl.innerHTML = Array.from({ length: 5 }, (_, i) => {
      const m = form[form.length - 5 + i];
      if (!m) return `<div class="profile-form-pill empty" style="width:32px;height:32px;font-size:14px;">·</div>`;
      return `<div class="profile-form-pill ${m.result}" style="width:32px;height:32px;font-size:14px;">${m.result}</div>`;
    }).join('');
  }

  const statsEl = document.getElementById('result-form-stats');
  if (statsEl) statsEl.textContent = `${wins}W from ${played} played · ${played ? Math.round(wins/played*100) : 0}% win rate`;
}

// ── Init ──────────────────────────────────────────────────────
document.addEventListener('DOMContentLoaded', () => { initProfiles(); });

// ═══════════════════════════════════════════════════════════════
// NAVIGATION
// ═══════════════════════════════════════════════════════════════
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById('screen-' + id).classList.add('active');
  window.scrollTo(0, 0);
}

function goToDraft() {
  showScreen('coin');
  startCoinFlow();
}

// ═══════════════════════════════════════════════════════════════
// COIN SCREEN — 3-phase flow: load → reveal → flip → draft
// ═══════════════════════════════════════════════════════════════
const REEL_LINES = [
  'Searching the archives…',
  'Rewinding the tape…',
  'Dusting off the VHS…',
  'Checking the score sheets…',
  'Loading match data…',
  'Consulting the archives…',
  'Finding the highlights reel…',
];

function showCoinPhase(phase) {
  ['loading','reveal','flip'].forEach(p => {
    const el = document.getElementById('coin-phase-' + p);
    if (el) el.style.display = p === phase ? 'flex' : 'none';
  });
}

function startCoinFlow() {
  showCoinPhase('loading');

  // Cycle loading lines for 1.5s then pick match and reveal
  let t = 0;
  const linesEl = document.getElementById('coin-loading-lines');
  const lineInterval = setInterval(() => {
    linesEl.textContent = REEL_LINES[t % REEL_LINES.length];
    t++;
  }, 220);

  setTimeout(() => {
    clearInterval(lineInterval);

    // Pick random match
    let idx;
    do { idx = Math.floor(Math.random() * ALL_MATCHES.length); }
    while (ALL_MATCHES.length > 1 && idx === state.matchIdx);
    loadMatch(idx);

    revealMatch(ALL_MATCHES[idx]);
  }, 1500);
}

function revealMatch(m) {
  // Reset tip state for fresh game
  state.tipTaken = false;
  const tipBtn     = document.getElementById('reveal-tip-btn');
  const tipContent = document.getElementById('reveal-tip-content');
  const tipCost    = document.querySelector('.reveal-tip-cost');
  if (tipBtn)     { tipBtn.disabled = false; }
  if (tipContent) { tipContent.style.display = 'none'; tipContent.innerHTML = ''; }
  if (tipCost)    { tipCost.innerHTML = '−5 pts penalty if you look'; }

  document.getElementById('coin-reveal-matchup').textContent = `${m.meta.home} vs ${m.meta.away}`;
  document.getElementById('coin-reveal-date').textContent = m.meta.date.toUpperCase();
  document.getElementById('coin-reveal-blurb').innerHTML = m.meta.blurb;

  showCoinPhase('reveal');

  // Countdown bar — 10 seconds
  const fill  = document.getElementById('coin-countdown-fill');
  const label = document.getElementById('coin-countdown-label');
  const TOTAL = 10;
  let secs = TOTAL;

  // Start bar at full, shrink over 10s
  fill.style.transition = 'none';
  fill.style.width = '100%';
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      fill.style.transition = `width ${TOTAL}s linear`;
      fill.style.width = '0%';
    });
  });

  const countdown = setInterval(() => {
    secs--;
    label.textContent = secs > 0 ? `Coin flip in ${secs}…` : 'Flipping…';
    if (secs <= 0) {
      clearInterval(countdown);
      runCoinFlip();
    }
  }, 1000);
}

function revealTip() {
  if (state.tipTaken) return;
  state.tipTaken = true;

  const m = ALL_MATCHES[state.matchIdx];
  if (!m) return;

  // Generate a tip from the real match events
  const goals = EVENTS.filter(e => e.type === 'goal');
  const reds  = EVENTS.filter(e => e.type === 'red');
  const homeGoals = goals.filter(e => PLAYERS.find(p => p.id === e.playerId && p.team === 'home')).length;
  const awayGoals = goals.filter(e => PLAYERS.find(p => p.id === e.playerId && p.team === 'away')).length;

  let tip;
  if (reds.length > 0 && Math.random() < 0.5) {
    // Tip about a red card — give team but not player
    const redPlayer = PLAYERS.find(p => p.id === reds[0].playerId);
    const teamName = redPlayer ? redPlayer.teamName : 'one of the teams';
    tip = `Someone from <strong>${teamName}</strong> won't last the full 90 minutes today.`;
  } else if (homeGoals !== awayGoals) {
    const moreTeam = homeGoals > awayGoals ? m.meta.home : m.meta.away;
    const diff = Math.abs(homeGoals - awayGoals);
    if (diff >= 3) {
      tip = `<strong>${moreTeam}</strong> are going to have a very good day. Draft accordingly.`;
    } else {
      tip = `<strong>${moreTeam}</strong> score more than the other side today.`;
    }
  } else {
    tip = `Both teams score in this one. It's a game of two halves.`;
  }

  const btn     = document.getElementById('reveal-tip-btn');
  const content = document.getElementById('reveal-tip-content');
  const cost    = document.querySelector('.reveal-tip-cost');

  if (btn) btn.disabled = true;
  if (cost) cost.innerHTML = `<span class="reveal-tip-taken">−5 pts applied at kick-off</span>`;
  if (content) {
    content.innerHTML = tip;
    content.style.display = '';
  }
}

function applyTipPenalty() {
  if (state.tipTaken) {
    state.myScore -= 5;
    updateScoreDisplay();
    flashPredResult('−5 TIP PENALTY', 'wrong');
  }
}

function runCoinFlip() {
  showCoinPhase('flip');

  const coin   = document.getElementById('coin');
  const status = document.getElementById('coin-status');
  const sub    = document.getElementById('coin-sub');

  coin.textContent = '🪙';
  coin.style.transform = '';
  status.textContent = '';
  sub.textContent = '';

  // Spin animation
  let flips = 0;
  const faces = ['🪙', '⚽'];
  const spinInterval = setInterval(() => {
    coin.textContent = faces[flips % 2];
    coin.style.transform = `rotateY(${flips * 180}deg) scale(${flips % 2 === 0 ? 1 : 0.85})`;
    flips++;
    if (flips > 10) {
      clearInterval(spinInterval);

      const playerWins = Math.random() < 0.5;
      state.gkPickerIsMe = playerWins;
      coin.style.transform = '';
      coin.textContent = playerWins ? '✅' : '❌';

      if (playerWins) {
        status.textContent = 'YOU WIN';
        sub.textContent = 'You pick the goalkeeper first';
      } else {
        status.textContent = 'OPPONENT WINS';
        sub.textContent = 'Opponent picks the goalkeeper first';
      }

      // Auto-proceed to draft after 3s
      setTimeout(() => {
        setupDraft();
        showScreen('draft');
      }, 3000);
    }
  }, 120);
}
const TEAM_EMOJIS = ['⚽','🏆','🥅','🧤','🟨','🟥','🎽','🦵','👟','🏟️','🪄','💀','👑','🔥','💥','⚡','🤡','🐐','🫠','🤌'];
let emojiIndex = 0;
let emojiPickerOpen = false;

function buildEmojiGrid() {
  const grid = document.getElementById('emoji-grid');
  grid.innerHTML = '';
  TEAM_EMOJIS.forEach((em, i) => {
    const btn = document.createElement('button');
    btn.className = 'emoji-grid-item' + (i === emojiIndex ? ' selected' : '');
    btn.textContent = em;
    btn.onclick = () => selectEmoji(i);
    grid.appendChild(btn);
  });
}

function toggleEmojiPicker() {
  emojiPickerOpen = !emojiPickerOpen;
  const grid = document.getElementById('emoji-grid');
  if (emojiPickerOpen) {
    buildEmojiGrid();
    grid.style.display = 'grid';
  } else {
    grid.style.display = 'none';
  }
}

function selectEmoji(i) {
  emojiIndex = i;
  document.getElementById('emoji-btn').textContent = TEAM_EMOJIS[i];
  // Update selected state
  document.querySelectorAll('.emoji-grid-item').forEach((el, idx) => {
    el.classList.toggle('selected', idx === i);
  });
  // Close picker after short delay so tap feels responsive
  setTimeout(() => {
    document.getElementById('emoji-grid').style.display = 'none';
    emojiPickerOpen = false;
  }, 200);
}

function randomEmoji() {
  const i = Math.floor(Math.random() * TEAM_EMOJIS.length);
  emojiIndex = i;
  document.getElementById('emoji-btn').textContent = TEAM_EMOJIS[i];
  if (emojiPickerOpen) buildEmojiGrid();
}

function onTeamNameInput() {
  const val = document.getElementById('team-name-input')?.value.trim();
  const saveBtn = document.getElementById('profile-save-btn');
  if (saveBtn) saveBtn.disabled = !val || val.length < 2;
}

function startGame() {
  // Must have an active profile
  if (!_activeProfileId) return;
  const p = getActiveProfile();
  state.teamName  = p.emoji + ' ' + p.name;
  state.teamEmoji = p.emoji;
  goToDraft();
}

function restart() {
  state = {
    myTeam: [], oppTeam: [],
    sequence: [], currentPick: 0,
    teamFilter: 'home', selectedPlayer: null,
    gkPickerIsMe: true,
    draftDone: false, timerInterval: null, timerSecs: 30,
    myCaptain: null, oppCaptain: null,
    simView: 'me', myScore: 0, oppScore: 0, playerData: {},
    teamName: '', teamEmoji: '', matchIdx: null,
    tipTaken: false, predictionPending: null, predictionAnswer: null, predictionTimerTimeout: null,
    autoPickLocked: false,
    mp: null,
  };
  const form = document.getElementById('profile-new-form');
  if (form) form.classList.remove('open');
  document.getElementById('emoji-grid').style.display = 'none';
  emojiIndex = 0;
  emojiPickerOpen = false;
  renderHomeProfiles(); // re-render so active profile stays highlighted
  showScreen('home');
}


/*
  EXACT DRAFT SEQUENCE:
  Step 0:  GK winner picks GK for themselves → other GK auto to loser
  Steps 1–6:  3 sabotage rounds, loser leads each round
              loser sab1, winner sab1, loser sab2, winner sab2, loser sab3, winner sab3
  Steps 7–20: 7 normal rounds alternating, loser leads
              loser n1, winner n1, loser n2, winner n2 ... loser n7, winner n7

  We encode this as a flat array of {who, type} objects.
*/
function buildDraftSequence(gkWinner) {
  const winner = gkWinner;
  const loser  = gkWinner === 'me' ? 'opp' : 'me';
  const seq = [];

  // GK: winner picks, other is auto-assigned
  seq.push({ who: winner, type: 'gk' });

  // Sabotage rounds (picks go to opponent's squad):
  // Round 1: loser, winner
  // Round 2: winner, loser
  // Round 3: loser, winner
  seq.push({ who: loser,  type: 'sabotage' }); // Loser sab 1
  seq.push({ who: winner, type: 'sabotage' }); // Winner sab 1
  seq.push({ who: winner, type: 'sabotage' }); // Winner sab 2
  seq.push({ who: loser,  type: 'sabotage' }); // Loser sab 2
  seq.push({ who: loser,  type: 'sabotage' }); // Loser sab 3
  seq.push({ who: winner, type: 'sabotage' }); // Winner sab 3

  // Normal picks: loser leads, then alternate
  for (let i = 0; i < 7; i++) {
    seq.push({ who: loser,  type: 'normal' });
    seq.push({ who: winner, type: 'normal' });
  }

  return seq; // 21 steps: 1 GK + 6 sab + 14 normal
}

function setupDraft() {
  state.myTeam        = [];
  state.oppTeam       = [];
  state.currentPick   = 0;
  state.selectedPlayer = null;
  state.teamFilter    = 'home';

  const gkWinner = state.gkPickerIsMe !== false ? 'me' : 'opp';
  state.sequence = buildDraftSequence(gkWinner);

  // Set team name label from home screen
  const myLabel = document.getElementById('my-zone-label');
  if (myLabel) {
    const name = state.teamName || 'Your XI';
    myLabel.innerHTML = `<span class="dot yours"></span> ${name}`;
  }

  renderDraftSlots();
  renderCarousel();
  updateTurnUI();

  // If opponent won coin flip they do the GK pick first — auto-pick it
  if (gkWinner === 'opp') {
    setTimeout(() => autoPickGK(), 1000);
  } else {
    startTimer();
  }
}

function currentStep() {
  return state.sequence[state.currentPick] || null;
}

function renderDraftSlots() {
  const oppEl = document.getElementById('opp-slots');
  const myEl  = document.getElementById('my-slots');
  oppEl.innerHTML = '';
  myEl.innerHTML  = '';

  for (let i = 0; i < 11; i++) {
    const oSlot = document.createElement('div');
    oSlot.className = 'player-slot ' + (i < state.oppTeam.length ? 'filled opponent-slot' : 'empty-slot');
    if (i < state.oppTeam.length) {
      const p = getPlayer(state.oppTeam[i]);
      oSlot.innerHTML = `<div class="slot-pos">${p.pos}</div><div class="slot-name">${p.name.split(' ').pop()}</div><div class="slot-team">${p.team === 'home' ? '🔵' : '🟡'}</div>`;
    } else {
      oSlot.innerHTML = `<div class="slot-pos">${i+1}</div>`;
    }
    oppEl.appendChild(oSlot);

    const mSlot = document.createElement('div');
    mSlot.className = 'player-slot ' + (i < state.myTeam.length ? 'filled your-slot' : 'empty-slot');
    if (i < state.myTeam.length) {
      const p = getPlayer(state.myTeam[i]);
      mSlot.innerHTML = `<div class="slot-pos">${p.pos}</div><div class="slot-name">${p.name.split(' ').pop()}</div><div class="slot-team">${p.team === 'home' ? '🔵' : '🟡'}</div>`;
    } else {
      mSlot.innerHTML = `<div class="slot-pos">${i+1}</div>`;
    }
    myEl.appendChild(mSlot);
  }

  // Sabotage pips for MY sabotages (steps 1–6, my turns)
  const mySabsDone = state.sequence
    ? state.sequence.slice(0, state.currentPick).filter(s => s.who === 'me' && s.type === 'sabotage').length
    : 0;
  const sabLeft = 3 - mySabsDone;
  const pips = document.getElementById('sabotage-pips');
  pips.innerHTML = '';
  for (let i = 0; i < 3; i++) {
    const pip = document.createElement('div');
    pip.className = 'sabotage-pip' + (i < sabLeft ? ' active' : '');
    pips.appendChild(pip);
  }
  document.getElementById('sabotage-label').textContent =
    sabLeft > 0 ? `${sabLeft} sabotage${sabLeft !== 1 ? 's' : ''} to send` : 'Sabotages complete';
}

function renderCarousel(scrollToTeam = null) {
  const track = document.getElementById('carousel-track');
  const container = document.getElementById('carousel-container');

  // Save scroll position before re-rendering (unless a tab jump was requested)
  const savedScroll = scrollToTeam ? 0 : (container ? container.scrollLeft : 0);

  track.innerHTML = '';

  const step = currentStep();
  const drafted = [...state.myTeam, ...state.oppTeam];

  let available;
  if (step && step.type === 'gk') {
    available = PLAYERS.filter(p => !drafted.includes(p.id) && p.pos === 'GK');
  } else {
    const city    = PLAYERS.filter(p => !drafted.includes(p.id) && p.team === 'home');
    const watford = PLAYERS.filter(p => !drafted.includes(p.id) && p.team === 'away');
    available = [...city, ...watford];
  }

  state.teamStartIndex = {
    home: 0,
    away: available.filter(p => p.team === 'home').length
  };

  for (const p of available) {
    const isSelected = state.selectedPlayer === p.id;
    const card = document.createElement('div');
    card.className = 'player-card' + (isSelected ? ' selected' : '');
    card.dataset.team = p.team;
    card.onclick = () => selectPlayer(p.id);
    card.innerHTML = `
      <div class="card-pos">${p.pos}</div>
      <div class="card-name">${p.name}</div>
      <div class="card-team"><span class="card-team-dot ${p.team}-dot"></span>${p.teamName}</div>
    `;
    track.appendChild(card);
  }

  if (available.length === 0) {
    track.innerHTML = '<div style="padding:20px;color:var(--muted);font-size:13px;">All players drafted</div>';
  }

  requestAnimationFrame(() => {
    if (scrollToTeam) {
      // Tab tapped — jump to start of that team
      const cards = track.querySelectorAll('.player-card');
      const idx = state.teamStartIndex[scrollToTeam] || 0;
      if (cards[idx]) {
        container.scrollTo({ left: cards[idx].offsetLeft - 12, behavior: 'smooth' });
      }
    } else {
      // Normal re-render — restore scroll position
      container.scrollLeft = savedScroll;
    }
  });
}

function selectPlayer(id) {
  state.selectedPlayer = state.selectedPlayer === id ? null : id;
  renderCarousel();
}

function setTeamFilter(team) {
  state.teamFilter = team;
  document.getElementById('toggle-home').classList.toggle('active', team === 'home');
  document.getElementById('toggle-away').classList.toggle('active', team === 'away');
  renderCarousel(team);
}

function updateTurnUI() {
  const step = currentStep();
  if (!step) return;

  const isMyTurn = step.who === 'me';
  const btn = document.getElementById('btn-me');
  document.getElementById('btn-sabotage').style.display = 'none';

  if (step.type === 'gk') {
    document.getElementById('turn-text').innerHTML = isMyTurn
      ? `<em>You won the toss!</em> Pick your goalkeeper`
      : `<em>Opponent won the toss.</em> Picking GK…`;
    btn.textContent = 'Pick GK';
    btn.disabled = !isMyTurn;
    btn.style.background = 'var(--blue)';

  } else if (step.type === 'sabotage') {
    const mySabsDone = state.sequence.slice(0, state.currentPick).filter(s => s.who === 'me' && s.type === 'sabotage').length;
    const oppSabsDone = state.sequence.slice(0, state.currentPick).filter(s => s.who === 'opp' && s.type === 'sabotage').length;
    if (isMyTurn) {
      document.getElementById('turn-text').innerHTML =
        `⚡ Sabotage <em>· ${mySabsDone + 1} of 3 — goes to opponent</em>`;
      btn.textContent = '⚡ Send to Opp';
      btn.disabled = false;
      btn.style.background = 'var(--red)';
    } else {
      document.getElementById('turn-text').innerHTML =
        `⚡ Opp sabotaging you <em>· ${oppSabsDone + 1} of 3</em>`;
      btn.disabled = true;
      btn.style.background = 'var(--red)';
      btn.textContent = '⚡ Send to Opp';
    }

  } else {
    const myNormalDone = state.sequence.slice(0, state.currentPick).filter(s => s.who === 'me' && s.type === 'normal').length;
    const oppNormalDone = state.sequence.slice(0, state.currentPick).filter(s => s.who === 'opp' && s.type === 'normal').length;
    if (isMyTurn) {
      document.getElementById('turn-text').innerHTML =
        `Your pick <em>· ${myNormalDone + 1} of 7</em>`;
      btn.textContent = 'Pick for Me';
      btn.disabled = false;
      btn.style.background = 'var(--blue)';
    } else {
      document.getElementById('turn-text').innerHTML =
        `Opponent picking… <em>· ${oppNormalDone + 1} of 7</em>`;
      btn.disabled = true;
      btn.style.background = 'var(--blue)';
      btn.textContent = 'Pick for Me';
    }
  }
}

function draftPlayer() {
  const step = currentStep();
  if (!step || step.who !== 'me') return;
  if (!state.selectedPlayer) { showToast('Select a player first!'); return; }

  // Guard: player already drafted (race condition between timer and manual pick)
  const alreadyDrafted = [...state.myTeam, ...state.oppTeam];
  if (alreadyDrafted.includes(state.selectedPlayer)) {
    state.selectedPlayer = null;
    renderCarousel();
    return;
  }

  if (step.type === 'gk') {
    const p = getPlayer(state.selectedPlayer);
    if (p.pos !== 'GK') { showToast('Must pick a goalkeeper!'); return; }
    state.myTeam.push(state.selectedPlayer);
    const otherGK = PLAYERS.find(q => q.pos === 'GK' && q.id !== state.selectedPlayer);
    state.oppTeam.push(otherGK.id);
    showToast(`You pick ${p.name} · ${otherGK.name} goes to opponent`);

  } else if (step.type === 'sabotage') {
    state.oppTeam.push(state.selectedPlayer);

  } else {
    state.myTeam.push(state.selectedPlayer);
  }

  state.selectedPlayer = null;
  state.currentPick++;
  resetTimer();
  afterPick();
}

function afterPick() {
  if (state.myTeam.length === 11 && state.oppTeam.length === 11) {
    clearInterval(state.timerInterval);
    renderDraftSlots();
    renderCarousel();
    setTimeout(() => showCaptainScreen(), 600);
    return;
  }

  const next = currentStep();
  renderDraftSlots();
  renderCarousel();
  updateTurnUI();

  // If only 1 player left in the pool and it's my turn, auto-draft them
  if (next && next.who === 'me' && next.type === 'normal') {
    const drafted = [...state.myTeam, ...state.oppTeam];
    const available = PLAYERS.filter(p => !drafted.includes(p.id));
    if (available.length === 1 && !state.autoPickLocked) {
      state.autoPickLocked = true;
      const autoPick = available[0];
      clearInterval(state.timerInterval); // stop timer so it can't also fire
      setTimeout(() => {
        state.autoPickLocked = false;
        // Re-check still valid (guard against concurrent picks)
        if (state.myTeam.includes(autoPick.id) || state.oppTeam.includes(autoPick.id)) return;
        showToast(`Only one left — ${autoPick.name} joins your squad!`);
        state.myTeam.push(autoPick.id);
        state.selectedPlayer = null;
        state.currentPick++;
        resetTimer();
        afterPick();
      }, 1200);
      return;
    }
  }

  if (next && next.who === 'opp') {
    setTimeout(() => autoPickOpponent(), 1100);
  }
}

function autoPickGK() {
  const gks = PLAYERS.filter(p => p.pos === 'GK');
  const pick = gks.reduce((best, p) => (CHAOS_VALUES[p.id] || 0) > (CHAOS_VALUES[best.id] || 0) ? p : best, gks[0]);
  const otherGK = gks.find(p => p.id !== pick.id);
  state.oppTeam.push(pick.id);
  state.myTeam.push(otherGK.id);
  state.currentPick++;
  showToast(`Opponent picks ${pick.name} · You get ${otherGK.name}`);
  afterPick();
  startTimer();
}

// Chaos values computed dynamically from EVENTS for the loaded match.
// Higher = more chaos potential (cards, own goals, concedes, early subs)
// Lower = too good (goals, assists = bad for opponent to have)
let CHAOS_VALUES = {};

function computeChaosValues() {
  CHAOS_VALUES = {};

  // Match-level info a football fan would reasonably know or infer:
  // total goals, and which team conceded more (from the scoreline context)
  const homeGoals = EVENTS.filter(e => e.type === 'goal' && PLAYERS.find(p => p.id === e.playerId && p.team === 'home')).length;
  const awayGoals = EVENTS.filter(e => e.type === 'goal' && PLAYERS.find(p => p.id === e.playerId && p.team === 'away')).length;
  const totalGoals = homeGoals + awayGoals;

  // How many goals did each team concede (match-level, not player-level)
  const goalsAgainst = { home: awayGoals, away: homeGoals };

  // Position-based chaos priors — what a knowledgeable fan would expect
  // before knowing exactly what happened
  // Higher = more likely to generate chaos points (cards, subs, own goals)
  // Lower  = more likely to be a "good" contributor (goals, assists)
  const POSITION_PRIOR = {
    GK:  5,   // moderate — could be busy if team conceded, but quiet if clean sheet
    CB:  8,   // defenders often get subbed, carded; rarely score
    RB:  6,
    LB:  6,
    DM:  7,   // holding midfielders: bookings, early subs
    CM:  5,   // could go either way
    AM:  3,   // attacking mid — more likely to contribute positively (bad for us)
    RW:  2,   // wingers and forwards — goal threat, avoid
    LW:  2,
    ST:  1,   // strikers most likely to score — lowest chaos prior
  };

  for (const p of PLAYERS) {
    const prior = POSITION_PRIOR[p.pos] || 5;

    // Contextual adjustment: defenders on the leaky side are more valuable
    // (they'll have conceded goals = chaos points for us)
    // A fan would reason: "that team got battered, their defenders must have had a mare"
    const isBackline = ['GK','CB','RB','LB'].includes(p.pos);
    const concededByTeam = goalsAgainst[p.team] || 0;
    const leakyBonus = isBackline ? concededByTeam * 2.5 : 0;

    // Forwards on the high-scoring side are dangerous to pick (they probably scored)
    // A fan would reason: "their attack was on fire — don't pick them"
    const isAttacker = ['ST','RW','LW','AM'].includes(p.pos);
    const goalsScoredByTeam = p.team === 'home' ? homeGoals : awayGoals;
    const attackerPenalty = isAttacker ? goalsScoredByTeam * 1.5 : 0;

    // Base estimate before noise
    const baseEstimate = prior + leakyBonus - attackerPenalty;

    // Add ±35% noise — the AI is going on gut feel and reputation,
    // not a spreadsheet. Sometimes it'll get it badly wrong.
    const noise = baseEstimate * (Math.random() * 0.7 - 0.35);

    CHAOS_VALUES[p.id] = baseEstimate + noise;
  }
}

function autoPickOpponent() {
  const step = currentStep();
  if (!step || step.who !== 'opp') return;

  const drafted = [...state.myTeam, ...state.oppTeam];
  const available = PLAYERS.filter(p => !drafted.includes(p.id));
  if (available.length === 0) return;

  const sorted = [...available].sort((a, b) => (CHAOS_VALUES[b.id] || 0) - (CHAOS_VALUES[a.id] || 0));

  if (step.type === 'sabotage') {
    // Send the worst player (most harmful to player = lowest chaos) to my team
    const pick = sorted[sorted.length - 1];
    state.myTeam.push(pick.id);
    showToast(`⚡ Opponent sends ${pick.name} to your squad!`);
  } else {
    // Normal pick: take best chaos player
    const pick = sorted[0];
    state.oppTeam.push(pick.id);
  }

  state.currentPick++;
  afterPick();
}


// Timer
function getTimerDuration() {
  // Last 5 picks for the human player = 10 seconds, otherwise 30
  const myPicksSoFar = state.sequence
    ? state.sequence.slice(0, state.currentPick).filter(s => s.who === 'me').length
    : 0;
  const myPicksTotal = state.sequence
    ? state.sequence.filter(s => s.who === 'me').length
    : 11;
  const picksRemaining = myPicksTotal - myPicksSoFar;
  return picksRemaining <= 5 ? 10 : 30;
}

function startTimer() {
  const duration = getTimerDuration();
  state.timerSecs = duration;
  state.timerDuration = duration;
  updateTimerDisplay();
  state.timerInterval = setInterval(() => {
    state.timerSecs--;
    updateTimerDisplay();
    if (state.timerSecs <= 0) {
      clearInterval(state.timerInterval);
      const step = currentStep();
      if (step && step.who === 'me') {
        const drafted = [...state.myTeam, ...state.oppTeam];
        const available = PLAYERS.filter(p => {
          if (drafted.includes(p.id)) return false;
          if (step.type === 'gk') return p.pos === 'GK';
          return true;
        });
        if (available.length > 0) {
          // Random auto-assign when timer expires
          const randomPick = available[Math.floor(Math.random() * available.length)];
          state.selectedPlayer = randomPick.id;
          draftPlayer();
        }
      }
    }
  }, 1000);
}

function resetTimer() {
  clearInterval(state.timerInterval);
  startTimer();
}

function updateTimerDisplay() {
  const circ = document.getElementById('timer-circle');
  const num = document.getElementById('timer-num');
  const duration = state.timerDuration || 30;
  const circumference = 100;
  num.textContent = state.timerSecs;
  const pct = state.timerSecs / duration;
  circ.style.strokeDashoffset = circumference * (1 - pct);
  circ.style.stroke = state.timerSecs > (duration * 0.33) ? '#f5a623' : '#e8290b';
}

// ═══════════════════════════════════════════════════════════════
// SIMULATION ENGINE
// ═══════════════════════════════════════════════════════════════

const COMMENTARY = {
  goal: [
    (name) => `<strong>${name}</strong> — finds the back of the net. Nothing the keeper could do.`,
    (name) => `<strong>${name}</strong> scores. Easy as you like.`,
    (name) => `And it's <strong>${name}</strong>. Clinical finish.`,
  ],
  own_goal: [
    (name) => `Oh no. <strong>${name}</strong> turns it in. Complete mix-up at the back.`,
    (name) => `<strong>${name}</strong> — own goal. The crowd falls silent.`,
    (name) => `Incredible scenes. <strong>${name}</strong> into his own net.`,
  ],
  red: [
    (name) => `<strong>${name}</strong> is off! Red card. No arguments there.`,
    (name) => `<strong>${name}</strong> shown a straight red. He's off.`,
  ],
  yellow: [
    (name) => `<strong>${name}</strong> booked. Frustration showing.`,
    (name) => `Yellow for <strong>${name}</strong>. He's lucky it's not more.`,
    (name) => `<strong>${name}</strong> in the book.`,
  ],
  sub: [
    (name) => `<strong>${name}</strong> withdrawn. Manager's seen enough.`,
    (name) => `Off comes <strong>${name}</strong>. Early bath.`,
    (name) => `<strong>${name}</strong> is hauled off. Not his afternoon.`,
  ],
  assist: [
    (name) => `Lovely ball from <strong>${name}</strong> — that had to be finished.`,
    (name) => `<strong>${name}</strong> with the assist. He's running this game.`,
  ],
  hat_trick: [
    (name) => `HAT-TRICK! <strong>${name}</strong> completes it! Extraordinary scenes!`,
  ],
  neutral: [
    () => `Nothing much happening. Both sides feeling each other out.`,
    () => `Tight game so far. Plenty of running but little creativity.`,
    () => `The referee's having a quiet afternoon. For now.`,
    () => `Late tension building. Everything still to play for.`,
  ],
};

// Near-miss fake beats — { build, resolve, emoji }
// build = suspense line, resolve = deflation line ~3s later
const NEAR_MISSES = {
  shot: [
    { build: (n) => `<strong>${n}</strong> shaping up for a shot here…`,        setup: (n) => `<strong>${n}</strong> picks it up on the edge of the box…`,        resolve: (n) => `…just over the bar! <strong>${n}</strong> puts his hands on his head.`,     emoji: '😬' },
    { build: (n) => `<strong>${n}</strong> cuts inside, pulls the trigger…`,     setup: (n) => `<strong>${n}</strong> driving at goal, defenders backing off…`,      resolve: (n) => `…straight at the keeper. <strong>${n}</strong> will be disappointed with that.`, emoji: '🧤' },
    { build: (n) => `Free kick for <strong>${n}</strong>, in a dangerous position…`, setup: (n) => `<strong>${n}</strong> standing over this, the wall's set…`,       resolve: (n) => `…into the wall. Nothing comes of it.`,                                    emoji: '🧱' },
    { build: (n) => `<strong>${n}</strong> through on goal here, one on one…`,   setup: (n) => `<strong>${n}</strong> played in behind — it's just him and the keeper…`, resolve: (n) => `…keeper spreads himself and saves it! Not today.`,                     emoji: '🧤' },
    { build: (n) => `Header from <strong>${n}</strong>!…`,                       setup: (n) => `Corner coming in, <strong>${n}</strong> getting across his man…`,     resolve: (n) => `…off the post! Agonising. The woodwork saves them.`,                     emoji: '😩' },
    { build: (n) => `<strong>${n}</strong> lines up from distance…`,             setup: (n) => `<strong>${n}</strong> has space, 30 yards out, eyeing the top corner…`, resolve: (n) => `…blazes it wide. Not his finest moment.`,                               emoji: '😅' },
    { build: (n) => `Corner coming in, <strong>${n}</strong> lurking at the back post…`, setup: (n) => `<strong>${n}</strong> peeling off his marker at the back stick…`, resolve: (n) => `…over! He'll say he got a touch.`,                                      emoji: '🙈' },
  ],
  card: [
    { build: (n) => `Ooh, <strong>${n}</strong> goes in late there, referee has a look…`,   setup: (n) => `<strong>${n}</strong> charging in — he's going to be late on this…`,   resolve: (n) => `…plays on. Ref keeps his cards in his pocket. Lucky escape.`,     emoji: '😤' },
    { build: (n) => `<strong>${n}</strong> not happy, getting in the ref's face here…`,     setup: (n) => `<strong>${n}</strong> fuming after that decision, storming over…`,      resolve: (n) => `…just a word. He's getting away with that.`,                       emoji: '🫣' },
    { build: (n) => `Bit of handbags near the touchline, <strong>${n}</strong> involved…`, setup: (n) => `Tempers fraying here, <strong>${n}</strong> right in the middle of it…`, resolve: (n) => `…ref steps in. No card, but he's noted the name.`,                 emoji: '📋' },
    { build: (n) => `Nasty challenge from <strong>${n}</strong>, crowd baying for a card…`, setup: (n) => `<strong>${n}</strong> sliding in, studs showing — this looks bad…`,     resolve: (n) => `…ref says play on. Remarkable decision.`,                          emoji: '🤯' },
    { build: (n) => `<strong>${n}</strong> catches his man studs up, ref coming over…`,     setup: (n) => `<strong>${n}</strong> going in high, the ref is running across…`,        resolve: (n) => `…talking to him but no card. He won't be told twice.`,             emoji: '😬' },
  ],
  var: [
    { build: (n) => `Hold on — they're checking the VAR monitor. <strong>${n}</strong> might be in trouble here…`, setup: (n) => `Play stopped. The officials are huddling, looking at the screen…`, resolve: (n) => `…no action. They're waving play on.`, emoji: '📺' },
    { build: (n) => `Referee goes to the screen to check <strong>${n}</strong>'s challenge…`, setup: (n) => `VAR intervenes. Everyone's waiting…`,                          resolve: (n) => `…no card. Close, though. Very close.`,                          emoji: '📺' },
  ],
  injury: [
    { build: (n) => `<strong>${n}</strong> down injured, physios running on…`,   setup: (n) => `<strong>${n}</strong> pulling up short, holding his hamstring…`,    resolve: (n) => `…up on his feet. He'll be okay, just cramp.`,                               emoji: '🩺' },
    { build: (n) => `<strong>${n}</strong> taking a knock here, looking sore…`,  setup: (n) => `<strong>${n}</strong> takes a heavy challenge, doesn't look right…`, resolve: (n) => `…back on his feet. Gets on with it.`,                                       emoji: '💪' },
  ],
  chance: [
    { build: (n) => `Penalty shout! <strong>${n}</strong> goes down in the box…`, setup: (n) => `<strong>${n}</strong> twisting in the area — contact there, surely…`, resolve: (n) => `…nothing given. Referee not interested. <strong>${n}</strong> furious.`,   emoji: '😡' },
    { build: (n) => `<strong>${n}</strong> appeals for handball, arms waving everywhere…`, setup: (n) => `Ball strikes an arm in the area — <strong>${n}</strong> already appealing…`, resolve: (n) => `…play continues. The ref isn't buying it.`,                        emoji: '🙅' },
  ],
};

function pickNearMiss(playerName, allowVar = true) {
  // Weight card scares higher — core jeopardy
  const allTypes = allowVar
    ? ['shot','shot','card','card','card','chance','chance','var','injury']
    : ['shot','shot','card','card','card','chance','chance','injury'];
  const type = allTypes[Math.floor(Math.random() * allTypes.length)];
  const pool = NEAR_MISSES[type];
  const miss = pool[Math.floor(Math.random() * pool.length)];
  return {
    setup:   miss.setup ? miss.setup(playerName) : null,
    build:   miss.build(playerName),
    resolve: miss.resolve(playerName),
    emoji:   miss.emoji,
    type,
  };
}

// Pre-event teasers — shown 1-2 mins before a real dramatic event to build anticipation
// Each has a setup line (atmosphere) and a trigger line (the action, ending "…")
const PRE_EVENT_TEASERS = {
  red: [
    { setup: (n) => `<strong>${n}</strong> has been walking a tightrope all afternoon…`,      trigger: (n) => `<strong>${n}</strong> goes in late — this time the referee's not letting it go…` },
    { setup: (n) => `<strong>${n}</strong> already booked, and he's still flying into challenges…`, trigger: (n) => `Another reckless foul from <strong>${n}</strong>, referee reaching for his pocket…` },
    { setup: (n) => `The crowd on <strong>${n}</strong>'s back every time he touches it…`,     trigger: (n) => `<strong>${n}</strong> snaps — challenge from behind, referee blowing immediately…` },
  ],
  yellow: [
    { setup: (n) => `<strong>${n}</strong> has been giving the referee problems all game…`,    trigger: (n) => `<strong>${n}</strong> pulls back his man cynically, referee's had enough…` },
    { setup: (n) => `Frustration building in <strong>${n}</strong>'s game…`,                   trigger: (n) => `<strong>${n}</strong> clatters into the challenge — no attempt to play the ball…` },
  ],
  goal: [
    { setup: (n) => `<strong>${n}</strong> has looked sharp today — something is brewing here…`, trigger: (n) => `<strong>${n}</strong> picks it up in space, carries it forward, beats his man…` },
    { setup: (n) => `The ball keeps finding <strong>${n}</strong> in dangerous positions…`,     trigger: (n) => `<strong>${n}</strong> through on goal — the defender's lost him completely…` },
    { setup: (n) => `<strong>${n}</strong> dropping deep, getting involved, building something…`, trigger: (n) => `<strong>${n}</strong> plays it one-two and bursts into the box…` },
  ],
  own_goal: [
    { setup: (n) => `<strong>${n}</strong> has been nervy today, miscontrolling, misdirecting…`, trigger: (n) => `Cross comes in — <strong>${n}</strong> has to deal with this under pressure…` },
    { setup: (n) => `The back line looks shaky. <strong>${n}</strong> hasn't been convincing…`, trigger: (n) => `<strong>${n}</strong> attempting to clear — awkward bounce, going wrong way…` },
  ],
};

function getPreTeaser(eventType, playerName) {
  const pool = PRE_EVENT_TEASERS[eventType];
  if (!pool) return null;
  const entry = pool[Math.floor(Math.random() * pool.length)];
  return {
    setup:   entry.setup(playerName),
    trigger: entry.trigger(playerName),
  };
}

function getComment(type, name) {
  const lines = COMMENTARY[type] || COMMENTARY.neutral;
  return lines[Math.floor(Math.random() * lines.length)](name);
}

// Scoring per event type for a player in a given team (mine vs opp)
function getEventDelta(event, player) {
  if (!player) return 0;
  const priorGoals   = EVENTS.filter(e => e.type === 'goal'   && e.playerId === player.id && e.min < event.min).length;
  const priorAssists = EVENTS.filter(e => e.type === 'assist' && e.playerId === player.id && e.min < event.min).length;
  switch (event.type) {
    case 'goal':   return getScoreForEvent('goal',   player, { nthEvent: priorGoals + 1 });
    case 'assist': return getScoreForEvent('assist', player, { nthEvent: priorAssists + 1 });
    case 'sub':    return getScoreForEvent('sub',    player, { min: event.min });
    default:       return getScoreForEvent(event.type, player);
  }
}

let simTimeout = null;
let simBeats = null; // store beats reference for autocomplete

function autoCompleteMatch() {
  if (simTimeout) { clearTimeout(simTimeout); simTimeout = null; }
  if (state.predictionTimerTimeout) { clearTimeout(state.predictionTimerTimeout); state.predictionTimerTimeout = null; }
  closePrediction();
  state._predOnComplete = null;
  const feed = document.getElementById('commentary-feed');
  if (feed) { feed.classList.remove('feed-building', 'feed-halftime'); }

  // Process all remaining events instantly
  const allEvents = EVENTS.filter(e => e.type !== 'full_90');
  for (const e of allEvents) {
    processSimEvent(e);
  }

  // Update live score display to final counts
  const homeGoals = EVENTS.filter(e => e.type === 'goal' && PLAYERS.find(p => p.id === e.playerId && p.team === 'home')).length;
  const awayGoals = EVENTS.filter(e => e.type === 'goal' && PLAYERS.find(p => p.id === e.playerId && p.team === 'away')).length;
  const h = document.getElementById('live-home-score');
  const a = document.getElementById('live-away-score');
  if (h) h.textContent = homeGoals;
  if (a) a.textContent = awayGoals;

  document.getElementById('match-clock').textContent = "90'";
  setCommentary('<strong>Full time.</strong> Skipped to the result.', '🏁');

  applyFull90();
  updateScoreDisplay();
  renderSimPlayers();

  setTimeout(() => showResults(), 800);
}

// ═══════════════════════════════════════════════════════════════
// CAPTAIN SELECTION
// ═══════════════════════════════════════════════════════════════

function showCaptainScreen() {
  showScreen('captain');
  state.myCaptain = null;

  // AI picks its captain — highest chaos value from its team, excluding GK
  // Use deterministic base estimates (no noise) so the AI captain is consistent
  const oppCandidates = state.oppTeam
    .map(id => {
      const p = getPlayer(id);
      if (!p || p.pos === 'GK') return null;
      // Recompute base estimate without noise for determinism
      const POSITION_PRIOR = { GK:5,CB:8,RB:6,LB:6,DM:7,CM:5,AM:3,RW:2,LW:2,ST:1 };
      const homeGoals = EVENTS.filter(e => e.type==='goal' && PLAYERS.find(q=>q.id===e.playerId&&q.team==='home')).length;
      const awayGoals = EVENTS.filter(e => e.type==='goal' && PLAYERS.find(q=>q.id===e.playerId&&q.team==='away')).length;
      const goalsAgainst = { home: awayGoals, away: homeGoals };
      const prior = POSITION_PRIOR[p.pos] || 5;
      const isBackline = ['CB','RB','LB'].includes(p.pos);
      const leakyBonus = isBackline ? (goalsAgainst[p.team] || 0) * 2.5 : 0;
      const isAttacker = ['ST','RW','LW','AM'].includes(p.pos);
      const goalsScoredByTeam = p.team === 'home' ? homeGoals : awayGoals;
      const attackerPenalty = isAttacker ? goalsScoredByTeam * 1.5 : 0;
      return { id, v: prior + leakyBonus - attackerPenalty };
    })
    .filter(Boolean);
  oppCandidates.sort((a, b) => b.v - a.v);
  state.oppCaptain = oppCandidates[0]?.id;

  // Render my outfield players as tappable tiles (no GKs)
  const grid = document.getElementById('captain-grid');
  grid.innerHTML = '';

  const posOrder = { CB:0, RB:0, LB:0, DM:1, CM:1, AM:2, RW:3, LW:3, ST:4 };
  const sorted = [...state.myTeam]
    .map(id => getPlayer(id))
    .filter(p => p && p.pos !== 'GK')
    .sort((a, b) => (posOrder[a.pos] || 0) - (posOrder[b.pos] || 0));

  for (const p of sorted) {
    const tile = document.createElement('div');
    tile.className = 'captain-tile';
    tile.dataset.id = p.id;

    const teamColour = p.team === 'home'
      ? (ALL_MATCHES[state.matchIdx]?.meta.homeColour || '#6CABDD')
      : (ALL_MATCHES[state.matchIdx]?.meta.awayColour || '#FBEE23');

    tile.innerHTML = `
      <div class="captain-tile-pos">${p.pos}</div>
      <div class="captain-tile-name">${p.name.split(' ').pop()}</div>
      <div class="captain-tile-team"><span class="captain-tile-dot" style="background:${teamColour}"></span>${p.teamName}</div>
    `;
    tile.addEventListener('click', () => selectCaptain(p.id));
    grid.appendChild(tile);
  }

  // Random captain tile (12th)
  const randomTile = document.createElement('div');
  randomTile.className = 'captain-tile random-tile';
  randomTile.dataset.id = 'random';
  randomTile.innerHTML = `<div class="captain-tile-name">🎲 Random</div>`;
  randomTile.addEventListener('click', () => {
    const outfield = state.myTeam.filter(id => { const p = getPlayer(id); return p && p.pos !== 'GK'; });
    const randomId = outfield[Math.floor(Math.random() * outfield.length)];
    selectCaptain(randomId, true);
  });
  grid.appendChild(randomTile);

  document.getElementById('captain-confirm-btn').disabled = true;
  document.getElementById('captain-hint').textContent = 'Tap a player to nominate';
  document.getElementById('captain-hint').className = 'captain-hint';

  // Start 10s captain timer — auto-random on expiry
  startCaptainTimer();
}

let captainTimerInterval = null;

function startCaptainTimer() {
  if (captainTimerInterval) clearInterval(captainTimerInterval);
  let secs = 10;

  const hint = document.getElementById('captain-hint');
  const btn  = document.getElementById('captain-confirm-btn');

  // Show countdown in hint
  function updateHint() {
    if (!state.myCaptain) {
      hint.textContent = `Tap a player to nominate — ${secs}s`;
    }
  }
  updateHint();

  captainTimerInterval = setInterval(() => {
    secs--;
    updateHint();
    if (secs <= 0) {
      clearInterval(captainTimerInterval);
      if (!state.myCaptain) {
        // Auto-assign random outfield player
        const outfield = state.myTeam.filter(id => { const p = getPlayer(id); return p && p.pos !== 'GK'; });
        const randomId = outfield[Math.floor(Math.random() * outfield.length)];
        selectCaptain(randomId, true);
        // Auto-confirm after brief pause
        setTimeout(() => confirmCaptain(), 800);
      }
    }
  }, 1000);
}

function selectCaptain(id, fromRandom = false) {
  state.myCaptain = id;

  // Update tile states — highlight the actual player tile, and random tile if it was used
  document.querySelectorAll('.captain-tile').forEach(t => {
    const tileId = t.dataset.id === 'random' ? 'random' : parseInt(t.dataset.id);
    if (fromRandom) {
      t.classList.toggle('selected', t.dataset.id === 'random');
    } else {
      t.classList.toggle('selected', parseInt(t.dataset.id) === id);
    }
  });

  const p = getPlayer(id);
  const hint = document.getElementById('captain-hint');
  const name = p ? p.name.split(' ').pop() : '?';
  hint.textContent = fromRandom
    ? `🎲 ${name} drawn at random — fate decides`
    : `${name} will wear the armband`;
  hint.className = 'captain-hint chosen';

  document.getElementById('captain-confirm-btn').disabled = false;
}

function confirmCaptain() {
  if (!state.myCaptain) return;
  if (captainTimerInterval) clearInterval(captainTimerInterval);

  if (state.mp) {
    // In mp mode: write captain to Firebase, signal ready to sim
    mpSetCaptain(state.myCaptain);
    showToast('Captain locked in — waiting for opponent…');
    // Disable button to prevent double-tap
    const btn = document.getElementById('captain-confirm-btn');
    if (btn) { btn.disabled = true; btn.textContent = 'Waiting…'; }
    mpReadyToSim();
    mpWaitForSimStart(() => startSimulation());
  } else {
    startSimulation();
  }
}

function isCaptain(playerId) {
  return playerId === state.myCaptain || playerId === state.oppCaptain;
}

function captainMultiplier(playerId) {
  return isCaptain(playerId) ? 2 : 1;
}

function startSimulation() {
  initPlayerData();
  state.myScore = 0;
  state.oppScore = 0;
  state.liveHomeScore = 0;
  state.liveAwayScore = 0;
  state.pendingFlashes = [];
  showScreen('sim');

  // Re-apply live scoreline team names (HTML default is hardcoded, needs refresh)
  const m = ALL_MATCHES[state.matchIdx];
  if (m) {
    const liveTeams = document.querySelector('.live-teams');
    if (liveTeams) liveTeams.innerHTML = `${m.meta.home} <strong id="live-home-score">0</strong> – <strong id="live-away-score">0</strong> ${m.meta.away}`;
    const commEl = document.getElementById('commentary');
    if (commEl) commEl.textContent = `${m.meta.home} vs ${m.meta.away} kicks off…`;
  }

  // Apply team name to scoreboard label and tab
  // Scoreboard: just the raw name without emoji (it's tiny, emoji breaks mono spacing)
  // Tab: emoji only to keep tabs balanced
  const teamName  = state.teamName  || 'You';
  const teamEmoji = state.teamEmoji || '';
  const shortName = teamName.replace(/^\S+\s/, ''); // strip leading emoji token
  const myLabel = document.getElementById('sim-my-label');
  if (myLabel) myLabel.textContent = shortName || teamName;
  const myTab = document.getElementById('sim-tab-me');
  if (myTab) myTab.textContent = (teamEmoji ? teamEmoji + ' ' : '') + 'Your XI';

  updateScoreDisplay();
  renderSimPlayers();
  setSimView('me');

  const beats = buildBeats();
  runBeats(beats, 0);
}

// ═══════════════════════════════════════════════════════════════
// PREDICTION MOMENTS
// ═══════════════════════════════════════════════════════════════

const PREDICTION_QUESTIONS = {
  goal:     (n) => `${n} is in space — does he score?`,
  own_goal: (n) => `${n} is under pressure — does he put it in his own net?`,
  red:      (n) => `${n} is on the edge — does he get sent off?`,
  yellow:   (n) => `${n} is pushing his luck — does he get booked?`,
  shot:     (n) => `${n} pulls the trigger — does it go in?`,
  card:     (n) => `${n} goes in late — does he see a card?`,
};

function getPredictionQuestion(eventType, playerName) {
  const fn = PREDICTION_QUESTIONS[eventType] || PREDICTION_QUESTIONS.shot;
  return fn(playerName);
}

// Called from runBeats when a prediction beat fires
function showPrediction(beat, onComplete) {
  const overlay  = document.getElementById('prediction-overlay');
  const qEl      = document.getElementById('prediction-question');
  const fillEl   = document.getElementById('prediction-timer-fill');
  const yesBtn   = document.querySelector('.pred-yes');
  const noBtn    = document.querySelector('.pred-no');

  if (!overlay) { onComplete(null); return; }

  state.predictionAnswer  = null;
  state.predictionPending = beat;

  qEl.textContent = beat.predQuestion;

  // Reset buttons
  yesBtn.disabled = false;
  noBtn.disabled  = false;
  yesBtn.classList.remove('selected');
  noBtn.classList.remove('selected');

  overlay.style.display = '';

  // Timer bar: full → empty over 3s
  fillEl.style.transition = 'none';
  fillEl.style.width = '100%';
  requestAnimationFrame(() => requestAnimationFrame(() => {
    fillEl.style.transition = 'width 3s linear';
    fillEl.style.width = '0%';
  }));

  // Auto-resolve after 3s if no answer
  state.predictionTimerTimeout = setTimeout(() => {
    closePrediction();
    onComplete(null); // no answer — 0 pts
  }, 3000);

  // Store callback for button taps
  state._predOnComplete = onComplete;
}

function submitPrediction(answer) {
  if (state.predictionTimerTimeout) {
    clearTimeout(state.predictionTimerTimeout);
    state.predictionTimerTimeout = null;
  }
  const yesBtn = document.querySelector('.pred-yes');
  const noBtn  = document.querySelector('.pred-no');
  if (yesBtn) { yesBtn.disabled = true; (answer ? yesBtn : noBtn).classList.add('selected'); }
  if (noBtn)  { noBtn.disabled  = true; }

  closePrediction();
  if (state._predOnComplete) {
    state._predOnComplete(answer);
    state._predOnComplete = null;
  }
}

function closePrediction() {
  const overlay = document.getElementById('prediction-overlay');
  const feed    = document.getElementById('commentary-feed');
  const sub     = document.getElementById('commentary-sub');
  if (overlay) overlay.style.display = 'none';
  if (feed)    feed.classList.remove('feed-building');
  if (sub)     { sub.innerHTML = ''; sub.style.display = 'none'; }
}

function applyPredictionResult(playerAnswer, isReal) {
  if (playerAnswer === null) {
    setCommentary('No answer — play continues.', '⏩');
    return;
  }
  const correct = (playerAnswer === isReal);
  if (correct) {
    state.myScore += 10;
    updateScoreDisplay();
    // Show result clearly in the commentary feed + toast
    setCommentary('<strong>✅ Correct!</strong> +10 pts added to your score.', '🎯');
    showToast('+10 CORRECT!');
    flashPredResult('+10 CORRECT!', 'correct');
  } else {
    state.myScore -= 5;
    updateScoreDisplay();
    setCommentary('<strong>❌ Wrong!</strong> −5 pts deducted from your score.', '💸');
    showToast('−5 WRONG');
    flashPredResult('−5 WRONG', 'wrong');
  }
}

function flashPredResult(text, cls) {
  const el = document.getElementById('pred-result-flash');
  if (!el) return;
  el.textContent = text;
  // Reset first to re-trigger animation
  el.className = 'pred-result-flash';
  el.style.opacity = '0';
  el.style.transform = 'translate(-50%, -50%) scale(0.8)';
  void el.offsetWidth;
  requestAnimationFrame(() => {
    el.className = `pred-result-flash ${cls} show`;
    el.style.opacity = '';
    el.style.transform = '';
    setTimeout(() => {
      el.classList.remove('show');
    }, 2000);
  });
}

// ═══════════════════════════════════════════════════════════════
// BEAT BUILDER
// ═══════════════════════════════════════════════════════════════
function buildBeats() {
  const beats = [];
  const m = ALL_MATCHES[state.matchIdx]; // declare once at top

  beats.push({ realTime: 2000,  matchMin: 0,  events: [], commentary: getComment('neutral'), emoji: '🏟️' });
  beats.push({ realTime: 6000,  matchMin: 10, events: [], commentary: getComment('neutral'), emoji: '🏟️' });

  const eventsToShow = EVENTS.filter(e => e.type !== 'full_90' && e.type !== 'assist');

  for (const e of eventsToShow) {
    const realTime = mapMatchMinToReal(e.min);
    let beat = beats.find(b => !b.fake && Math.abs(b.realTime - realTime) < 2000);
    if (!beat) {
      beat = { realTime, matchMin: e.min, events: [], commentary: '', emoji: '🏟️' };
      beats.push(beat);
    } else {
      beat.matchMin = Math.max(beat.matchMin, e.min);
    }
    beat.events.push(e);
    const p = getPlayer(e.playerId);
    if (!beat.commentary || e.type === 'goal' || e.type === 'own_goal') {
      const isHatTrick = e.type === 'goal' &&
        EVENTS.filter(ev => ev.type === 'goal' && ev.playerId === e.playerId && ev.min < e.min).length === 2;
      beat.commentary = isHatTrick
        ? getComment('hat_trick', p ? p.name : '')
        : getComment(e.type, p ? p.name : '');
      beat.emoji = isHatTrick ? EVENT_EMOJI.hat_trick : (EVENT_EMOJI[e.type] || '🏟️');
    }
  }

  // ── Inject near-miss fake beats into gaps ───────────────────────
  // Get all drafted player names for realistic fake commentary
  const draftedIds = [...new Set([...state.myTeam, ...state.oppTeam])];
  const draftedPlayers = draftedIds.map(id => getPlayer(id)).filter(Boolean);
  const outfield = draftedPlayers.filter(p => p.pos !== 'GK');
  const candidatePool = outfield.length > 0 ? outfield : draftedPlayers;

  // Work out if this match is VAR-era (PL VAR started 2019/20 season)
  const matchYear = m ? parseInt(m.meta.date.split(' ').pop()) : 2000;
  const allowVar  = matchYear >= 2019;

  // Sort real beats so we can find gaps and upcoming events
  beats.sort((a, b) => a.realTime - b.realTime);

  if (candidatePool.length > 0) {
    const usedMinutes = new Set();
    const fakesToInsert = [];

    // ── 1. Pre-event teasers: for each dramatic real event, plant a
    //       teaser beat ~2 min before using THAT player's name
    const dramaticTypes = ['red', 'yellow', 'goal', 'own_goal'];
    for (const e of eventsToShow) {
      if (!dramaticTypes.includes(e.type)) continue;
      const p = getPlayer(e.playerId);
      if (!p) continue;
      const teaser = getPreTeaser(e.type, p.name.split(' ').pop());
      if (!teaser) continue;

      const teaserMin     = Math.max(1, e.min - 2);
      const teaserRealTime = mapMatchMinToReal(teaserMin);

      // Don't crowd another beat
      const tooClose = beats.some(b => Math.abs(b.realTime - teaserRealTime) < 2500);
      if (tooClose || usedMinutes.has(teaserMin)) continue;
      usedMinutes.add(teaserMin);

      fakesToInsert.push({
        realTime:          teaserRealTime,
        matchMin:          teaserMin,
        events:            [],
        fake:              true,
        isTeaser:          true,
        setup:             teaser.setup,
        build:             teaser.trigger,
        resolve:           teaser.trigger,
        commentary:        teaser.setup,
        emoji:             '👀',
        linkedEventType:   e.type,
        linkedPlayerName:  p.name.split(' ').pop(),
      });
    }

    // ── 2. Near-miss fakes in gaps: 1 per medium gap, 2 per long gap
    const realBeats = beats.filter(b => !b.fake);
    for (let i = 0; i < realBeats.length - 1; i++) {
      const gap = realBeats[i+1].realTime - realBeats[i].realTime;
      if (gap < 4500) continue;

      const howMany = gap > 14000 ? 2 : 1;

      for (let k = 0; k < howMany; k++) {
        // Spread across the gap: 30% and 65%
        const ratio = howMany === 1 ? 0.4 : (k === 0 ? 0.28 : 0.65);
        const fakeRealTime = realBeats[i].realTime + Math.round(gap * ratio);
        const fakeMin = Math.round(
          realBeats[i].matchMin +
          (realBeats[i+1].matchMin - realBeats[i].matchMin) * ratio
        );

        const tooClose = [...beats, ...fakesToInsert].some(b => Math.abs(b.realTime - fakeRealTime) < 2200);
        if (tooClose || usedMinutes.has(fakeMin)) continue;
        usedMinutes.add(fakeMin);

        const player = candidatePool[Math.floor(Math.random() * candidatePool.length)];
        const miss   = pickNearMiss(player.name.split(' ').pop(), allowVar);

        fakesToInsert.push({
          realTime:    fakeRealTime,
          matchMin:    fakeMin,
          events:      [],
          fake:        true,
          isTeaser:    false,
          setup:       miss.setup,
          build:       miss.build,
          resolve:     miss.resolve,
          commentary:  miss.build,
          emoji:       '…',
          linkedPlayerName: player.name.split(' ').pop(),
          linkedEventType:  miss.type,
        });
      }
    }

    beats.push(...fakesToInsert);

    // ── 3. Guarantee ≥1 prediction per half, max 3 total ─────────
    // ONLY use teasers (tied to real events) — never near-miss fakes.
    // A knowledgeable player who says "yes Collymore scores" is right;
    // penalising them for a fake miss event is unfair.
    const shuffle = arr => [...arr].sort(() => Math.random() - 0.5);

    const teaserOnly    = fakesToInsert.filter(b => b.isTeaser);
    const firstHalf     = teaserOnly.filter(b => b.matchMin < 45);
    const secondHalf    = teaserOnly.filter(b => b.matchMin >= 45);

    const pick1st = shuffle(firstHalf)[0];
    const pick2nd = shuffle(secondHalf)[0];
    const chosen  = [pick1st, pick2nd].filter(Boolean);

    if (chosen.length < 3) {
      const remaining = teaserOnly.filter(b => !chosen.includes(b));
      const extra = shuffle(remaining)[0];
      if (extra) chosen.push(extra);
    }

    for (const pb of chosen) {
      pb.isPrediction = true;
      pb.predIsReal   = true; // all from teasers — real event always follows
      const type = pb.linkedEventType || 'goal';
      const name = pb.linkedPlayerName || '';
      pb.predQuestion = getPredictionQuestion(type, name);
    }
  }

  // ── Half-time beat ──────────────────────────────────────────────
  const htRealTime = mapMatchMinToReal(45);
  const tooCloseToHT = beats.some(b => !b.isHalfTime && Math.abs(b.realTime - htRealTime) < 1500);
  if (!tooCloseToHT) {
    beats.push({
      realTime:   htRealTime,
      matchMin:   45,
      events:     [],
      isHalfTime: true,
      fake:       true,
      commentary: `<strong>Half time.</strong> Referee blows for the break.`,
      emoji:      '🟡',
    });
  }

  beats.push({ realTime: 40000, matchMin: 88, events: [], commentary: m ? m.meta.lateCommentary : "Late pressure. Time running out.", emoji: '⏱️' });
  beats.push({ realTime: 43500, matchMin: 90, events: [], commentary: m ? m.meta.finalCommentary : "<strong>Full time.</strong>", emoji: '🏁' });

  beats.sort((a, b) => a.realTime - b.realTime);
  return beats;
}

function mapMatchMinToReal(min) {
  return Math.round((min / 90) * 43500);
}

function runBeats(beats, idx) {
  if (idx >= beats.length) {
    applyFull90();
    setTimeout(() => showResults(), 2000);
    return;
  }

  // Apply tip penalty on the very first beat
  if (idx === 0 && state.tipTaken) {
    applyTipPenalty();
  }

  const beat = beats[idx];
  const delay = idx === 0 ? 500 : (beat.realTime - beats[idx-1].realTime);

  simTimeout = setTimeout(() => {
    document.getElementById('match-clock').textContent = beat.matchMin + "'";

    if (beat.fake) {
      if (beat.isHalfTime) {
        const htOverlay = document.getElementById('ht-overlay');
        const htScore   = document.getElementById('ht-score');
        const feed      = document.getElementById('commentary-feed');

        // Show current scores at half time
        if (htScore) {
          const my  = Math.round(state.myScore);
          const opp = Math.round(state.oppScore);
          const name = state.teamName || 'You';
          htScore.textContent = `${name}  ${my > 0 ? '+' : ''}${my}  ·  Opp  ${opp > 0 ? '+' : ''}${opp}`;
        }

        if (htOverlay) htOverlay.style.display = '';
        if (feed) feed.classList.add('feed-halftime');
        setCommentary('<strong>Half time.</strong> Referee blows for the break.', '🟡');

        simTimeout = setTimeout(() => {
          if (htOverlay) htOverlay.style.display = 'none';
          if (feed) { feed.classList.remove('feed-halftime'); }
          const sub = document.getElementById('commentary-sub');
          if (sub) sub.style.display = 'none';
          setCommentary('Second half underway.', '🏟️');
          simTimeout = setTimeout(() => runBeats(beats, idx + 1), 800);
        }, 3500);
        return;
      }

      if (beat.isPrediction) {
        const feed = document.getElementById('commentary-feed');
        // Step 1: expand feed, show atmosphere/setup line as sub-context
        if (feed) feed.classList.add('feed-building');
        setCommentary(beat.setup || beat.build, '👁️');
        simTimeout = setTimeout(() => {
          // Step 2: show the action trigger line as main, setup becomes sub context
          setCommentary(beat.build, '…', beat.setup || null);
          simTimeout = setTimeout(() => {
            // Step 3: slide up prediction panel — question is clean and plain
            showPrediction(beat, (playerAnswer) => {
              if (feed) feed.classList.remove('feed-building');
              setCommentary(
                beat.predIsReal ? `Watch this space…` : beat.resolve,
                beat.predIsReal ? '👀' : beat.emoji
              );
              applyPredictionResult(playerAnswer, beat.predIsReal);
              simTimeout = setTimeout(() => runBeats(beats, idx + 1), 2800);
            });
          }, 1600); // trigger line visible before prediction pops
        }, 2000);  // setup line visible before trigger appears
        return;
      }

      if (beat.isTeaser) {
        setCommentary(beat.commentary || beat.build, '👀');
        simTimeout = setTimeout(() => runBeats(beats, idx + 1), 2000);
        return;
      }

      // Standard near-miss: show build, pause, resolve
      setCommentary(beat.build, '…');
      simTimeout = setTimeout(() => {
        setCommentary(beat.resolve, beat.emoji);
        simTimeout = setTimeout(() => runBeats(beats, idx + 1), 1800);
      }, 2800);
      return;
    }

    state.pendingFlashes = [];
    for (const e of beat.events) {
      processSimEvent(e);
      if (e.type === 'goal') {
        const scorer = getPlayer(e.playerId);
        if (scorer && scorer.team === 'home') {
          state.liveHomeScore = (state.liveHomeScore || 0) + 1;
          const h = document.getElementById('live-home-score');
          if (h) h.textContent = state.liveHomeScore;
        } else if (scorer && scorer.team === 'away') {
          state.liveAwayScore = (state.liveAwayScore || 0) + 1;
          const a = document.getElementById('live-away-score');
          if (a) a.textContent = state.liveAwayScore;
        }
      }
    }

    if (beat.commentary) {
      setCommentary(beat.commentary, beat.emoji);
    }

    updateScoreDisplay();
    renderSimPlayers();

    const flashes = state.pendingFlashes || [];
    flashes.forEach(({ id, delta }) => flashPlayer(id, delta));
    state.pendingFlashes = [];

    runBeats(beats, idx + 1);
  }, delay);
}

function processSimEvent(event) {
  const player = getPlayer(event.playerId);
  if (!player) return;

  const baseD = getEventDelta(event, player);
  const mult  = captainMultiplier(player.id);
  const delta = baseD * mult;
  const inMyTeam  = state.myTeam.includes(player.id);
  const inOppTeam = state.oppTeam.includes(player.id);

  if (inMyTeam) {
    state.myScore += delta;
    if (state.playerData[player.id]) {
      state.playerData[player.id].pts += delta;
      state.playerData[player.id].events.push(event.type);
      if (event.type === 'sub') state.playerData[player.id].subbed = true;
    }
  }
  if (inOppTeam) {
    state.oppScore += delta;
    if (state.playerData[player.id]) {
      state.playerData[player.id].pts += delta;
      state.playerData[player.id].events.push(event.type);
      if (event.type === 'sub') state.playerData[player.id].subbed = true;
    }
  }

  // Goals conceded: defenders & GK of the conceding team get bonus pts per goal
  if (event.type === 'goal') {
    const scoringTeam = player.team;
    const concedingTeam = scoringTeam === 'home' ? 'away' : 'home';
    const defenders = PLAYERS.filter(p =>
      p.team === concedingTeam && ['GK','CB','RB','LB'].includes(p.pos)
    );
    for (const dp of defenders) {
      const concedeDelta = getScoreForEvent('concede', dp) * captainMultiplier(dp.id);
      if (concedeDelta === 0) continue;
      const dpInMine = state.myTeam.includes(dp.id);
      const dpInOpp  = state.oppTeam.includes(dp.id);
      if (!dpInMine && !dpInOpp) continue;
      if (dpInMine && state.playerData[dp.id]) {
        state.myScore += concedeDelta;
        state.playerData[dp.id].pts += concedeDelta;
      }
      if (dpInOpp && state.playerData[dp.id]) {
        state.oppScore += concedeDelta;
        state.playerData[dp.id].pts += concedeDelta;
      }
    }
  }

  if (delta !== 0) state.pendingFlashes = (state.pendingFlashes || []).concat({ id: player.id, delta });
}

function applyFull90() {
  const allDrafted = [...new Set([...state.myTeam, ...state.oppTeam])];
  for (const id of allDrafted) {
    const player = getPlayer(id);
    const pd = state.playerData[id];
    if (!pd.subbed) {
      const delta = getScoreForEvent('full_90', player) * captainMultiplier(id);
      if (state.myTeam.includes(id)) state.myScore += delta;
      if (state.oppTeam.includes(id)) state.oppScore += delta;
      pd.pts += delta;
    }
  }
  updateScoreDisplay();
  renderSimPlayers();
}

function chaosLabel(pts, isWinning, isTied) {
  if (isTied)      return { text: 'LEVEL',      cls: 'level' };
  if (!isWinning)  return { text: 'BEHIND',      cls: 'losing' };
  const gap = Math.abs(pts - (isWinning ? state.oppScore : state.myScore));
  if (gap < 5)     return { text: 'EDGING IT',   cls: 'winning' };
  if (gap < 12)    return { text: 'AHEAD',        cls: 'winning' };
  if (gap < 22)    return { text: 'PULLING AWAY', cls: 'winning' };
  return             { text: 'RUNNING RIOT',  cls: 'winning' };
}

function updateScoreDisplay() {
  const my  = state.myScore;
  const opp = state.oppScore;
  const tied = my === opp;
  const meWin = my > opp;
  const gap = Math.abs(my - opp);

  const myEl    = document.getElementById('sim-my-status');
  const oppPts  = document.getElementById('sim-opp-pts');
  const gapLine = document.getElementById('sim-gap-line');

  if (myEl) {
    if (tied) {
      myEl.textContent = 'LEVEL';
      myEl.className = 'sim-score-status level';
    } else if (meWin) {
      // Pick tier label for winning
      let label = 'AHEAD';
      if (gap < 5)  label = 'EDGING IT';
      else if (gap < 12) label = 'AHEAD';
      else if (gap < 22) label = 'PULLING AWAY';
      else label = 'RUNNING RIOT';
      myEl.textContent = label;
      myEl.className = 'sim-score-status winning';
    } else {
      myEl.textContent = 'BEHIND';
      myEl.className = 'sim-score-status losing';
    }
  }

  // Opponent just shows their raw pts — small, understated
  if (oppPts) {
    oppPts.textContent = opp >= 0 ? `+${opp} pts` : `${opp} pts`;
  }

  // Middle: single contextual line about the gap
  if (gapLine) {
    if (tied) {
      gapLine.textContent = 'All square';
    } else if (meWin) {
      gapLine.textContent = `ahead by ${gap} pt${gap === 1 ? '' : 's'}`;
    } else {
      gapLine.textContent = `behind by ${gap} pt${gap === 1 ? '' : 's'}`;
    }
  }

  // Bar: shift both scores to be positive for percentage calculation
  const min = Math.min(my, opp, 0);
  const myAdj  = my  - min;
  const oppAdj = opp - min;
  const total  = myAdj + oppAdj;
  const myPct  = total > 0 ? (myAdj / total) * 100 : 50;
  const bar = document.getElementById('score-bar-fill');
  if (bar) bar.style.width = myPct + '%';
}

function setSimView(view) {
  state.simView = view;
  document.getElementById('sim-tab-me').classList.toggle('active', view === 'me');
  document.getElementById('sim-tab-opp').classList.toggle('active', view === 'opp');
  renderSimPlayers();
}

function renderSimPlayers() {
  const list = document.getElementById('sim-players-list');
  const teamIds = state.simView === 'me' ? state.myTeam : state.oppTeam;

  // Sort by position: GK → DEF → MID → ATT
  const posOrder = { GK: 0, CB: 1, RB: 1, LB: 1, DM: 2, CM: 2, AM: 3, RW: 4, LW: 4, ST: 5 };
  const sorted = [...teamIds].sort((a, b) => {
    const pa = getPlayer(a), pb = getPlayer(b);
    return (posOrder[pa?.pos] ?? 9) - (posOrder[pb?.pos] ?? 9);
  });

  list.innerHTML = '';
  for (const id of sorted) {
    const p = getPlayer(id);
    if (!p) continue;
    const pd = state.playerData[id] || { pts: 0, events: [] };

    const row = document.createElement('div');
    const teamClass = p.team === 'home' ? 'team-home' : 'team-away';
    row.className = 'sim-player-row ' + teamClass + (pd.subbed ? ' subbed-off' : '');
    row.id = 'sim-row-' + id;

    const eventIcons = pd.events.map(e => ({
      goal: '⚽', assist: '🎯', yellow: '🟨', red: '🟥',
      own_goal: '😬', missed_pen: '❌', sub: '🔄'
    }[e] || '')).filter(Boolean);

    const ptsClass = pd.pts > 0 ? 'pts-positive' : pd.pts < 0 ? 'pts-negative' : 'pts-neutral';

    const captainBadge = isCaptain(id)
      ? `<span style="display:inline-flex;align-items:center;justify-content:center;background:#f5a623;color:white;font-family:'Bebas Neue',sans-serif;font-size:10px;letter-spacing:1px;width:18px;height:18px;border-radius:50%;margin-left:5px;vertical-align:middle;line-height:1;flex-shrink:0;">C</span>`
      : '';

    row.innerHTML = `
      <div class="sim-player-pos">${p.pos}</div>
      <div class="sim-player-name">${p.name}${captainBadge}${pd.subbed ? ' <span style="font-size:11px;color:#bbb">↓</span>' : ''}</div>
      <div class="sim-player-events">${eventIcons.slice(-3).map(i => `<span class="event-icon">${i}</span>`).join('')}</div>
      <div class="sim-player-pts ${ptsClass}">${pd.pts >= 0 ? '+' : ''}${pd.pts}</div>
    `;
    list.appendChild(row);
  }
}

const EVENT_EMOJI = {
  goal: '⚽', assist: '🎯', yellow: '🟨', red: '🟥',
  own_goal: '😬', missed_pen: '❌', sub: '🔄', hat_trick: '🎩',
  neutral: '🏟️', concede: '🥅', pen_save: '🧤',
};

function setCommentary(text, emoji, subText) {
  const el  = document.getElementById('commentary');
  const sub = document.getElementById('commentary-sub');
  const emo = document.getElementById('commentary-emoji');
  el.style.opacity  = '0';
  if (emo) emo.style.opacity = '0';
  setTimeout(() => {
    el.innerHTML = text;
    el.style.opacity = '1';
    if (sub) {
      if (subText) {
        sub.innerHTML = subText;
        sub.style.display = '';
      } else {
        sub.innerHTML = '';
        sub.style.display = 'none';
      }
    }
    if (emo) {
      emo.textContent  = emoji || '🏟️';
      emo.style.opacity = '1';
    }
  }, 200);
}

function flashPlayer(playerId, delta) {
  // Always flash the commentary bar so something always visible reacts
  const feed = document.querySelector('.commentary-feed');
  if (feed) {
    const feedCls = delta > 0 ? 'feed-flash-pos' : 'feed-flash-neg';
    feed.classList.remove('feed-flash-pos', 'feed-flash-neg'); // reset if already animating
    void feed.offsetWidth; // force reflow to restart animation
    feed.classList.add(feedCls);
    setTimeout(() => feed.classList.remove(feedCls), 1600);
  }

  // Also flash the player row if it happens to be in the current view
  const row = document.getElementById('sim-row-' + playerId);
  if (row) {
    const cls = delta > 0 ? 'flash-positive' : 'flash-negative';
    row.classList.add(cls);
    setTimeout(() => row.classList.remove(cls), 800);

    const popup = document.createElement('div');
    popup.className = 'delta-popup ' + (delta > 0 ? 'positive' : 'negative');
    popup.textContent = (delta > 0 ? '+' : '') + delta;
    row.appendChild(popup);
    setTimeout(() => popup.remove(), 1200);
  }
}

// ═══════════════════════════════════════════════════════════════
// RESULTS
// ═══════════════════════════════════════════════════════════════
function showResults() {
  // In mp mode: write our score to Firebase first, then wait for opponent's
  if (state.mp) {
    mpWriteScore(state.myScore);
    // Listen for opponent score to show final comparison
    window._fb.onValue(state.mp.sessionRef, (snap) => {
      const d = snap.val();
      if (!d) return;
      const myScore  = state.mp.role === 'A' ? d.scoreA : d.scoreB;
      const oppScore = state.mp.role === 'A' ? d.scoreB : d.scoreA;
      if (myScore !== null && oppScore !== null) {
        window._fb.off(state.mp.sessionRef);
        state.oppScore = oppScore;
        _renderResults();
      }
    });
    // Show loading state while waiting
    showScreen('results');
    document.getElementById('result-headline').textContent = 'CALCULATING…';
    document.getElementById('result-sub').textContent = 'Waiting for opponent score…';
    return;
  }

  _renderResults();
}

function _renderResults() {
  const myWon = state.myScore > state.oppScore;
  const tied  = state.myScore === state.oppScore;

  // ── Save result to active profile ────────────────────────────
  const m = ALL_MATCHES[state.matchIdx];
  if (m && _activeProfileId) {
    const captain = state.myCaptain ? PLAYERS.find(p => p.id === state.myCaptain) : null;
    recordMatchResult({
      matchId:      m.id,
      matchLabel:   `${m.meta.home} ${m.meta.score} ${m.meta.away}`,
      result:       myWon ? 'W' : tied ? 'D' : 'L',
      myScore:      state.myScore,
      oppScore:     state.oppScore,
      captainName:  captain ? captain.name.split(' ').pop() : null,
    });
    renderPostMatchFormTile();
  }

  // Headline
  const headlines = {
    win:  ['YOU BEAUTY', 'DRAFTED PERFECTLY', 'CHAOS MERCHANT'],
    lose: ['TOO SENSIBLE MATE', 'NICE GUYS FINISH LAST', 'BACK TO SCHOOL'],
    tie:  ['HONOURS EVEN', "A GENTLEMAN'S DRAW"],
  };
  const hl = myWon ? headlines.win : tied ? headlines.tie : headlines.lose;
  document.getElementById('result-headline').textContent = hl[Math.floor(Math.random() * hl.length)];

  // Single full-width result tile
  const gap = Math.abs(state.myScore - state.oppScore);

  function resultEmoji(won, isTied) {
    if (isTied) return '🤝';
    if (!won) {
      if (gap >= 21) return '💀';
      if (gap >= 18) return '😵';
      if (gap >= 15) return '😩';
      if (gap >= 12) return '😤';
      if (gap >= 9)  return '😬';
      if (gap >= 6)  return '😅';
      return '🤌';
    } else {
      if (gap >= 21) return '🐐';
      if (gap >= 18) return '👑';
      if (gap >= 15) return '🏆';
      if (gap >= 12) return '💪';
      if (gap >= 9)  return '🔥';
      if (gap >= 6)  return '😄';
      return '😏';
    }
  }

  function resultWord(won, isTied) {
    if (isTied) return 'ALL SQUARE';
    if (won) {
      if (gap <= 3)  return 'JUST ABOUT';
      if (gap <= 10) return 'WINNER';
      if (gap <= 15) return 'DOMINANT';
      return 'OBLITERATED';
    } else {
      if (gap <= 3)  return 'SO CLOSE';
      if (gap <= 10) return 'BEATEN';
      if (gap <= 15) return 'OUTCLASSED';
      return 'SCHOOLED';
    }
  }

  function resultDetail(won, isTied) {
    if (isTied) return 'All square on chaos points';
    if (won) return `You won by ${gap} chaos point${gap === 1 ? '' : 's'}`;
    return `You lost by ${gap} chaos point${gap === 1 ? '' : 's'}`;
  }

  const myCard = document.getElementById('my-score-card');
  if (myCard) {
    const stateClass = tied ? 'tied' : myWon ? 'winner' : 'loser';
    myCard.className = `result-score-card full ${stateClass}`;

    const myLabel = document.getElementById('my-score-label');
    if (myLabel) {
      myLabel.textContent = state.teamName || 'You';
    }
    document.getElementById('my-result-emoji').textContent   = resultEmoji(myWon, tied);
    document.getElementById('my-result-outcome').textContent = resultWord(myWon, tied);
    document.getElementById('my-score-detail').textContent   = resultDetail(myWon, tied);
  }

  // ── MATCH REPORT ──────────────────────────────────────────────
  const allDrafted = [...new Set([...state.myTeam, ...state.oppTeam])];
  const withPts = allDrafted.map(id => ({
    player: getPlayer(id),
    pts: state.playerData[id] ? state.playerData[id].pts : 0,
    events: state.playerData[id] ? state.playerData[id].events : [],
    mine: state.myTeam.includes(id)
  })).filter(item => item.player);

  withPts.sort((a, b) => b.pts - a.pts);

  const reportEl = document.getElementById('match-report');
  if (reportEl && m) {

    // ── Stats table ──────────────────────────────────────────────
    const countEvt = (team, type) =>
      EVENTS.filter(e => e.type === type && PLAYERS.find(p => p.id === e.playerId && p.team === team)).length;

    const homeGoals   = countEvt('home', 'goal');
    const awayGoals   = countEvt('away', 'goal');
    const homeYellows = countEvt('home', 'yellow');
    const awayYellows = countEvt('away', 'yellow');
    const homeReds    = countEvt('home', 'red');
    const awayReds    = countEvt('away', 'red');
    const homePens    = countEvt('home', 'missed_pen');
    const awayPens    = countEvt('away', 'missed_pen');
    const homeOGs     = countEvt('home', 'own_goal');
    const awayOGs     = countEvt('away', 'own_goal');

    function statRow(label, home, away) {
      const hStr = home > 0 ? `<span class="stat-val-active">${home}</span>` : `<span class="stat-val-zero">0</span>`;
      const aStr = away > 0 ? `<span class="stat-val-active">${away}</span>` : `<span class="stat-val-zero">0</span>`;
      return `<div class="stat-row"><div class="stat-home">${hStr}</div><div class="stat-label">${label}</div><div class="stat-away">${aStr}</div></div>`;
    }

    const statsHtml = `
      <div class="stats-table">
        <div class="stats-header">
          <div class="stats-team-name">${m.meta.home}</div>
          <div></div>
          <div class="stats-team-name">${m.meta.away}</div>
        </div>
        ${statRow('Goals', homeGoals, awayGoals)}
        ${statRow('Yellow cards', homeYellows, awayYellows)}
        ${statRow('Red cards', homeReds, awayReds)}
        ${statRow('Missed pens', homePens, awayPens)}
        ${statRow('Own goals', homeOGs, awayOGs)}
      </div>
    `;

    // ── Good, Bad & Ugly tiles ────────────────────────────────────
    // Sort by pts: highest = "ugly" (disaster = good for us), lowest = "good" (scored goals = bad), middle = "bad"
    const sorted = [...withPts].sort((a, b) => b.pts - a.pts);
    const ugly = sorted[0];                              // most pts — biggest disaster
    const good = sorted[sorted.length - 1];              // lowest pts — too good, unhelpful
    const midIdx = Math.floor(sorted.length / 2);
    const bad  = sorted[midIdx];                         // middling — neither use nor ornament

    function playerTeamLabel(item) {
      return `${item.player.name} · ${item.player.teamName}`;
    }
    function ownerLabel(item) {
      return item.mine ? `in <em>your</em> squad` : `in <em>your opponent's</em> squad`;
    }

    function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

    function uglyBlurb(item) {
      const evts = item.events;
      const n = item.player.name;
      const surname = n.split(' ').pop();
      const bits = [];
      if (evts.includes('red'))                                   bits.push(pick(['sent off','shown a straight red','given his marching orders']));
      if (evts.includes('own_goal'))                              bits.push(pick(['put one in his own net','turned it into his own goal','gifted them one']));
      if (evts.filter(e=>e==='yellow').length >= 2)               bits.push(pick(['booked twice','picked up a second yellow','got himself sent off via two bookings']));
      else if (evts.includes('yellow'))                           bits.push(pick(['booked','carded','picked up a yellow']));
      if (evts.includes('sub') && !evts.includes('red'))          bits.push(pick(['hauled off early','hooked before the hour','dragged off']));
      if (evts.includes('missed_pen'))                            bits.push(pick(['missed a pen','ballooned it over from the spot','sent the keeper the wrong way then hit the post']));

      const chaos = bits.length > 0 ? bits.join(', ') : pick(['had a complete nightmare','was an absolute liability all afternoon','contributed chaos at every turn']);
      const sign = pick([
        `what an absolute shambles 🤌`,
        `the gift that keeps on giving 🤌`,
        `utterly magnificent 🤌`,
        `a complete and utter disaster 🤌`,
      ]);
      const closer = pick([
        `Finishing on <strong>+${item.pts}</strong>, ${ownerLabel(item)}.`,
        `<strong>+${item.pts}</strong> chaos points, ${ownerLabel(item)}. Beautiful.`,
        `${ownerLabel(item).charAt(0).toUpperCase() + ownerLabel(item).slice(1)}. <strong>+${item.pts}</strong> on the board.`,
      ]);
      return `<strong>${n}</strong> ${chaos} — ${sign}. ${closer}`;
    }

    function goodBlurb(item) {
      const evts = item.events;
      const n = item.player.name;
      const goalCount   = evts.filter(e => e === 'goal').length;
      const assistCount = evts.filter(e => e === 'assist').length;
      const bits = [];
      if (goalCount >= 3)       bits.push(pick([`banging in a hat-trick 🥱`,`completing a hat-trick like it's nothing 🥱`,`helping himself to three goals 🥱`]));
      else if (goalCount === 2) bits.push(pick([`bagging a brace — typical 🥱`,`scoring twice, of all things 🥱`,`netting two — unhelpful 🥱`]));
      else if (goalCount === 1) bits.push(pick([`scoring a goal, obviously 🙄`,`chipping in with a goal — cheers for that 🙄`,`finding the net — not what we needed 🙄`]));
      if (assistCount >= 2)     bits.push(pick([`chipping in with ${assistCount} assists`,`laying on ${assistCount} goals`,`running the game from midfield`]));
      else if (assistCount === 1) bits.push(pick([`laying one on a plate`,`setting one up — unhelpful`,`adding an assist for good measure`]));
      const desc = bits.length > 0 ? bits.join(' and ') : pick([`kept themselves far too busy out there`,`decided to actually try`,`turned up and made an effort — rude`]);
      const closer = pick([
        `Only managed <strong>${item.pts}</strong> points, ${ownerLabel(item)}. Dead weight.`,
        `<strong>${item.pts}</strong> points, ${ownerLabel(item)}. An utter waste of a pick.`,
        `${ownerLabel(item).charAt(0).toUpperCase() + ownerLabel(item).slice(1)} with <strong>${item.pts}</strong> measly points. Useless.`,
      ]);
      return `<strong>${n}</strong> — ${desc}. ${closer}`;
    }

    function badBlurb(item) {
      const evts = item.events;
      const n = item.player.name;
      if (evts.length === 0) {
        return `<strong>${n}</strong> ` + pick([
          `wandered around like a lost tourist, contributing precisely nothing. <strong>${item.pts >= 0 ? '+' : ''}${item.pts}</strong> points, ${ownerLabel(item)}. Baffling.`,
          `was essentially invisible for 90 minutes. <strong>${item.pts >= 0 ? '+' : ''}${item.pts}</strong> points, ${ownerLabel(item)}. Remarkable.`,
          `somehow managed to do absolutely nothing of note. <strong>${item.pts >= 0 ? '+' : ''}${item.pts}</strong> points, ${ownerLabel(item)}. At least they tried.`,
          `ghosted through the match without leaving a trace. <strong>${item.pts >= 0 ? '+' : ''}${item.pts}</strong> points, ${ownerLabel(item)}. Fine. Whatever.`,
        ]);
      }
      const bits = [];
      if (evts.includes('yellow'))  bits.push(pick(['a booking','a yellow card','getting into the referee\'s notebook']));
      if (evts.includes('sub'))     bits.push(pick(['an early exit','being hauled off','getting the hook']));
      if (evts.includes('goal'))    bits.push(pick(['a goal — annoying','finding the net — not ideal','scoring, which helps nobody']));
      if (evts.includes('assist'))  bits.push(pick(['an assist — worse','setting one up, brilliantly unhelpfully','laying one on']));
      const desc = bits.length > 0 ? bits.join(', ') : pick(['a forgettable afternoon','a deeply average shift','a performance best forgotten']);
      const closer = pick([
        `Sitting on <strong>${item.pts >= 0 ? '+' : ''}${item.pts}</strong>, ${ownerLabel(item)}. Could've been worse. Could've been better.`,
        `<strong>${item.pts >= 0 ? '+' : ''}${item.pts}</strong> points, ${ownerLabel(item)}. Neither one thing nor the other.`,
        `${ownerLabel(item).charAt(0).toUpperCase() + ownerLabel(item).slice(1)}. <strong>${item.pts >= 0 ? '+' : ''}${item.pts}</strong> points. Make of that what you will.`,
      ]);
      return `<strong>${n}</strong> gave us ${desc}. ${closer}`;
    }

    const gbuHtml = `
      <div class="gbu-grid">
        <div class="gbu-tile gbu-good">
          <div class="gbu-label">😴 The Good</div>
          <div class="gbu-text">${goodBlurb(good)}</div>
        </div>
        <div class="gbu-tile gbu-bad">
          <div class="gbu-label">😬 The Bad</div>
          <div class="gbu-text">${badBlurb(bad)}</div>
        </div>
        <div class="gbu-tile gbu-ugly">
          <div class="gbu-label">🔥 The Ugly</div>
          <div class="gbu-text">${uglyBlurb(ugly)}</div>
        </div>
      </div>
    `;

    reportEl.innerHTML = statsHtml + gbuHtml;
  }

  // ── WORST ELEVEN LEADERBOARD ─────────────────────────────────
  // Top 11 players by pts across both teams
  withPts.sort((a, b) => b.pts - a.pts);
  const top11 = withPts.slice(0, 11);
  const contList = document.getElementById('contributors-list');
  if (contList) {
    contList.innerHTML = '';
    for (const item of top11) {
      const row = document.createElement('div');
      row.className = 'contributor-row';
      const ownerLabel = item.mine
        ? '<span style="color:var(--blue);font-size:10px;font-weight:700;">YOU</span>'
        : '<span style="color:var(--red);font-size:10px;font-weight:700;">OPP</span>';
      const ptsColor = item.pts > 0 ? 'var(--red)' : item.pts < 0 ? '#22c55e' : 'var(--muted)';
      row.innerHTML = `
        <div class="contributor-pos">${item.player.pos}</div>
        <div class="contributor-name">${item.player.name} <span class="contributor-team">${item.player.teamName}</span></div>
        <div style="margin-right:8px;">${ownerLabel}</div>
        <div class="contributor-pts" style="color:${ptsColor}">${item.pts >= 0 ? '+' : ''}${item.pts}</div>
      `;
      contList.appendChild(row);
    }
  }

  // ── BADGES ────────────────────────────────────────────────────
  const badges = [];
  const myOwnGoals = state.myTeam.filter(id => state.playerData[id] && state.playerData[id].events.includes('own_goal')).length;
  const myYellows  = state.myTeam.filter(id => state.playerData[id] && state.playerData[id].events.includes('yellow')).length;
  if (state.myScore >= 40) badges.push({ icon: '💥', name: 'Chaos Lord', desc: '40+ points' });
  if (myOwnGoals >= 1)     badges.push({ icon: '😬', name: 'Own Goal FC', desc: 'Own goal in squad' });
  if (myYellows  >= 2)     badges.push({ icon: '🟨', name: 'Card Magnet', desc: '2+ yellows' });
  if (myWon)               badges.push({ icon: '🏆', name: 'Worst Winner', desc: 'Outscored opponent' });
  if (badges.length === 0) badges.push({ icon: '😴', name: 'Too Sensible', desc: 'Pick worse next time' });

  const badgeList = document.getElementById('badges-list');
  if (badgeList) {
    badgeList.innerHTML = '';
    for (const b of badges) {
      const el = document.createElement('div');
      el.className = 'badge';
      el.innerHTML = `<span class="badge-icon">${b.icon}</span><span class="badge-name">${b.name}</span><span class="badge-desc">${b.desc}</span>`;
      badgeList.appendChild(el);
    }
  }

  showScreen('results');
}

function shareResult() {
  const won = state.myScore > state.oppScore;
  const text = `⚽ WORST ELEVEN — MCI 8-0 WAT\n${won ? '🏆 I won!' : '😅 I lost...'}\nMe: ${state.myScore} vs Opp: ${state.oppScore}\n\nChaos rating: top ${state.myScore > 140 ? '5%' : '20%'}\n\nPlay at worst-eleven.com`;
  if (navigator.share) {
    navigator.share({ text });
  } else {
    navigator.clipboard.writeText(text).then(() => showToast('Result copied to clipboard!'));
  }
}

// ═══════════════════════════════════════════════════════════════
// UTILS
// ═══════════════════════════════════════════════════════════════
function getPlayer(id) {
  return PLAYERS.find(p => p.id === id);
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2200);
}

// ═══════════════════════════════════════════════════════════════
// MULTIPLAYER — Firebase Realtime Database
// ═══════════════════════════════════════════════════════════════

// ── Helpers ──────────────────────────────────────────────────
function genCode() {
  // 4-char alphanumeric code, easy to type on mobile
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // no I/O/1/0
  let code = '';
  for (let i = 0; i < 4; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

function getPlayerId() {
  // Persistent anonymous ID stored in localStorage
  let id = localStorage.getItem('worst-eleven-pid');
  if (!id) { id = 'p_' + Date.now() + '_' + Math.random().toString(36).slice(2, 7); localStorage.setItem('worst-eleven-pid', id); }
  return id;
}

function fbReady() {
  return window._fbReady && window._fb;
}

function showLobbyError(msg) {
  const el = document.getElementById('lobby-error');
  if (el) { el.textContent = msg; el.style.display = ''; }
}

function hideLobbyError() {
  const el = document.getElementById('lobby-error');
  if (el) el.style.display = 'none';
}

function showLobbyPhase(phase) {
  ['choose','waiting','joined'].forEach(p => {
    const el = document.getElementById('lobby-phase-' + p);
    if (el) el.style.display = p === phase ? 'flex' : 'none';
  });
}

// ── Entry points ──────────────────────────────────────────────
function openLobby() {
  if (!fbReady()) { showToast('Multiplayer not available — Firebase not configured'); return; }
  showLobbyPhase('choose');
  hideLobbyError();
  showScreen('lobby');
}

function leaveLobby() {
  // Detach any Firebase listeners and clean up
  if (state.mp && state.mp.sessionRef) {
    window._fb.off(state.mp.sessionRef);
  }
  state.mp = null;
  showScreen('home');
}

// ── Create game (Player A / Host) ─────────────────────────────
async function createGame() {
  if (!fbReady()) return;
  const profile = getActiveProfile();
  if (!profile) return;

  let code, snap, attempts = 0;
  do {
    code = genCode();
    snap = await window._fb.get(window._fb.ref('sessions/' + code));
    attempts++;
  } while (snap.exists() && attempts < 10);

  if (snap.exists()) { showLobbyError('Could not create a game — try again'); return; }

  const pid = getPlayerId();

  // Pick the match now so both players get the same one
  let matchIdx;
  do { matchIdx = Math.floor(Math.random() * ALL_MATCHES.length); }
  while (ALL_MATCHES.length > 1 && matchIdx === state.matchIdx);

  const session = {
    status:    'waiting',
    matchIdx,
    createdAt: Date.now(),
    playerA: { id: pid, name: profile.name, emoji: profile.emoji, ready: true },
    playerB: null,
    picks:    [],
    captainA: null,
    captainB: null,
    simStartTimestamp: null,
    scoreA: null,
    scoreB: null,
  };

  await window._fb.set(window._fb.ref('sessions/' + code), session);

  state.mp = {
    code,
    role:       'A',
    playerId:   pid,
    sessionRef: window._fb.ref('sessions/' + code),
  };

  // Update UI
  document.getElementById('lobby-code-display').textContent = code;
  document.getElementById('lobby-name-a').textContent = profile.emoji + ' ' + profile.name;
  showLobbyPhase('waiting');

  // Listen for Player B joining
  window._fb.onValue(state.mp.sessionRef, (snap) => {
    const data = snap.val();
    if (!data) return;
    if (data.playerB) {
      const nameEl = document.getElementById('lobby-name-b');
      if (nameEl) nameEl.textContent = data.playerB.emoji + ' ' + data.playerB.name;
      const dot = document.querySelector('#lobby-phase-waiting .lobby-player-row:last-child .lobby-player-dot');
      if (dot) { dot.classList.remove('waiting'); dot.classList.add('ready'); }
      const tag = document.querySelector('#lobby-phase-waiting .lobby-player-row:last-child');
      if (tag && !tag.querySelector('.lobby-ready-tag')) {
        const t = document.createElement('span'); t.className = 'lobby-ready-tag'; t.textContent = 'Ready';
        tag.appendChild(t);
      }
    }
    if (data.status === 'drafting') {
      mpStartDraft(data);
    }
  });

  // Auto-start when B joins — give it 1s for UI to update
  window._fb.onValue(window._fb.ref('sessions/' + code + '/playerB'), async (snap) => {
    if (!snap.val()) return;
    await new Promise(r => setTimeout(r, 1200));
    // Transition to drafting
    await window._fb.update(window._fb.ref('sessions/' + code), { status: 'drafting' });
  });
}

// ── Join game (Player B / Guest) ──────────────────────────────
async function joinGame() {
  if (!fbReady()) return;
  const code = (document.getElementById('join-code-input').value || '').trim().toUpperCase();
  if (code.length !== 4) { showLobbyError('Enter a 4-letter code'); return; }

  const profile = getActiveProfile();
  if (!profile) return;

  const pid = getPlayerId();
  hideLobbyError();

  const sessionRef = window._fb.ref('sessions/' + code);
  const snap = await window._fb.get(sessionRef);

  if (!snap.exists()) { showLobbyError('Game not found — check the code'); return; }
  const data = snap.val();
  if (data.status !== 'waiting') { showLobbyError('Game already started'); return; }
  if (data.playerB) { showLobbyError('Game is full'); return; }
  if (data.playerA.id === pid) { showLobbyError("That's your own game — share the code with a friend"); return; }

  await window._fb.update(sessionRef, {
    playerB: { id: pid, name: profile.name, emoji: profile.emoji, ready: true }
  });

  state.mp = {
    code,
    role:       'B',
    playerId:   pid,
    sessionRef,
  };

  // Update UI
  document.getElementById('lobby-joined-name-a').textContent = data.playerA.emoji + ' ' + data.playerA.name;
  document.getElementById('lobby-joined-name-b').textContent = profile.emoji + ' ' + profile.name;
  showLobbyPhase('joined');

  // Listen for game to start
  window._fb.onValue(sessionRef, (snap) => {
    const d = snap.val();
    if (!d) return;
    if (d.status === 'drafting') mpStartDraft(d);
  });
}

// ── Start multiplayer draft ────────────────────────────────────
function mpStartDraft(sessionData) {
  // Detach lobby listener — we'll set up draft-specific listeners
  if (state.mp && state.mp.sessionRef) window._fb.off(state.mp.sessionRef);

  const mp = state.mp;
  mp.matchIdx   = sessionData.matchIdx;
  mp.playerA    = sessionData.playerA;
  mp.playerB    = sessionData.playerB;

  // Set up game state
  const profile = getActiveProfile();
  state.teamName  = profile.emoji + ' ' + profile.name;
  state.teamEmoji = profile.emoji;
  loadMatch(mp.matchIdx);
  state.matchIdx = mp.matchIdx;

  // Build draft sequence — both clients use the same seed logic so sequence is identical
  // Host (A) wins coin flip to keep it simple (could be randomised later)
  const gkWinner = mp.role === 'A' ? 'me' : 'opp';
  buildDraftSequence(gkWinner === 'me');
  state.gkPickerIsMe = gkWinner === 'me';

  showScreen('draft');
  initPlayerData();
  renderDraftSlots();
  renderCarousel();
  updateTurnUI();
  startTimer();

  // Label opponent in draft header
  const oppName = mp.role === 'A' ? (mp.playerB.emoji + ' ' + mp.playerB.name) : (mp.playerA.emoji + ' ' + mp.playerA.name);
  showToast('🔴 LIVE — playing vs ' + oppName);

  // Listen for picks from Firebase
  window._fb.onValue(window._fb.ref('sessions/' + mp.code + '/picks'), (snap) => {
    const picks = snap.val() || [];
    mpSyncPicks(picks);
  });
}

// ── Sync picks from Firebase into local state ─────────────────
function mpSyncPicks(picks) {
  const mp = state.mp;
  if (!mp) return;

  // Rebuild teams from the canonical picks array
  const myRole  = mp.role;
  const newMy   = [];
  const newOpp  = [];
  const seq     = state.sequence;

  for (let i = 0; i < picks.length; i++) {
    const pick   = picks[i];
    const step   = seq[i];
    if (!step) continue;

    if (step.type === 'gk') {
      // GK pick: one player per team, we determine which is ours by role
      if (pick.teamA !== undefined) {
        if (myRole === 'A') { newMy.push(pick.teamA);  newOpp.push(pick.teamB); }
        else                { newMy.push(pick.teamB);  newOpp.push(pick.teamA); }
      }
    } else {
      const isMyPick = (myRole === 'A' && step.who === 'me') || (myRole === 'B' && step.who === 'opp');
      // In mp context, sequence is from Player A's perspective
      const isAPick  = step.who === 'me'; // 'me' in sequence = Player A
      if (isAPick) {
        if (myRole === 'A') newMy.push(pick.playerId);
        else newOpp.push(pick.playerId);
      } else {
        if (myRole === 'A') newOpp.push(pick.playerId);
        else newMy.push(pick.playerId);
      }
    }
  }

  state.myTeam  = newMy;
  state.oppTeam = newOpp;
  state.currentPick = picks.length;

  renderDraftSlots();
  renderCarousel();
  updateTurnUI();

  // Check if draft is complete
  if (picks.length >= state.sequence.length) {
    mpDraftComplete();
    return;
  }

  // If it's now my turn, start my timer
  const nextStep = state.sequence[picks.length];
  if (nextStep && ((mp.role === 'A' && nextStep.who === 'me') || (mp.role === 'B' && nextStep.who === 'opp'))) {
    startTimer();
  } else {
    clearInterval(state.timerInterval);
    updateTurnUI();
  }
}

// ── Write a pick to Firebase (called instead of local draftPlayer in mp mode) ──
async function mpDraftPlayer() {
  const mp   = state.mp;
  const step = currentStep();
  if (!step) return;

  // Only act on my turn
  const isMyTurn = (mp.role === 'A' && step.who === 'me') || (mp.role === 'B' && step.who === 'opp');
  if (!isMyTurn) return;
  if (!state.selectedPlayer) { showToast('Select a player first!'); return; }

  const drafted = [...state.myTeam, ...state.oppTeam];
  if (drafted.includes(state.selectedPlayer)) { state.selectedPlayer = null; renderCarousel(); return; }

  const picksRef  = window._fb.ref('sessions/' + mp.code + '/picks');
  const snapNow   = await window._fb.get(picksRef);
  const picksSoFar = snapNow.val() || [];

  // Guard: only write if the pick index matches what we expect
  if (picksSoFar.length !== state.currentPick) return;

  let pickEntry;
  if (step.type === 'gk') {
    const p = getPlayer(state.selectedPlayer);
    if (p.pos !== 'GK') { showToast('Must pick a goalkeeper!'); return; }
    const otherGK = PLAYERS.find(q => q.pos === 'GK' && q.id !== state.selectedPlayer);
    pickEntry = { teamA: mp.role === 'A' ? state.selectedPlayer : otherGK.id,
                  teamB: mp.role === 'A' ? otherGK.id : state.selectedPlayer };
  } else {
    pickEntry = { playerId: state.selectedPlayer };
  }

  await window._fb.update(window._fb.ref('sessions/' + mp.code), {
    picks: [...picksSoFar, pickEntry],
  });

  state.selectedPlayer = null;
  clearInterval(state.timerInterval);
}

// ── Draft complete → go to captain ────────────────────────────
function mpDraftComplete() {
  clearInterval(state.timerInterval);
  if (state.myTeam.length < 11 || state.oppTeam.length < 11) return;
  setTimeout(() => showCaptainScreen(), 600);
}

// ── Captain selection sync ────────────────────────────────────
async function mpSetCaptain(playerId) {
  const mp = state.mp;
  if (!mp) return;
  const field = mp.role === 'A' ? 'captainA' : 'captainB';
  await window._fb.update(mp.sessionRef, { [field]: playerId });
}

// ── Simulation sync ───────────────────────────────────────────
async function mpReadyToSim() {
  // Both players signal ready; Player A writes the start timestamp
  const mp = state.mp;
  if (!mp) return;
  const field = mp.role === 'A' ? 'simReadyA' : 'simReadyB';
  await window._fb.update(mp.sessionRef, { [field]: true });

  if (mp.role === 'A') {
    // Wait for B to also be ready then fire
    window._fb.onValue(mp.sessionRef, async (snap) => {
      const d = snap.val();
      if (d && d.simReadyA && d.simReadyB && !d.simStartTimestamp) {
        await window._fb.update(mp.sessionRef, {
          simStartTimestamp: Date.now(),
          status: 'simulating',
        });
      }
    });
  }
}

// Intercept startSim — in mp mode wait for shared timestamp
function mpWaitForSimStart(callback) {
  const mp = state.mp;
  window._fb.onValue(mp.sessionRef, (snap) => {
    const d = snap.val();
    if (d && d.simStartTimestamp) {
      window._fb.off(mp.sessionRef);
      const delay = Math.max(0, d.simStartTimestamp + 500 - Date.now());
      setTimeout(callback, delay);
    }
  });
}

// Write final score to Firebase for results comparison
async function mpWriteScore(score) {
  const mp = state.mp;
  if (!mp) return;
  const field = mp.role === 'A' ? 'scoreA' : 'scoreB';
  await window._fb.update(mp.sessionRef, { [field]: Math.round(score), status: 'done' });
}

// ── Override draftPlayer in mp mode ──────────────────────────
const _origDraftPlayer = draftPlayer;
const _origAfterPick   = afterPick;

// Patch draftPlayer to route through Firebase in mp mode
window.draftPlayer = function() {
  if (state.mp) { mpDraftPlayer(); }
  else { _origDraftPlayer(); }
};

</script>
</body>
</html>
