<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Worst Eleven</title>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=DM+Sans:wght@300;400;500;600&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --black: #0a0a0a;
    --white: #ffffff;
    --off-white: #f7f6f3;
    --card-bg: #ffffff;
    --border: #e8e6e1;
    --muted: #9b9690;
    --red: #e8290b;
    --green: #1a7a4a;
    --yellow: #f5a623;
    --blue: #1a3fc4;
    --home-colour: #6cabdd;
    --home-colour-dark: #1c5493;
    --home-colour-light: #eef2ff;
    --home-colour-border: #c7d2fe;
    --away-colour: #fbee23;
    --away-colour-dark: #c8a000;
    --away-colour-light: #fffbea;
    --away-colour-border: #fde68a;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'DM Sans', sans-serif;
    background: var(--off-white);
    color: var(--black);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* ─── SCREENS ─── */
  .screen { display: none; min-height: 100vh; }
  .screen.active { display: flex; flex-direction: column; }

  /* ─── HEADER ─── */
  .game-header {
    background: var(--black);
    padding: 16px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: sticky;
    top: 0;
    z-index: 100;
  }
  .logo {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 28px;
    color: var(--white);
    letter-spacing: 2px;
  }
  .logo span { color: var(--red); }
  .match-badge {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  /* ─── HOME SCREEN ─── */
  #screen-home {
    background: var(--black);
    align-items: center;
    justify-content: flex-start;
    text-align: center;
    padding: 28px 24px 24px;
    overflow-y: auto;
  }
  .home-logo {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(52px, 12vw, 80px);
    color: var(--white);
    letter-spacing: 4px;
    line-height: 0.88;
    margin-bottom: 8px;
  }
  .home-logo span { color: var(--red); }
  .home-tagline {
    font-size: 15px;
    color: var(--muted);
    margin-bottom: 20px;
    letter-spacing: 0.5px;
  }
  .home-tagline .tagline-score {
    color: white;
    font-weight: 700;
  }
  .match-preview-card {
    background: #141414;
    border: 1px solid #2a2a2a;
    border-radius: 16px;
    padding: 28px 32px;
    max-width: 380px;
    width: 100%;
    margin: 0 auto 32px;
  }
  .match-preview-label {
    font-size: 12px;
    color: var(--muted);
    font-weight: 500;
    margin-bottom: 0;
  }
  .match-teams {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 8px 12px;
  }
  .match-team-crest-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    flex: 1;
  }
  .team-crest {
    width: 60px;
    height: 60px;
    object-fit: contain;
  }
  .crest-fallback {
    width: 60px;
    height: 60px;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 38px;
  }
  .match-vs-col {
    font-size: 14px;
    font-weight: 500;
    color: var(--muted);
    flex-shrink: 0;
    padding: 0 12px;
    margin-bottom: 26px;
  }
  .match-team-name {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 28px;
    font-weight: 400;
    color: var(--black);
    letter-spacing: 1px;
  }
  .match-team-name.city { color: #6CABDD; }
  .match-team-name.watford { color: #FBEE23; text-shadow: 0 0 1px #aaa; }
  .match-score-display {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 48px;
    color: var(--white);
    line-height: 1;
  }
  .btn-primary {
    background: var(--white);
    color: var(--black);
    border: none;
    border-radius: 12px;
    padding: 18px 48px;
    font-family: 'DM Sans', sans-serif;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    letter-spacing: 0.3px;
    transition: all 0.15s;
    display: inline-block;
  }
  .btn-primary:hover { background: #e8e6e1; transform: translateY(-1px); }
  .btn-primary:disabled {
    background: #1e1e1e;
    color: #444;
    cursor: default;
    transform: none;
    border: 1.5px solid #2a2a2a;
  }
  .btn-primary:disabled:hover { background: #1e1e1e; transform: none; }
  .btn-primary.dark {
    background: var(--black);
    color: var(--white);
  }
  .btn-primary.dark:hover { background: #222; }
  .btn-primary.red { background: var(--red); color: white; }
  .btn-primary.red:hover { background: #c5230a; }
  .home-rules {
    background: #111;
    border-radius: 16px;
    padding: 14px 14px;
    margin-bottom: 14px;
    width: 100%;
  }
  .home-rules-title {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #555;
    margin-bottom: 12px;
  }
  .home-rule-step {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    margin-bottom: 9px;
    font-size: 12px;
    color: #aaa;
    line-height: 1.45;
  }
  .home-rule-step:last-child { margin-bottom: 0; }
  .home-rule-step strong { color: #ddd; }
  .home-rule-num {
    flex-shrink: 0;
    width: 20px;
    height: 20px;
    background: #1e1e1e;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 700;
    color: #555;
    margin-top: 1px;
  }
  .home-scoring {
    width: 100%;
    padding: 16px 0 8px;
  }
  .home-scoring-title {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #555;
    margin-bottom: 10px;
  }
  .home-scoring-row {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 13px;
    color: #888;
    margin-bottom: 6px;
  }
  .score-pill {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    font-weight: 700;
    padding: 2px 7px;
    border-radius: 6px;
    flex-shrink: 0;
    min-width: 44px;
    text-align: center;
  }
  .score-pill.pos { background: #1a2e1a; color: #4ade80; }
  .score-pill.neg { background: #2e1a1a; color: #f87171; }

  /* ─── DRAFT SCREEN ─── */
  #screen-draft {
    background: var(--off-white);
    flex-direction: column;
    height: 100dvh;
    max-height: 100dvh;
    overflow: hidden;
  }
  .draft-layout {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 10px 12px;
    gap: 8px;
    max-width: 600px;
    width: 100%;
    margin: 0 auto;
    min-height: 0;
    overflow: hidden;
  }

  /* Opponent zone */
  .zone-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 4px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .zone-label .dot {
    width: 6px; height: 6px;
    border-radius: 50%;
  }
  .dot.opponent { background: var(--red); }
  .dot.yours { background: var(--blue); }

  .slots-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 4px;
  }
  .player-slot {
    background: white;
    border: 1.5px solid var(--border);
    border-radius: 8px;
    padding: 0 4px;
    text-align: center;
    height: 50px;
    min-height: 50px;
    max-height: 50px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: background 0.2s, border-color 0.2s;
  }
  .player-slot.filled { border-color: transparent; }
  .player-slot.filled.opponent-slot { background: #fff5f4; border-color: #ffd5d0; }
  .player-slot.filled.your-slot { background: #f4f6ff; border-color: #d0d8ff; }
  .player-slot .slot-pos {
    font-family: 'DM Mono', monospace;
    font-size: 8px;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    line-height: 1;
  }
  .player-slot .slot-name {
    font-size: 10px;
    font-weight: 600;
    line-height: 1.2;
    margin-top: 1px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
  }
  .player-slot .slot-team {
    font-size: 9px;
    line-height: 1;
    margin-top: 1px;
  }
  .player-slot.empty-slot .slot-pos { color: #ccc; font-size: 9px; }

  /* Middle carousel */
  .draft-middle {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 7px;
    min-height: 0;
  }

  /* Combined bottom action row */
  .draft-action-row {
    display: flex;
    align-items: stretch;
    gap: 8px;
    width: 100%;
    flex-shrink: 0;
    box-sizing: border-box;
  }
  .turn-pill {
    display: flex;
    align-items: center;
    gap: 8px;
    background: var(--black);
    color: white;
    border-radius: 10px;
    padding: 10px 12px;
    flex: 1 1 0;
    min-width: 0;
    max-width: calc(55% - 4px);
    overflow: hidden;
  }
  .turn-text {
    font-size: 11px;
    font-weight: 500;
    flex: 1;
    min-width: 0;
    line-height: 1.35;
    overflow: hidden;
  }
  .turn-text strong {
    display: block;
    font-size: 12px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
  }
  .turn-text em { font-style: normal; color: #aaa; font-size: 10.5px; }
  .btn-confirm {
    flex: 1 1 0;
    min-width: 0;
    max-width: calc(45% - 4px);
    padding: 11px 8px;
    border-radius: 10px;
    border: none;
    font-size: 13px;
    font-weight: 700;
    cursor: pointer;
    transition: background 0.15s;
    background: var(--blue);
    color: white;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .btn-confirm:disabled { opacity: 0.4; cursor: not-allowed; }
  .btn-confirm:not(:disabled):hover { background: #1535a8; }
  .timer-ring {
    width: 30px; height: 30px;
    position: relative;
    flex-shrink: 0;
  }
  .timer-ring svg {
    position: absolute;
    inset: 0;
    transform: rotate(-90deg);
    width: 100%;
    height: 100%;
  }
  .timer-ring circle {
    fill: none;
    stroke: #333;
    stroke-width: 3;
  }
  .timer-ring .progress {
    stroke: var(--yellow);
    stroke-linecap: round;
    transition: stroke-dashoffset 1s linear;
  }
  .timer-num {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    font-weight: 600;
    color: white;
    line-height: 1;
  }

  /* Team toggle */
  .team-toggle {
    display: flex;
    background: white;
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 3px;
    gap: 3px;
  }
  .team-toggle button {
    border: none;
    background: none;
    padding: 8px 16px;
    border-radius: 7px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
    color: var(--muted);
  }
  .team-toggle button.active {
    background: var(--black);
    color: white;
  }

  /* Sabotage bar hidden */
  .sabotage-bar { display: none; }

  /* Player cards carousel */
  .carousel-container {
    width: 100%;
    overflow-x: auto;
    overflow-y: visible;
    position: relative;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }
  .carousel-container::-webkit-scrollbar { display: none; }
  .carousel-track {
    display: flex;
    gap: 10px;
    padding: 4px;
    width: max-content;
  }
  .player-card {
    flex-shrink: 0;
    width: 96px;
    background: white;
    border: 2px solid var(--border);
    border-radius: 10px;
    padding: 8px 8px;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    position: relative;
  }
  .player-card:hover { border-color: var(--black); transform: translateY(-2px); box-shadow: 0 4px 16px rgba(0,0,0,0.1); }
  .player-card.selected { border-color: var(--blue); background: #f4f6ff; }
  .player-card .card-pos {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--muted);
    margin-bottom: 3px;
  }
  .player-card .card-name {
    font-size: 12px;
    font-weight: 700;
    line-height: 1.2;
    margin-bottom: 3px;
  }
  .player-card .card-team {
    font-size: 10px;
    color: var(--muted);
  }
  .player-card .chaos-score { display: none; }
  .card-team-dot {
    display: inline-block;
    width: 6px; height: 6px;
    border-radius: 50%;
    margin-right: 3px;
    vertical-align: middle;
    margin-top: -1px;
  }
  .home-dot { background: var(--home-colour); }
  .away-dot { background: var(--away-colour); }

  .btn-pick-me {
    background: var(--blue);
    border-color: var(--blue);
    color: white;
  }
  .btn-pick-me:hover { background: #1535a8; }
  .btn-sabotage { display: none; }

  /* Auto-scroll hint */
  .carousel-hint {
    font-size: 11px;
    color: var(--muted);
    text-align: center;
  }

  /* ─── SIMULATION SCREEN ─── */
  /* ─── CAPTAIN SCREEN ─── */
  #screen-captain {
    background: white;
    flex-direction: column;
    min-height: 100dvh;
    padding-bottom: 100px;
  }
  .captain-header {
    padding: 20px 24px 12px;
    text-align: center;
  }
  .captain-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 32px;
    color: var(--black);
    letter-spacing: 2px;
    line-height: 1;
    margin-bottom: 4px;
  }
  .captain-sub {
    font-size: 12px;
    color: var(--muted);
    line-height: 1.4;
  }
  .captain-grid {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 7px;
    padding: 0 12px;
    flex: 1;
  }
  .captain-tile {
    background: var(--off-white);
    border: 2px solid var(--border);
    border-radius: 12px;
    padding: 8px 10px;
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    flex-direction: column;
    gap: 2px;
    position: relative;
    overflow: hidden;
    min-height: 0;
  }
  .captain-tile:active { transform: scale(0.96); }
  .captain-tile.selected {
    border-color: #f5a623;
    background: #fff8ed;
  }
  .captain-tile.selected::after {
    content: 'C';
    font-family: 'Bebas Neue', sans-serif;
    font-size: 11px;
    letter-spacing: 1px;
    position: absolute;
    top: 6px;
    right: 8px;
    color: #f5a623;
  }
  .captain-tile.random-tile {
    grid-column: span 2;
    background: #f5f5f5;
    border-style: dashed;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
  .captain-tile.random-tile.selected {
    border-color: #f5a623;
    background: #fff8ed;
    border-style: solid;
  }
  .captain-tile-pos {
    font-family: 'DM Mono', monospace;
    font-size: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #aaa;
  }
  .captain-tile-name {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 17px;
    color: var(--black);
    letter-spacing: 0.5px;
    line-height: 1;
  }
  .captain-tile.selected .captain-tile-name { color: #f5a623; }
  .captain-tile.random-tile .captain-tile-name {
    font-size: 13px;
    color: #888;
    text-align: center;
    font-family: 'DM Mono', monospace;
    letter-spacing: 0;
  }
  .captain-tile-team {
    font-size: 10px;
    color: #bbb;
  }
  .captain-tile-dot {
    display: inline-block;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    margin-right: 3px;
    vertical-align: middle;
  }
  .captain-footer {
    position: fixed;
    bottom: 0;
    left: 0; right: 0;
    background: white;
    border-top: 1px solid var(--border);
    padding: 10px 20px 24px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 7px;
  }
  .captain-hint {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: #aaa;
    text-align: center;
    letter-spacing: 1px;
    text-transform: uppercase;
    transition: color 0.2s;
  }
  .captain-hint.chosen { color: #f5a623; }
  .captain-confirm {
    width: 100%;
    max-width: 360px;
    font-size: 15px;
    padding: 16px 32px;
  }

  /* ═══════════════════════════════════════════
     PITCH VIEW
  ═══════════════════════════════════════════ */
  .sim-pitch-wrap {
    flex: 1;
    position: relative;
    overflow: hidden;
    display: none;
    min-height: 0;
  }
  .sim-pitch-wrap.active { 
    display: flex;
    flex-direction: column;
  }
  .sim-pitch-wrap.active .pitch-field {
    flex: 1;
  }

  .pitch-field {
    width: 100%;
    height: 100%;
    min-height: 200px;
    background: linear-gradient(180deg, #2d7a3a 0%, #267034 50%, #2d7a3a 100%);
    position: relative;
    overflow: hidden;
  }
  .pitch-svg {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
  .pitch-half-label {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.3);
    pointer-events: none;
    z-index: 2;
  }
  .pitch-half-label.top    { top: 10px; }
  .pitch-half-label.bottom { bottom: 10px; }

  .pitch-event-tile {
    position: absolute;
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 7px 12px;
    border-radius: 10px;
    font-size: 12px;
    font-weight: 700;
    white-space: nowrap;
    pointer-events: none;
    z-index: 10;
    box-shadow: 0 4px 16px rgba(0,0,0,0.5);
    will-change: transform, opacity;
    max-width: 200px;
  }
  .pitch-event-tile.col-green { background: #16a34a; color: white; }
  .pitch-event-tile.col-red   { background: #dc2626; color: white; }

  .pitch-tile-name {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 15px;
    letter-spacing: 0.5px;
    line-height: 1;
  }
  .pitch-tile-pts {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    opacity: 0.85;
  }
  .pitch-tile-emoji { font-size: 13px; line-height: 1; }

  @keyframes pitch-fly-right {
    0%   { transform: translateX(-120%); opacity: 0; }
    12%  { opacity: 1; }
    65%  { transform: translateX(0); opacity: 1; }
    100% { transform: translateX(0); opacity: 0; }
  }
  @keyframes pitch-fly-left {
    0%   { transform: translateX(120%); opacity: 0; }
    12%  { opacity: 1; }
    65%  { transform: translateX(0); opacity: 1; }
    100% { transform: translateX(0); opacity: 0; }
  }
  .pitch-event-tile.fly-right {
    animation: pitch-fly-right 1.9s cubic-bezier(0.22, 0.61, 0.36, 1) forwards;
  }
  .pitch-event-tile.fly-left {
    animation: pitch-fly-left 1.9s cubic-bezier(0.22, 0.61, 0.36, 1) forwards;
  }


  #screen-sim {
    background: white;
    flex-direction: column;
    height: 100dvh;
    max-height: 100dvh;
    overflow: hidden;
  }
  .sim-header {
    background: var(--black);
    padding: 8px 16px 6px;
    flex-shrink: 0;
  }
  /* ─── SCOREBOARD ─── */
  .sim-scoreboard {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 0 6px;
  }
  .sim-player-score {
    display: flex;
    flex-direction: column;
    gap: 1px;
  }
  .sim-player-label {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    letter-spacing: 2px;
    color: #aaa;
    text-transform: uppercase;
  }
  .sim-score-status {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 26px;
    letter-spacing: 1px;
    color: white;
    line-height: 1;
  }
  .sim-score-status.winning { color: #4ade80; }
  .sim-score-status.losing  { color: #f87171; }
  .sim-score-status.level   { color: #888; }
  .sim-middle {
    text-align: center;
    flex: 1;
  }
  .sim-gap-line {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: #444;
    letter-spacing: 1px;
    text-transform: uppercase;
    text-align: center;
  }
  .sim-opp-pts {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 26px;
    letter-spacing: 1px;
    color: #ccc;
    line-height: 1;
    text-align: right;
  }


  /* ─── TUTORIAL OVERLAY ─────────────────────────────────────── */
  .tutorial-overlay {
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    background: rgba(0,0,0,0.72);
    animation: tut-fade-in 0.25s ease;
    padding-bottom: env(safe-area-inset-bottom, 0px);
  }
  @keyframes tut-fade-in {
    from { opacity: 0; }
    to   { opacity: 1; }
  }
  .tutorial-card {
    background: #fff;
    border-radius: 20px 20px 0 0;
    padding: 28px 24px 36px;
    width: 100%;
    max-width: 480px;
    position: relative;
    animation: tut-slide-up 0.3s cubic-bezier(0.34,1.56,0.64,1);
  }
  @keyframes tut-slide-up {
    from { transform: translateY(60px); opacity: 0; }
    to   { transform: translateY(0);    opacity: 1; }
  }
  .tutorial-step-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    color: #aaa;
    margin-bottom: 10px;
    text-transform: uppercase;
  }
  .tutorial-emoji {
    font-size: 36px;
    margin-bottom: 10px;
    display: block;
  }
  .tutorial-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 26px;
    letter-spacing: 1px;
    color: #111;
    margin-bottom: 8px;
    line-height: 1.1;
  }
  .tutorial-body {
    font-size: 15px;
    color: #444;
    line-height: 1.55;
    margin-bottom: 24px;
  }
  .tutorial-body strong { color: #111; }
  .tutorial-got-it {
    width: 100%;
    background: #111;
    color: #fff;
    border: none;
    border-radius: 14px;
    padding: 16px;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 20px;
    letter-spacing: 1px;
    cursor: pointer;
    transition: background 0.15s;
  }
  .tutorial-got-it:hover { background: #333; }
  .tutorial-skip {
    display: block;
    text-align: center;
    margin-top: 12px;
    font-size: 12px;
    color: #bbb;
    cursor: pointer;
    text-decoration: underline;
  }
  /* Tutorial button on home screen */
  .tutorial-home-btn {
    width: 100%;
    max-width: 360px;
    background: linear-gradient(135deg, #e8290b, #ff6b35);
    color: white;
    border: none;
    border-radius: 14px;
    padding: 18px 16px;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 22px;
    letter-spacing: 1.5px;
    cursor: pointer;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    box-shadow: 0 4px 16px rgba(232,41,11,0.3);
  }
  .tutorial-home-btn:hover { opacity: 0.92; }

  /* ─── EVENT TIMELINE STRIP ─── */
  .sim-timeline {
    padding: 4px 16px 6px;
    background: var(--black);
    flex-shrink: 0;
  }
  .sim-timeline-halves {
    display: flex;
    gap: 6px;
    align-items: flex-end;
  }
  .sim-timeline-half {
    position: relative;
    height: 36px;
    flex: 1;
  }
  .sim-timeline-half.second-half {
    opacity: 0.35; /* dim until HT */
  }
  .sim-timeline-half.second-half.active {
    opacity: 1;
  }
  .sim-timeline-track {
    position: absolute;
    bottom: 6px;
    left: 0; right: 0;
    height: 2px;
    background: #222;
    border-radius: 2px;
  }
  .sim-timeline-progress {
    position: absolute;
    bottom: 0; left: 0;
    height: 100%;
    background: #333;
    border-radius: 2px;
    transition: width 0.8s linear;
  }
  .sim-timeline-event {
    position: absolute;
    bottom: 10px;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
  }
  .sim-timeline-emoji {
    font-size: 11px;
    line-height: 1;
  }
  .sim-timeline-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background: #555;
  }
  .sim-timeline-dot.good { background: #4ade80; }
  .sim-timeline-dot.bad  { background: #f87171; }
  .sim-timeline-divider {
    width: 1px;
    height: 20px;
    background: #333;
    align-self: flex-end;
    margin-bottom: 0;
    flex-shrink: 0;
  }
  .sim-timeline-ht-label {
    font-family: 'DM Mono', monospace;
    font-size: 8px;
    color: #444;
    letter-spacing: 1px;
    text-align: center;
    margin-bottom: 0;
    align-self: flex-end;
    padding-bottom: 0px;
    flex-shrink: 0;
  }

  /* ─── PREDICTION OVERLAY ─── */
  .prediction-overlay {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    background: var(--black);
    padding: 16px 20px 32px;
    z-index: 100;
    animation: pred-slide-up 0.25s ease;
  }
  @keyframes pred-slide-up {
    from { transform: translateY(100%); opacity: 0; }
    to   { transform: translateY(0);    opacity: 1; }
  }
  .prediction-question {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 22px;
    letter-spacing: 1px;
    color: white;
    text-align: center;
    margin-bottom: 10px;
    line-height: 1.3;
  }
  .prediction-timer-bar {
    height: 3px;
    background: #333;
    border-radius: 2px;
    overflow: hidden;
    margin-bottom: 14px;
  }
  .prediction-timer-fill {
    height: 100%;
    background: #f5a623;
    border-radius: 2px;
    width: 100%;
    transition: width 3s linear;
  }
  .prediction-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }
  .pred-btn {
    padding: 14px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
    transition: transform 0.1s, opacity 0.1s;
  }
  .pred-btn:active { transform: scale(0.96); }
  .pred-yes { background: #16a34a; color: white; }
  .pred-no  { background: #dc2626; color: white; }
  .pred-btn.selected { outline: 3px solid white; }
  .pred-btn:disabled { opacity: 0.4; pointer-events: none; }
  .pred-scoring-hint {
    font-size: 10px;
    color: rgba(255,255,255,0.4);
    text-align: center;
    margin-top: 6px;
    letter-spacing: 0.5px;
    font-family: 'DM Mono', monospace;
  }

  /* ─── 3-OPTION SCORER QUESTION ─── */
  .scorer-overlay {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    background: var(--black);
    padding: 16px 20px 32px;
    z-index: 100;
    animation: pred-slide-up 0.25s ease;
  }
  .scorer-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    letter-spacing: 2px;
    color: #f5a623;
    text-align: center;
    text-transform: uppercase;
    margin-bottom: 6px;
  }
  .scorer-question {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 22px;
    letter-spacing: 1px;
    color: white;
    text-align: center;
    margin-bottom: 10px;
    line-height: 1.3;
  }
  .scorer-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 8px;
  }
  .scorer-btn {
    padding: 14px 8px;
    border: 2px solid #333;
    border-radius: 12px;
    background: #111;
    color: white;
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    transition: transform 0.1s, background 0.1s;
    text-align: center;
  }
  .scorer-btn:active  { transform: scale(0.96); }
  .scorer-btn:disabled { opacity: 0.4; pointer-events: none; }
  .scorer-btn.correct { background: #16a34a; border-color: #16a34a; }
  .scorer-btn.wrong   { background: #dc2626; border-color: #dc2626; }

  /* ─── REVEAL TIP CARD ─── */
  .reveal-tip-card {
    margin: 14px 0 8px;
    border: 1.5px solid #333;
    border-radius: 12px;
    padding: 12px 16px;
    text-align: center;
    width: 100%;
    box-sizing: border-box;
  }
  .reveal-tip-btn {
    background: none;
    border: none;
    color: #f5a623;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    width: 100%;
    padding: 0;
  }
  .reveal-tip-btn:disabled {
    color: #555;
    cursor: default;
  }
  .reveal-tip-cost {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: #555;
    margin-top: 4px;
    letter-spacing: 1px;
  }
  .reveal-tip-content {
    margin-top: 10px;
    font-size: 13px;
    color: #ccc;
    line-height: 1.5;
    border-top: 1px solid #333;
    padding-top: 10px;
  }
  .reveal-tip-content strong { color: white; }
  .reveal-tip-taken {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: #f5a623;
    margin-top: 6px;
    letter-spacing: 1px;
  }

  /* ─── HALF TIME OVERLAY ─── */
  .ht-overlay {
    position: fixed;
    inset: 0;
    background: #111;
    z-index: 150;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 10px;
    animation: ht-fade-in 0.3s ease;
  }
  @keyframes ht-fade-in {
    from { opacity: 0; }
    to   { opacity: 1; }
  }
  .ht-whistle {
    font-size: 52px;
    margin-bottom: 4px;
  }
  .ht-label {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 52px;
    letter-spacing: 4px;
    color: #f5c842;
    line-height: 1;
  }
  .ht-score {
    font-family: 'DM Mono', monospace;
    font-size: 14px;
    color: #888;
    letter-spacing: 2px;
    margin-top: 4px;
  }
  .ht-sub {
    font-size: 13px;
    color: #555;
    font-style: italic;
    margin-top: 8px;
  }

  /* ─── HT SWAP CARDS ─── */
  .ht-swap-card {
    background: #1a1a1a;
    border: 1.5px solid #2a2a2a;
    border-radius: 8px;
    padding: 8px 10px;
    cursor: pointer;
    transition: all 0.15s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
  }
  .ht-swap-card:active { transform: scale(0.97); }
  .ht-swap-card.selected-out {
    border-color: #f5c842;
    background: #2a2500;
  }
  .ht-swap-card.selected-in {
    border-color: #4ade80;
    background: #0a2a14;
  }
  .ht-swap-card.locked {
    opacity: 0.4;
    pointer-events: none;
  }
  .ht-swap-card .sc-pos {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    color: #555;
    width: 22px;
    flex-shrink: 0;
  }
  .ht-swap-card .sc-name {
    font-weight: 600;
    color: white;
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .ht-swap-card .sc-pts {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: #555;
    flex-shrink: 0;
  }

  /* ─── RESULTS GRAPH ─── */
  .result-graph-wrap {
    position: relative;
    width: 100%;
    max-width: 400px;
    margin: 0 auto 24px;
    background: #f7f6f3;
    border-radius: 14px;
    padding: 16px 12px 10px;
    box-sizing: border-box;
  }
  .result-graph-title {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #aaa;
    text-align: center;
    margin-bottom: 8px;
  }
  #result-graph { width: 100%; display: block; }
  .profile-delete-btn {
    width: 100%;
    margin-top: 8px;
    background: none;
    border: 1.5px solid #f87171;
    border-radius: 10px;
    padding: 12px;
    font-size: 13px;
    font-weight: 600;
    color: #f87171;
    cursor: pointer;
    transition: all 0.15s;
  }
  .profile-delete-btn:hover { background: #fff1f2; }

  /* ─── TEAM BADGES ─── */
  .match-badges-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-bottom: 8px;
  }
  .match-badge-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }
  .match-badge-name {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    letter-spacing: 1px;
    color: #888;
    text-transform: uppercase;
    text-align: center;
    max-width: 64px;
    line-height: 1.2;
  }
  .match-badge-vs {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 22px;
    color: #555;
    padding: 0 2px;
    line-height: 1;
  }
  .results-badges-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    margin-top: 8px;
    margin-bottom: 4px;
  }
  .results-badge-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 3px;
  }
  .results-badge-name {
    font-family: 'DM Mono', monospace;
    font-size: 8px;
    letter-spacing: 1px;
    color: #bbb;
    text-transform: uppercase;
    text-align: center;
  }
  .results-badge-score {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 20px;
    color: white;
    letter-spacing: 2px;
  }

  .pred-result-flash {
    position: fixed;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: #111;
    color: white;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 34px;
    letter-spacing: 3px;
    padding: 18px 32px;
    border-radius: 14px;
    z-index: 300;
    opacity: 0;
    transition: opacity 0.18s ease, transform 0.18s ease;
    pointer-events: none;
    text-align: center;
    border: 3px solid transparent;
  }
  .pred-result-flash.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
  .pred-result-flash.correct { border-color: #16a34a; color: #4ade80; }
  .pred-result-flash.wrong   { border-color: #dc2626; color: #f87171; }
  .pred-result-flash.timeout { border-color: #555; }

  /* ─── LOBBY SCREEN ─── */
  #screen-lobby {
    background: var(--black);
    flex-direction: column;
    min-height: 100dvh;
    color: white;
  }
  .lobby-inner {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 24px 24px 48px;
    width: 100%;
    max-width: 420px;
    margin: 0 auto;
    box-sizing: border-box;
    gap: 0;
  }
  .lobby-phase {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    gap: 16px;
    animation: phase-in 0.3s ease;
  }
  .lobby-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 40px;
    letter-spacing: 2px;
    color: white;
    text-align: center;
    margin-top: 16px;
  }
  .lobby-sub {
    font-size: 14px;
    color: #888;
    text-align: center;
    line-height: 1.6;
    max-width: 300px;
  }
  .lobby-btn {
    background: white;
    color: var(--black);
    border: none;
    border-radius: 14px;
    padding: 16px 32px;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
    width: 100%;
    max-width: 280px;
    transition: opacity 0.15s;
  }
  .lobby-btn:active { opacity: 0.8; }
  .lobby-btn-sm {
    background: white;
    color: var(--black);
    border: none;
    border-radius: 10px;
    padding: 12px 20px;
    font-size: 15px;
    font-weight: 700;
    cursor: pointer;
    white-space: nowrap;
    flex-shrink: 0;
  }
  .lobby-divider {
    font-size: 12px;
    color: #444;
    letter-spacing: 2px;
  }
  .lobby-join-row {
    display: flex;
    gap: 10px;
    width: 100%;
    max-width: 280px;
  }
  .lobby-code-input {
    flex: 1;
    background: #1a1a1a;
    border: 1.5px solid #333;
    border-radius: 10px;
    color: white;
    font-family: 'DM Sans', sans-serif;
    font-size: 15px;
    font-weight: 600;
    letter-spacing: 3px;
    padding: 10px 12px;
    text-align: center;
    outline: none;
    min-width: 0;
  }
  .lobby-code-input::placeholder { letter-spacing: 0; font-weight: 400; color: #555; font-size: 13px; }
  .lobby-code-input:focus { border-color: #555; }
  .lobby-code-display {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 72px;
    letter-spacing: 12px;
    color: white;
    line-height: 1;
    margin: 8px 0;
  }
  .lobby-waiting-status {
    background: #111;
    border-radius: 14px;
    padding: 16px 20px;
    width: 100%;
    max-width: 280px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    box-sizing: border-box;
  }
  .lobby-player-row {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 14px;
    color: #ccc;
  }
  .lobby-player-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  .lobby-player-dot.ready   { background: #16a34a; }
  .lobby-player-dot.waiting { background: #444; animation: dot-pulse 1.5s ease-in-out infinite; }
  @keyframes dot-pulse {
    0%, 100% { opacity: 0.3; }
    50%       { opacity: 1; }
  }
  .lobby-ready-tag {
    margin-left: auto;
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    letter-spacing: 1px;
    color: #16a34a;
  }
  .lobby-hint {
    font-size: 12px;
    color: #444;
    text-align: center;
    font-style: italic;
  }
  .lobby-error {
    font-size: 13px;
    color: #f87171;
    text-align: center;
  }

  /* ─── HOME SCREEN mp button ─── */
  #mp-btn { margin-top: 0; }
  .score-bar-track {
    height: 3px;
    background: #222;
    border-radius: 2px;
    position: relative;
    overflow: hidden;
  }
  .score-bar-fill {
    position: absolute;
    top: 0; bottom: 0; left: 0;
    background: #7c9fff;
    transition: width 0.5s ease;
  }

  /* Match clock */
  .match-clock {
    text-align: center;
    padding: 5px 8px;
    font-family: 'DM Mono', monospace;
    font-size: 12px;
    font-weight: 700;
    color: var(--muted);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }

  /* Team view toggle */
  .sim-view-toggle {
    display: flex;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .sim-view-toggle button {
    flex: 1;
    padding: 8px;
    border: none;
    background: none;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    color: var(--muted);
    border-bottom: 2px solid transparent;
    transition: all 0.15s;
  }
  .sim-view-toggle button.active {
    color: var(--black);
    border-bottom-color: var(--black);
  }

  /* Player list during sim — this is the only scrolling zone */
  .sim-players {
    overflow-y: auto;
    padding: 4px 12px;
    min-height: 0;
    flex-shrink: 1;
    flex-grow: 0;
  }
  .sim-player-row {
    display: flex;
    align-items: center;
    padding: 6px 10px;
    border-radius: 8px;
    margin-bottom: 4px;
    border: 1.5px solid transparent;
    transition: all 0.3s;
    position: relative;
  }
  .sim-player-row.team-home    { background: var(--home-colour-light); border-color: var(--home-colour-border); }
  .sim-player-row.team-away { background: var(--away-colour-light); border-color: var(--away-colour-border); }
  .sim-player-row.flash-positive { border-color: #22c55e !important; background: #f0fdf4 !important; animation: flash-pulse 0.7s ease; }
  .sim-player-row.flash-negative { border-color: #ef4444 !important; background: #fff1f1 !important; animation: flash-pulse 0.7s ease; }
  .sim-player-row.subbed-off   { opacity: 0.45; }
  @keyframes flash-pulse {
    0% { transform: scale(1.02); }
    100% { transform: scale(1); }
  }
  .sim-player-pos {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: var(--muted);
    width: 26px;
    text-transform: uppercase;
  }
  .sim-player-name {
    flex: 1;
    font-size: 13px;
    font-weight: 500;
  }
  .sim-player-events {
    display: flex;
    gap: 3px;
    align-items: center;
  }
  .event-icon {
    font-size: 13px;
    animation: pop-in 0.3s ease;
  }
  @keyframes pop-in {
    0% { transform: scale(0); opacity: 0; }
    70% { transform: scale(1.3); }
    100% { transform: scale(1); opacity: 1; }
  }
  .sim-player-pts {
    font-family: 'DM Mono', monospace;
    font-size: 12px;
    font-weight: 500;
    width: 44px;
    text-align: right;
  }
  .pts-positive { color: #22c55e; }   /* green = positive pts, good for you */
  .pts-negative { color: var(--red); } /* red   = negative pts, losing points */
  .pts-neutral { color: var(--muted); }

  /* Delta popups */
  .delta-popup {
    position: absolute;
    right: 12px;
    top: -8px;
    font-family: 'DM Mono', monospace;
    font-size: 13px;
    font-weight: 700;
    animation: float-up 1.2s ease forwards;
    pointer-events: none;
    z-index: 10;
  }
  .delta-popup.positive { color: #22c55e; }
  .delta-popup.negative { color: var(--green); }
  @keyframes float-up {
    0% { opacity: 1; transform: translateY(0); }
    100% { opacity: 0; transform: translateY(-24px); }
  }

  /* Live actual scoreline */
  .live-scoreline {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 16px;
    background: #111;
    border-top: 1px solid #222;
    flex-shrink: 0;
  }
  .live-left {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .live-pill {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    font-weight: 700;
    letter-spacing: 1.5px;
    color: #fff;
    background: var(--red);
    padding: 2px 6px;
    border-radius: 4px;
    animation: live-pulse 1.5s ease-in-out infinite;
  }
  @keyframes live-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  .live-teams {
    font-size: 12px;
    color: #aaa;
    font-weight: 400;
  }
  .live-teams strong { color: white; font-weight: 700; }
  .live-clock {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    font-weight: 700;
    color: #aaa;
  }

  /* Commentary feed — pinned to bottom, larger and more prominent */
  .commentary-feed {
    background: var(--black);
    padding: 12px 16px;
    min-height: 72px;
    max-height: 72px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    flex-shrink: 0;
    transition: max-height 0.4s ease, padding 0.4s ease, background 0.3s ease;
    overflow: hidden;
  }
  .commentary-feed.feed-building {
    max-height: 140px;
    padding: 16px 16px;
    background: #0a0a0a;
  }
  .commentary-feed.feed-building .commentary-line {
    font-size: 15px;
    color: #e0e0e0;
  }
  .commentary-feed.feed-halftime {
    background: #1a1400;
    max-height: 56px;
  }
  .commentary-feed.feed-halftime .commentary-line {
    color: #f5c842;
    font-style: normal;
    font-weight: 600;
    font-size: 13px;
  }
  .commentary-line {
    font-size: 13px;
    color: #ccc;
    line-height: 1.4;
    font-style: italic;
    transition: opacity 0.3s;
    min-width: 0;
  }
  .commentary-lines {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  .commentary-line-sub {
    font-size: 11px;
    color: #666;
    font-style: italic;
    opacity: 0;
    transition: opacity 0.5s ease 0.2s;
  }
  .feed-building .commentary-line-sub { opacity: 1; }
  .commentary-line strong { color: white; font-style: normal; }
  .commentary-line-sub strong { color: #999; font-style: normal; }
  .commentary-feed.feed-flash-pos {
    animation: flash-green 1.6s ease forwards;
  }
  .commentary-feed.feed-flash-neg {
    animation: flash-red 1.6s ease forwards;
  }
  @keyframes flash-green {
    0%   { background: #14532d; }
    10%  { background: #14532d; }
    20%  { background: #111; }
    30%  { background: #14532d; }
    40%  { background: #111; }
    50%  { background: #14532d; }
    60%  { background: #111; }
    70%  { background: #14532d; }
    80%  { background: #111; }
    90%  { background: #14532d; }
    100% { background: #111; }
  }
  @keyframes flash-red {
    0%   { background: #7f1d1d; }
    10%  { background: #7f1d1d; }
    20%  { background: #111; }
    30%  { background: #7f1d1d; }
    40%  { background: #111; }
    50%  { background: #7f1d1d; }
    60%  { background: #111; }
    70%  { background: #7f1d1d; }
    80%  { background: #111; }
    90%  { background: #7f1d1d; }
    100% { background: #111; }
  }
  .commentary-emoji {
    font-size: 20px;
    flex-shrink: 0;
    transition: opacity 0.3s;
    min-width: 24px;
    text-align: center;
  }

  /* ─── RESULTS SCREEN ─── */
  #screen-results {
    background: var(--off-white);
  }
  .results-header {
    background: var(--black);
    padding: 32px 24px 24px;
    text-align: center;
  }
  .result-headline {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 52px;
    color: white;
    letter-spacing: 2px;
    line-height: 1;
    margin-bottom: 4px;
  }
  .result-sub {
    font-size: 14px;
    color: var(--muted);
  }
  .results-scores {
    padding: 20px 24px 8px;
    max-width: 600px;
    margin: 0 auto;
  }
  .result-score-card {
    background: white;
    border-radius: 20px;
    padding: 28px 24px 24px;
    text-align: center;
    border: 2px solid var(--border);
    width: 100%;
  }
  .result-score-card.full { display: block; }
  .result-score-card.winner { border-color: #22c55e; }
  .result-score-card.loser  { border-color: #ef4444; }
  .result-score-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
  }
  .result-score-emoji {
    font-size: 48px;
    line-height: 1;
    margin-bottom: 8px;
  }
  .result-outcome {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 56px;
    line-height: 1;
    margin: 4px 0 10px;
  }
  .result-score-card.winner .result-outcome { color: #16a34a; }
  .result-score-card.loser  .result-outcome { color: #dc2626; }
  .result-score-card.tied   .result-outcome { color: #888; }
  .result-score-detail {
    font-size: 14px;
    color: #555;
    margin-top: 2px;
    line-height: 1.5;
  }
  .result-score-card.winner .result-score-detail { color: #15803d; }
  .result-score-card.loser  .result-score-detail { color: #b91c1c; }

  .results-body {
    padding: 0 24px 24px;
    max-width: 600px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .result-section {
    background: white;
    border-radius: 16px;
    padding: 20px;
    border: 1px solid var(--border);
  }
  .result-section-title {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 14px;
  }

  /* ── Stats table ── */
  .stats-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
  }
  .stats-header {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    margin-bottom: 10px;
  }
  .stats-team-name {
    font-family: 'Bebas Neue', cursive;
    font-size: 16px;
    letter-spacing: 1px;
    color: #222;
  }
  .stats-team-name:last-child { text-align: right; }
  .stat-row {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    padding: 7px 0;
    border-bottom: 1px solid var(--border);
  }
  .stat-row:last-child { border-bottom: none; }
  .stat-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--muted);
    text-align: center;
    padding: 0 12px;
    white-space: nowrap;
  }
  .stat-home { text-align: left; }
  .stat-away { text-align: right; }
  .stat-val-active {
    font-family: 'Bebas Neue', cursive;
    font-size: 22px;
    color: #111;
    line-height: 1;
  }
  .stat-val-zero {
    font-size: 14px;
    color: #ccc;
  }

  /* ── Good, Bad & Ugly ── */
  .gbu-grid {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .gbu-tile {
    border-radius: 12px;
    padding: 14px 16px;
    border-left: 4px solid transparent;
  }
  .gbu-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 8px;
    font-weight: 700;
  }
  .gbu-text {
    font-size: 13px;
    line-height: 1.6;
    color: #333;
  }
  .gbu-text strong { font-weight: 700; }
  .gbu-text em { font-style: italic; }
  .gbu-good {
    background: #f0fdf4;
    border-left-color: #86efac;
  }
  .gbu-good .gbu-label { color: #16a34a; }
  .gbu-bad {
    background: #fefce8;
    border-left-color: #fde047;
  }
  .gbu-bad .gbu-label { color: #ca8a04; }
  .gbu-ugly {
    background: #fff1f2;
    border-left-color: #fca5a5;
  }
  .gbu-ugly .gbu-label { color: #dc2626; }

  .chaos-rating {
    text-align: center;
    padding: 8px;
  }
  .chaos-pct {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 48px;
    color: var(--red);
    line-height: 1;
  }
  .chaos-desc { font-size: 14px; color: var(--muted); margin-top: 4px; }

  .contributor-row {
    display: flex;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid var(--border);
  }
  .contributor-row:last-child { border-bottom: none; }
  .contributor-pos {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: var(--muted);
    width: 28px;
    text-transform: uppercase;
  }
  .contributor-name { flex: 1; font-size: 14px; font-weight: 500; }
  .contributor-team { font-size: 11px; color: var(--muted); }
  .contributor-pts {
    font-family: 'DM Mono', monospace;
    font-size: 14px;
    font-weight: 700;
    color: var(--red);
  }

  .moment-row {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    padding: 8px 0;
    border-bottom: 1px solid var(--border);
  }
  .moment-row:last-child { border-bottom: none; }
  .moment-icon { font-size: 20px; flex-shrink: 0; }
  .moment-text { font-size: 13px; line-height: 1.5; color: #333; }
  .moment-text strong { font-weight: 600; }
  .moment-swing {
    font-family: 'DM Mono', monospace;
    font-size: 12px;
    color: var(--red);
    font-weight: 700;
    margin-left: auto;
    flex-shrink: 0;
  }

  .badges-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .badge {
    background: var(--off-white);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 10px 14px;
    text-align: center;
    min-width: 100px;
  }
  .badge-icon { font-size: 24px; display: block; margin-bottom: 4px; }
  .badge-name { font-size: 11px; font-weight: 600; display: block; }
  .badge-desc { font-size: 10px; color: var(--muted); display: block; }

  .cta-newgame {
    background: #111;
    color: white;
    border: 1.5px solid #333 !important;
  }
  .cta-newgame:hover { background: #222; }
  .cta-row {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }
  .cta-row button {
    flex: 1;
    min-width: 120px;
    padding: 14px 20px;
    border-radius: 12px;
    border: none;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
  }
  .cta-rematch { background: var(--black); color: white; }
  .cta-rematch:hover { background: #222; }
  .cta-share { background: white; color: var(--black); border: 1.5px solid var(--border) !important; border: none; }
  .cta-share:hover { background: var(--off-white); }

  /* ─── TEAM NAME CARD ─── */
  .team-name-card {
    background: white;
    border: 1.5px solid var(--border);
    border-radius: 16px;
    padding: 12px 16px;
    width: 100%;
    max-width: 360px;
    margin-bottom: 12px;
  }
  .team-name-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 10px;
  }
  .team-name-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .emoji-pick-btn {
    font-size: 28px;
    background: var(--off-white);
    border: 1.5px solid var(--border);
    border-radius: 10px;
    width: 52px;
    height: 52px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    flex-shrink: 0;
    transition: background 0.15s;
    line-height: 1;
  }
  .emoji-pick-btn:hover { background: #e8e8e8; }
  .team-name-input {
    flex: 1;
    border: 1.5px solid var(--border);
    border-radius: 10px;
    padding: 12px 14px;
    font-size: 16px;
    font-family: 'DM Sans', sans-serif;
    font-weight: 600;
    outline: none;
    transition: border-color 0.15s;
    color: var(--black);
  }
  .team-name-input:focus { border-color: var(--black); }
  .team-name-input::placeholder { color: #ccc; font-weight: 400; }
  .emoji-hint {
    font-size: 11px;
    color: #bbb;
    margin-top: 7px;
  }
  .emoji-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 6px;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border);
  }
  .emoji-grid-item {
    font-size: 24px;
    background: var(--off-white);
    border: 1.5px solid transparent;
    border-radius: 8px;
    padding: 6px 0;
    text-align: center;
    cursor: pointer;
    transition: all 0.12s;
    line-height: 1;
  }
  .emoji-grid-item:hover { background: #e8e8e8; }
  .emoji-grid-item.selected { border-color: var(--black); background: #f0f0f0; }

  /* ─── PRE-MATCH REPORT ─── */
  .prematch-report {
    font-size: 13px;
    line-height: 1.65;
    color: #aaa;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #333;
  }
  .prematch-report strong { color: white; }

  /* Notification toast */
  .toast {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--black);
    color: white;
    padding: 12px 24px;
    border-radius: 10px;
    font-size: 14px;
    z-index: 999;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
  }
  .toast.show { opacity: 1; }

  /* ─── HOME SCREEN — PROFILE FIRST ─── */
  .home-profile-section {
    width: 100%;
    max-width: 360px;
    margin-bottom: 12px;
  }
  .profile-pick-label {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 8px;
  }
  .profile-cards-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 8px;
  }
  .profile-card {
    background: white;
    border: 2px solid var(--border);
    border-radius: 14px;
    padding: 12px 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 12px;
    transition: all 0.15s;
  }
  .profile-card:active { transform: scale(0.98); }
  .profile-card.active-profile {
    border-color: var(--black);
    background: var(--off-white);
  }
  .profile-card-emoji { font-size: 28px; flex-shrink: 0; }
  .profile-card-info { flex: 1; min-width: 0; }
  .profile-card-name {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 20px;
    letter-spacing: 1px;
    color: var(--black);
    line-height: 1;
  }
  .profile-card-stats {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: var(--muted);
    margin-top: 2px;
  }
  .profile-card-form { display: flex; gap: 3px; margin-top: 5px; }
  .form-pip {
    width: 14px; height: 14px; border-radius: 3px;
    font-size: 8px; font-weight: 700; color: white;
    display: flex; align-items: center; justify-content: center;
  }
  .form-pip.W { background: #16a34a; }
  .form-pip.L { background: #dc2626; }
  .form-pip.D { background: #888; }
  .form-pip.empty { background: #e5e5e5; }
  .profile-card-arrow {
    font-size: 18px;
    color: #ccc;
    flex-shrink: 0;
  }
  .profile-card-viewbtn {
    background: none;
    border: none;
    font-size: 11px;
    color: var(--muted);
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 6px;
    flex-shrink: 0;
    text-decoration: underline;
  }
  .profile-new-btn {
    width: 100%;
    background: none;
    border: 1.5px dashed #ccc;
    border-radius: 14px;
    padding: 12px;
    font-family: 'DM Mono', monospace;
    font-size: 12px;
    color: #aaa;
    cursor: pointer;
    transition: all 0.15s;
    letter-spacing: 1px;
  }
  .profile-new-btn:hover { border-color: #999; color: #666; }
  .profile-new-form {
    background: white;
    border: 2px solid var(--black);
    border-radius: 14px;
    padding: 14px 16px;
    display: none;
    flex-direction: column;
    gap: 10px;
  }
  .profile-new-form.open { display: flex; }
  .profile-new-row { display: flex; gap: 8px; align-items: center; }
  .profile-new-input {
    flex: 1;
    border: 1.5px solid var(--border);
    border-radius: 8px;
    padding: 10px 12px;
    font-size: 15px;
    font-family: 'DM Sans', sans-serif;
    outline: none;
  }
  .profile-new-input:focus { border-color: var(--black); }
  .profile-new-save {
    background: var(--black);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 10px 16px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
  }

  /* ─── PROFILE SCREEN ─── */
  #screen-profile {
    background: var(--off-white);
    flex-direction: column;
    min-height: 100dvh;
  }
  .profile-header {
    background: var(--black);
    padding: 20px 20px 24px;
    color: white;
  }
  .profile-back-btn {
    background: none;
    border: none;
    color: #666;
    font-size: 13px;
    cursor: pointer;
    padding: 0;
    margin-bottom: 12px;
    display: block;
    font-family: 'DM Mono', monospace;
    letter-spacing: 1px;
  }
  .profile-header-main {
    display: flex;
    align-items: center;
    gap: 14px;
  }
  .profile-header-emoji { font-size: 42px; }
  .profile-name-big {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 38px;
    letter-spacing: 2px;
    line-height: 1;
    color: white;
  }
  .profile-header-sub {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: #555;
    margin-top: 4px;
    letter-spacing: 1px;
    text-transform: uppercase;
  }
  .profile-body {
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 14px;
  }
  .profile-stat-row {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 10px;
  }
  .profile-stat-card {
    background: white;
    border-radius: 14px;
    padding: 14px 10px;
    text-align: center;
    border: 1.5px solid var(--border);
  }
  .profile-stat-num {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 32px;
    color: var(--black);
    line-height: 1;
  }
  .profile-stat-label {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--muted);
    margin-top: 3px;
  }
  .profile-section {
    background: white;
    border-radius: 14px;
    padding: 14px 16px;
    border: 1.5px solid var(--border);
  }
  .profile-section-title {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 10px;
  }
  .profile-form-strip {
    display: flex;
    gap: 6px;
  }
  .profile-form-pill {
    width: 36px; height: 36px;
    border-radius: 8px;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 16px;
    color: white;
    display: flex; align-items: center; justify-content: center;
  }
  .profile-form-pill.W { background: #16a34a; }
  .profile-form-pill.L { background: #dc2626; }
  .profile-form-pill.D { background: #888; }
  .profile-form-pill.empty { background: #f0f0f0; color: #ccc; }
  .profile-archive-bar-wrap { display: flex; flex-direction: column; gap: 8px; }
  .profile-archive-bar {
    height: 8px;
    background: #f0f0f0;
    border-radius: 4px;
    overflow: hidden;
  }
  .profile-archive-fill {
    height: 100%;
    background: var(--black);
    border-radius: 4px;
    transition: width 0.6s ease;
  }
  .profile-archive-label {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: var(--muted);
  }
  .profile-history-row {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 0;
    border-bottom: 1px solid var(--border);
  }
  .profile-history-row:last-child { border-bottom: none; }
  .profile-history-result {
    width: 28px; height: 28px;
    border-radius: 6px;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 14px;
    color: white;
    display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
  }
  .profile-history-result.W { background: #16a34a; }
  .profile-history-result.L { background: #dc2626; }
  .profile-history-result.D { background: #888; }
  .profile-history-match { flex: 1; min-width: 0; }
  .profile-history-matchname {
    font-size: 13px;
    font-weight: 600;
    color: var(--black);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .profile-history-meta {
    font-family: 'DM Mono', monospace;
    font-size: 10px;
    color: var(--muted);
    margin-top: 1px;
  }
  .profile-history-score {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: var(--muted);
    flex-shrink: 0;
  }
  .profile-badges-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
  }
  .profile-badge {
    background: var(--off-white);
    border: 1.5px solid var(--border);
    border-radius: 12px;
    padding: 12px 8px;
    text-align: center;
  }
  .profile-badge.earned { border-color: #f5a623; background: #fff8ed; }
  .profile-badge.locked { opacity: 0.4; }
  .profile-badge-icon { font-size: 26px; display: block; margin-bottom: 4px; }
  .profile-badge-name { font-size: 10px; font-weight: 700; display: block; color: var(--black); }
  .profile-badge-desc { font-size: 9px; color: var(--muted); display: block; margin-top: 2px; }

  /* ─── POST-MATCH FORM TILE ─── */
  .result-form-tile {
    background: white;
    border: 1.5px solid var(--border);
    border-radius: 16px;
    padding: 16px;
    margin-bottom: 0;
  }
  .result-form-title {
    font-family: 'DM Mono', monospace;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 10px;
  }
  .result-form-row {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
  }
  .result-form-stats {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: var(--muted);
    margin-top: 8px;
  }
  .result-view-profile-btn {
    width: 100%;
    margin-top: 10px;
    background: var(--black);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 12px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.15s;
  }
  .result-view-profile-btn:hover { background: #222; }

  /* Coin flip screen — full loading/reveal experience */
  #screen-coin {
    background: var(--black);
    color: white;
  }
  .coin-screen-inner {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px 24px;
    text-align: center;
    width: 100%;
    box-sizing: border-box;
  }
  .coin-phase {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    animation: phase-in 0.4s ease;
  }
  @keyframes phase-in {
    from { opacity: 0; transform: translateY(10px); }
    to   { opacity: 1; transform: translateY(0); }
  }
  .coin-phase-label {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    letter-spacing: 2px;
    color: #666;
    text-transform: uppercase;
    margin-bottom: 20px;
  }
  .coin-loading-tape {
    font-size: 64px;
    margin-bottom: 20px;
    animation: tape-wobble 1s ease-in-out infinite;
  }
  @keyframes tape-wobble {
    0%, 100% { transform: rotate(-4deg); }
    50%       { transform: rotate(4deg); }
  }
  .coin-loading-lines {
    font-family: 'DM Mono', monospace;
    font-size: 13px;
    color: #555;
    min-height: 20px;
  }
  .coin-reveal-matchup {
    font-family: 'Bebas Neue', cursive;
    font-size: 34px;
    letter-spacing: 1px;
    line-height: 1.1;
    color: white;
    margin-bottom: 6px;
  }
  .coin-reveal-date {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: #666;
    margin-bottom: 20px;
    letter-spacing: 1px;
  }
  .coin-reveal-blurb {
    font-size: 14px;
    line-height: 1.7;
    color: #ccc;
    max-width: 340px;
    text-align: left;
    margin-bottom: 28px;
  }
  .coin-reveal-blurb strong { color: white; }
  .coin-countdown-bar {
    width: 100%;
    max-width: 320px;
    height: 3px;
    background: #222;
    border-radius: 2px;
    overflow: hidden;
    margin-bottom: 10px;
  }
  .coin-countdown-fill {
    height: 100%;
    background: #555;
    width: 100%;
    transition: width 1s linear;
  }
  .coin-countdown-label {
    font-family: 'DM Mono', monospace;
    font-size: 11px;
    color: #555;
    letter-spacing: 1px;
  }

  /* Updated match preview for dynamic content */
  .match-team-name.home-team { color: #6CABDD; }
  .match-team-name.away-team { color: #FBEE23; text-shadow: 0 0 1px #aaa; }
</style>
<!-- ═══════════════════════ FIREBASE ═══════════════════════ -->
<!-- Replace the firebaseConfig object below with your own   -->
<!-- from Firebase Console → Project Settings → Your apps    -->
<script type="module">
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
  import { getDatabase, ref, set, get, update, onValue, off, serverTimestamp }
    from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js';

  const firebaseConfig = {
    apiKey:            "AIzaSyCUy5gY30n7DNLg2V20gZm05HKHk2RNIic",
    authDomain:        "worst-eleven.firebaseapp.com",
    databaseURL:       "https://worst-eleven-default-rtdb.europe-west1.firebasedatabase.app",
    projectId:         "worst-eleven",
    storageBucket:     "worst-eleven.firebasestorage.app",
    messagingSenderId: "340747531029",
    appId:             "1:340747531029:web:aad6a3cdbdc08e95aaef1c",
    measurementId:     "G-6F5HPEH1S4",
  };

  let app, db;
  try {
    app = initializeApp(firebaseConfig);
    db  = getDatabase(app);
    window._fbReady = true;
  } catch(e) {
    console.warn('Firebase not configured — multiplayer disabled.', e.message);
    window._fbReady = false;
  }

  // Expose Firebase helpers on window so the main (non-module) script can reach them
  // onValue() in Firebase v9 modular returns an unsubscribe function.
  // We wrap it to also register with our cleanup registry.
  const _origOnValue = (r, cb) => onValue(r, cb);
  window._fb = {
    ref:             (path)           => ref(db, path),
    set:             (r, v)           => set(r, v),
    get:             (r)              => get(r),
    update:          (r, v)           => update(r, v),
    onValue:         (r, cb)          => {
                       const unsub = onValue(r, cb);
                       if (window._mpUnsubs) window._mpUnsubs.push(unsub);
                       return unsub;
                     },
    off:             (r)              => off(r),
    serverTimestamp: ()               => serverTimestamp(),
  };
</script>
<script>
// ── Firebase listener registry ────────────────────────────────
// _fb.onValue() auto-registers every unsubscribe fn here.
// mpCleanup() kills ALL active mp listeners in one shot.
window._mpUnsubs = [];

function mpCleanup() {
  for (const unsub of window._mpUnsubs) {
    try { unsub(); } catch(e) {}
  }
  window._mpUnsubs = [];
}
</script>
</head>
<body>

<!-- ═══════════════════════════════════════ HOME ═══════════════════════════════════════ -->
<div id="screen-home" class="screen active">
  <!-- Title + tagline -->
  <div style="margin-bottom: 16px;">
    <div class="home-logo">WORST<br><span>ELEVEN</span></div>
    <div class="home-tagline">Draft the worst. <span class="tagline-score">Score the most. 😈</span></div>
  </div>

  <!-- Profile selector — pick or create -->
  <div class="home-profile-section">
    <div class="profile-pick-label">Your Profile</div>

    <!-- Existing profiles list (populated by JS) -->
    <div class="profile-cards-list" id="home-profiles-list"></div>

    <!-- + New profile button — shown when profiles already exist -->
    <button class="profile-new-btn" id="profile-add-btn" onclick="openNewProfileForm()" style="display:none;">+ New profile</button>

    <!-- New profile creation form -->
    <div class="profile-new-form" id="profile-new-form">
      <div class="profile-new-row">
        <button class="emoji-pick-btn" id="emoji-btn" onclick="toggleEmojiPicker()">⚽</button>
        <input class="profile-new-input" id="team-name-input" type="text" placeholder="Team name…" maxlength="24" oninput="onTeamNameInput()"/>
        <button class="profile-new-save" id="profile-save-btn" onclick="saveNewProfile()" disabled>Save</button>
      </div>
      <div class="emoji-hint">Tap the crest to pick · <span style="cursor:pointer;text-decoration:underline;" onclick="randomEmoji()">randomise</span></div>
      <div class="emoji-grid" id="emoji-grid" style="display:none;"></div>
    </div>
  </div>

  <!-- Primary: Play vs AI — full width, biggest button -->
  <button class="btn-primary" id="start-btn" onclick="startGame()" style="width:100%;max-width:360px;font-size:17px;padding:18px 12px;border-radius:14px;margin-bottom:10px;display:flex;align-items:center;justify-content:center;gap:8px;min-height:62px;" disabled>
    🤖 Play vs AI
  </button>

  <!-- Secondary row: vs Friend + Tutorial -->
  <div style="display:flex;gap:10px;width:100%;max-width:360px;margin-bottom:16px;align-items:stretch;">
    <button class="btn-primary dark" id="mp-btn" onclick="openLobby()" style="flex:2;font-size:15px;padding:16px 12px;border-radius:14px;display:flex;align-items:center;justify-content:center;gap:6px;min-height:52px;" disabled>
      ⚽ Play vs Friend
    </button>
    <button onclick="startTutorial()" style="flex:1;font-size:12px;padding:12px 8px;border-radius:14px;background:#333;color:#fff;border:none;cursor:pointer;font-family:inherit;font-weight:600;letter-spacing:0.5px;min-height:52px;">
      🎓 Tutorial
    </button>
  </div>

  <!-- How to play -->
  <div class="home-rules">
    <div class="home-rules-title">How to play</div>
    <div class="home-rule-step">
      <span class="home-rule-num">1</span>
      <span><strong>Create your profile</strong> above, then hit Practice vs AI or Play vs Friend.</span>
    </div>
    <div class="home-rule-step">
      <span class="home-rule-num">2</span>
      <span><strong>A mystery match from the archives</strong> will fire up — you won't know the score.</span>
    </div>
    <div class="home-rule-step">
      <span class="home-rule-num">3</span>
      <span><strong>A coin toss</strong> decides who picks goalkeeper first. The other keeper goes straight to your opponent.</span>
    </div>
    <div class="home-rule-step">
      <span class="home-rule-num">4</span>
      <span><strong>Draft the worst eleven</strong> you can remember from that game. Who stank the place out?</span>
    </div>
    <div class="home-rule-step">
      <span class="home-rule-num">5</span>
      <span><strong>Sabotage your opponent</strong> — your first 3 picks go to <em>their</em> squad. Send them the stars.</span>
    </div>
  </div>

  <!-- Scoring mechanics -->
  <div class="home-scoring">
    <div class="home-scoring-title">Scoring</div>
    <div class="home-scoring-row"><span class="score-pill pos">+20</span> GK red card</div>
    <div class="home-scoring-row"><span class="score-pill pos">+10</span> Red card (outfield)</div>
    <div class="home-scoring-row"><span class="score-pill pos">+10</span> Own goal / missed pen</div>
    <div class="home-scoring-row"><span class="score-pill pos">+8</span> GK yellow card</div>
    <div class="home-scoring-row"><span class="score-pill pos">+4</span> Yellow card (outfield)</div>
    <div class="home-scoring-row"><span class="score-pill pos">+1–5</span> Subbed off early</div>
    <div class="home-scoring-row"><span class="score-pill neg">−3</span> Playing the full 90'</div>
    <div class="home-scoring-row"><span class="score-pill neg">−3–6</span> Goal scored</div>
    <div class="home-scoring-row"><span class="score-pill neg">−3–6</span> Assist</div>
    <div class="home-scoring-row" style="color:#777;font-size:11px;margin-top:4px;">Higher score wins · goals &amp; assists hurt you</div>
  </div>
</div>

<!-- ═══════════════════════════════════════ LOBBY ═══════════════════════════════════════ -->
<div id="screen-lobby" class="screen">
  <div class="lobby-inner">

    <button class="profile-back-btn" onclick="leaveLobby()" style="align-self:flex-start;margin-bottom:8px;">← Back</button>

    <!-- Phase: choose create or join -->
    <div id="lobby-phase-choose" class="lobby-phase">
      <div class="lobby-title">Play vs Friend</div>
      <div class="lobby-sub">You'll both watch the same match and draft live against each other.</div>
      <button class="lobby-btn" onclick="createGame()">🏟️ Create a game</button>
      <div class="lobby-divider">or</div>
      <div class="lobby-join-row">
        <input class="lobby-code-input" id="join-code-input" type="text" maxlength="4"
          placeholder="Enter code" oninput="this.value=this.value.toUpperCase()"/>
        <button class="lobby-btn-sm" onclick="joinGame()">Join →</button>
      </div>
      <div class="lobby-error" id="lobby-error" style="display:none"></div>
    </div>

    <!-- Phase: waiting room (host) -->
    <div id="lobby-phase-waiting" class="lobby-phase" style="display:none">
      <div class="lobby-title">Game Created</div>
      <div class="lobby-sub">Share this code with your friend</div>
      <div class="lobby-code-display" id="lobby-code-display">—</div>
      <div class="lobby-waiting-status" id="lobby-waiting-status">
        <div class="lobby-player-row">
          <div class="lobby-player-dot ready"></div>
          <span id="lobby-name-a">You</span>
          <span class="lobby-ready-tag">Ready</span>
        </div>
        <div class="lobby-player-row">
          <div class="lobby-player-dot waiting"></div>
          <span id="lobby-name-b">Waiting for opponent…</span>
        </div>
      </div>
      <div class="lobby-hint">Game starts automatically when your friend joins</div>
    </div>

    <!-- Phase: joined (guest) -->
    <div id="lobby-phase-joined" class="lobby-phase" style="display:none">
      <div class="lobby-title">Joined!</div>
      <div class="lobby-sub" id="lobby-joined-sub">Waiting for host to start…</div>
      <div class="lobby-waiting-status" id="lobby-joined-status">
        <div class="lobby-player-row">
          <div class="lobby-player-dot ready"></div>
          <span id="lobby-joined-name-a">Host</span>
          <span class="lobby-ready-tag">Ready</span>
        </div>
        <div class="lobby-player-row">
          <div class="lobby-player-dot ready"></div>
          <span id="lobby-joined-name-b">You</span>
          <span class="lobby-ready-tag">Ready</span>
        </div>
      </div>
      <div class="lobby-hint">Starting shortly…</div>
    </div>

  </div>
</div>

<!-- ═══════════════════════════════════════ PROFILE ═══════════════════════════════════════ -->
<div id="screen-profile" class="screen">
  <div class="profile-header">
    <button class="profile-back-btn" onclick="showScreen('home')">← Back</button>
    <div class="profile-header-main">
      <div class="profile-header-emoji" id="profile-header-emoji">⚽</div>
      <div>
        <div class="profile-name-big" id="profile-name-big">—</div>
        <div class="profile-header-sub" id="profile-header-sub">Member since —</div>
      </div>
    </div>
  </div>
  <div class="profile-body">
    <div class="profile-stat-row">
      <div class="profile-stat-card">
        <div class="profile-stat-num" id="profile-wins">0</div>
        <div class="profile-stat-label">Wins</div>
      </div>
      <div class="profile-stat-card">
        <div class="profile-stat-num" id="profile-played">0</div>
        <div class="profile-stat-label">Played</div>
      </div>
      <div class="profile-stat-card">
        <div class="profile-stat-num" id="profile-winpct">—</div>
        <div class="profile-stat-label">Win %</div>
      </div>
    </div>

    <div class="profile-section">
      <div class="profile-section-title">Form — last 5</div>
      <div class="profile-form-strip" id="profile-form-strip"></div>
    </div>

    <div class="profile-section">
      <div class="profile-section-title">Archive Progress</div>
      <div class="profile-archive-bar-wrap">
        <div class="profile-archive-bar"><div class="profile-archive-fill" id="profile-archive-fill"></div></div>
        <div class="profile-archive-label" id="profile-archive-label">0 / 7 matches played</div>
      </div>
    </div>


    <div class="profile-section">
      <div class="profile-section-title">Badges</div>
      <div class="profile-badges-grid" id="profile-badges-grid"></div>
    </div>

    <button class="profile-delete-btn" onclick="confirmDeleteProfile()">🗑 Delete Profile</button>
  </div>
</div>

<!-- ═══════════════════════════════════════ COIN FLIP ═══════════════════════════════════════ -->
<div id="screen-coin" class="screen">
  <div class="coin-screen-inner">

    <!-- Phase 1: Loading -->
    <div id="coin-phase-loading" class="coin-phase">
      <div class="coin-phase-label">Loading match…</div>
      <div class="coin-loading-tape">📼</div>
      <div class="coin-loading-lines" id="coin-loading-lines">Searching the archives…</div>
    </div>

    <!-- Phase 2: Match reveal -->
    <div id="coin-phase-reveal" class="coin-phase" style="display:none;">
      <div class="coin-phase-label">Today's Match</div>
      <div class="match-badges-row" id="coin-badges-row"></div>
      <div class="coin-reveal-matchup" id="coin-reveal-matchup"></div>
      <div class="coin-reveal-date" id="coin-reveal-date"></div>
      <div class="coin-reveal-blurb" id="coin-reveal-blurb"></div>

      <!-- Reveal tip card -->
      <div class="reveal-tip-card" id="reveal-tip-card">
        <button class="reveal-tip-btn" id="reveal-tip-btn" onclick="revealTip()">
          <span>🔍</span> Reveal a tip
        </button>
        <div class="reveal-tip-cost">−5 pts penalty if you look</div>
        <div class="reveal-tip-content" id="reveal-tip-content" style="display:none"></div>
      </div>

      <div class="coin-countdown-bar">
        <div class="coin-countdown-fill" id="coin-countdown-fill"></div>
      </div>
      <div class="coin-countdown-label" id="coin-countdown-label">Coin flip in 10…</div>
    </div>

    <!-- Phase 3: Coin flip -->
    <div id="coin-phase-flip" class="coin-phase" style="display:none;">
      <div class="coin-phase-label">Coin Flip</div>
      <div id="coin" style="width:100px;height:100px;border-radius:50%;background:white;display:flex;align-items:center;justify-content:center;font-size:48px;transition:transform 0.1s;box-shadow:0 0 0 6px #222;margin:0 auto 32px;">🪙</div>
      <div id="coin-status" style="font-family:'Bebas Neue',sans-serif;font-size:42px;color:white;letter-spacing:2px;min-height:52px;text-align:center;"></div>
      <div id="coin-sub" style="font-size:14px;color:var(--muted);margin-top:8px;min-height:20px;text-align:center;"></div>
    </div>

  </div>
</div>

<!-- ═══════════════════════════════════════ DRAFT ═══════════════════════════════════════ -->
<div id="screen-draft" class="screen">
  <div class="game-header">
    <div class="logo">WORST <span>XI</span></div>
    <div class="match-badge" id="match-badge">DRAFT</div>
  </div>
  <div class="draft-layout">
    <!-- Opponent slots -->
    <div>
      <div class="zone-label" id="opp-zone-label"><span class="dot opponent"></span> Opponent's XI</div>
      <div class="slots-grid" id="opp-slots"></div>
    </div>

    <!-- Middle: carousel + controls -->
    <div class="draft-middle">

      <div class="team-toggle">
        <button class="active" onclick="setTeamFilter('home')" id="toggle-home">Home</button>
        <button onclick="setTeamFilter('away')" id="toggle-away">Away</button>
      </div>

      <div class="sabotage-bar">
        <div class="sabotage-pips" id="sabotage-pips"></div>
        <span id="sabotage-label">3 sabotages remaining</span>
      </div>

      <div class="carousel-container" id="carousel-container">
        <div class="carousel-track" id="carousel-track"></div>
      </div>
      <div class="carousel-hint">← scroll to browse · select to pick</div>

      <!-- Bottom action row: status pill (left) + pick button (right) -->
      <div class="draft-action-row">
        <div class="turn-pill">
          <div class="turn-text" id="turn-text">Your pick</div>
          <div class="timer-ring">
            <svg width="30" height="30" viewBox="0 0 36 36">
              <circle cx="18" cy="18" r="15.9"/>
              <circle class="progress" id="timer-circle" cx="18" cy="18" r="15.9"
                stroke-dasharray="100" stroke-dashoffset="0"/>
            </svg>
            <div class="timer-num" id="timer-num">30</div>
          </div>
        </div>
        <button class="btn-confirm" onclick="draftPlayer()" id="btn-me">Pick Player</button>
        <button style="display:none" id="btn-sabotage"></button>
      </div>

    </div>

    <!-- Your slots -->
    <div>
      <div class="zone-label" id="my-zone-label"><span class="dot yours"></span> Your XI</div>
      <div class="slots-grid" id="my-slots"></div>
    </div>
  </div>
</div>

<!-- ═══════════════════════════════════════ CAPTAIN ═══════════════════════════════════════ -->
<div id="screen-captain" class="screen">
  <div class="captain-header">
    <div class="captain-title">Pick Your Captain</div>
    <div class="captain-sub">Their points will be doubled. Choose wisely — or don't. 😈</div>
  </div>
  <div class="captain-grid" id="captain-grid"></div>
  <div class="captain-footer">
    <div class="captain-hint" id="captain-hint">Tap a player to nominate</div>
    <button class="btn-primary captain-confirm" id="captain-confirm-btn" onclick="confirmCaptain()" disabled>
      Confirm Captain →
    </button>
  </div>
</div>

<!-- ═══════════════════════════════════════ SIMULATION ═══════════════════════════════════════ -->
<div id="screen-sim" class="screen">
  <div class="sim-header">
    <!-- Scoreboard: your name + status vs opponent pts -->
    <div class="sim-scoreboard">
      <div class="sim-player-score">
        <div class="sim-player-label" id="sim-my-label">You</div>
        <div class="sim-score-status" id="sim-my-status">–</div>
      </div>
      <div class="sim-middle">
        <div class="sim-gap-line" id="sim-gap-line"></div>
      </div>
      <div class="sim-player-score" style="text-align:right">
        <div class="sim-player-label">Opponent</div>
        <div class="sim-opp-pts" id="sim-opp-pts"></div>
      </div>
    </div>
    <!-- hidden canvas kept so drawLiveGraph calls don't throw -->
    <canvas id="sim-graph" style="display:none"></canvas>
    <div id="sim-graph-you-label" style="display:none"></div>
    <div id="sim-graph-emoji" style="display:none"></div>
  </div>

  <div class="sim-view-toggle">
    <button onclick="setSimView('me')" id="sim-tab-me">Your XI</button>
    <button class="active" onclick="setSimView('pitch')" id="sim-tab-pitch">⚽ The Pitch</button>
    <button onclick="setSimView('opp')" id="sim-tab-opp">Their XI</button>
  </div>

  <!-- Pitch view -->
  <div class="sim-pitch-wrap active" id="sim-pitch-wrap">
    <div class="pitch-field" id="pitch-field">
      <svg class="pitch-svg" id="pitch-svg" viewBox="0 0 100 160" preserveAspectRatio="none">
        <!-- Outer boundary -->
        <rect x="6" y="4" width="88" height="152" fill="none" stroke="rgba(255,255,255,0.25)" stroke-width="0.8"/>
        <!-- Halfway line -->
        <line x1="6" y1="80" x2="94" y2="80" stroke="rgba(255,255,255,0.25)" stroke-width="0.8"/>
        <!-- Centre circle -->
        <circle cx="50" cy="80" r="12" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="0.8"/>
        <circle cx="50" cy="80" r="0.8" fill="rgba(255,255,255,0.3)"/>
        <!-- Top penalty area (opponent) -->
        <rect x="24" y="4" width="52" height="22" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="0.7"/>
        <!-- Top 6-yard box -->
        <rect x="36" y="4" width="28" height="8" fill="none" stroke="rgba(255,255,255,0.15)" stroke-width="0.6"/>
        <!-- Top penalty spot -->
        <circle cx="50" cy="17" r="0.7" fill="rgba(255,255,255,0.25)"/>
        <!-- Bottom penalty area (you) -->
        <rect x="24" y="134" width="52" height="22" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="0.7"/>
        <!-- Bottom 6-yard box -->
        <rect x="36" y="148" width="28" height="8" fill="none" stroke="rgba(255,255,255,0.15)" stroke-width="0.6"/>
        <!-- Bottom penalty spot -->
        <circle cx="50" cy="143" r="0.7" fill="rgba(255,255,255,0.25)"/>
        <!-- Grass stripe effect (alternating slightly lighter bands) -->
        <rect x="6" y="4"   width="88" height="19" fill="rgba(255,255,255,0.03)"/>
        <rect x="6" y="42"  width="88" height="19" fill="rgba(255,255,255,0.03)"/>
        <rect x="6" y="80"  width="88" height="19" fill="rgba(255,255,255,0.03)"/>
        <rect x="6" y="118" width="88" height="19" fill="rgba(255,255,255,0.03)"/>
      </svg>

      <!-- Tiles injected here by JS -->
    </div>
  </div>

  <div class="sim-players" id="sim-players-list" style="display:none;"></div>

  <!-- Event timeline strip — half 1 | HT | half 2 -->
  <div class="sim-timeline" id="sim-timeline">
    <div class="sim-timeline-halves">
      <!-- First half -->
      <div class="sim-timeline-half" id="tl-half1">
        <div class="sim-timeline-track">
          <div class="sim-timeline-progress" id="tl-progress1" style="width:0%"></div>
        </div>
        <div id="tl-events1"></div>
      </div>
      <!-- HT divider -->
      <div style="display:flex;flex-direction:column;align-items:center;gap:2px;flex-shrink:0">
        <div class="sim-timeline-ht-label">HT</div>
        <div class="sim-timeline-divider"></div>
      </div>
      <!-- Second half -->
      <div class="sim-timeline-half second-half" id="tl-half2">
        <div class="sim-timeline-track">
          <div class="sim-timeline-progress" id="tl-progress2" style="width:0%"></div>
        </div>
        <div id="tl-events2"></div>
      </div>
    </div>
  </div>

  <div class="live-scoreline">
    <span class="live-pill">LIVE</span>
    <span class="live-teams">Man City <strong id="live-home-score">0</strong> – <strong id="live-away-score">0</strong> Watford</span>
    <span class="live-clock" id="match-clock">0'</span>

  </div>

  <div class="commentary-feed" id="commentary-feed">
    <div class="commentary-lines">
      <div class="commentary-line commentary-line-sub" id="commentary-sub" style="display:none"></div>
      <div class="commentary-line" id="commentary">Man City vs Watford kicks off...</div>
    </div>
    <div class="commentary-emoji" id="commentary-emoji">⚽</div>
  </div>

  <!-- Prediction overlay — sits over commentary feed when a moment fires -->
  <div class="prediction-overlay" id="prediction-overlay" style="display:none">
    <div class="prediction-question" id="prediction-question">Does he score?</div>
    <div class="prediction-timer-bar"><div class="prediction-timer-fill" id="prediction-timer-fill"></div></div>
    <div class="prediction-buttons">
      <button class="pred-btn pred-yes" id="pred-btn-a" onclick="submitPrediction(true)">✅ Yes</button>
      <button class="pred-btn pred-no"  id="pred-btn-b" onclick="submitPrediction(false)">❌ No</button>
    </div>
    <div class="pred-scoring-hint">✅ correct +10 · ❌ wrong −5 · skip 0</div>
  </div>

  <!-- 3-option scorer question overlay -->
  <div class="scorer-overlay" id="scorer-overlay" style="display:none">
    <div class="scorer-label" id="scorer-label">⚡ First to answer wins</div>
    <div class="scorer-question" id="scorer-question">Who scored?</div>
    <div class="prediction-timer-bar"><div class="prediction-timer-fill" id="scorer-timer-fill"></div></div>
    <div class="scorer-buttons" id="scorer-buttons"></div>
    <div class="pred-scoring-hint">✅ correct +15 · ❌ wrong −5 · skip 0</div>
  </div>
</div>

<!-- ═══════════════════════════════════════ RESULTS ═══════════════════════════════════════ -->
<div id="screen-results" class="screen">
  <div class="results-header">
    <div class="result-headline" id="result-headline">OMNISHAMBLES</div>
    <div class="result-sub" id="result-sub">Man City 8-0 Watford · 2019</div>
    <div class="results-badges-row" id="results-badges-row"></div>
  </div>

  <div class="results-scores">
    <div class="result-score-card full" id="my-score-card">
      <div class="result-score-label" id="my-score-label">You</div>
      <div class="result-score-emoji" id="my-result-emoji">😬</div>
      <div class="result-outcome" id="my-result-outcome">—</div>
      <div class="result-score-detail" id="my-score-detail"></div>
    </div>
  </div>

  <div class="results-body">
    <div class="result-section">
      <div class="result-section-title">The Rollercoaster</div>
      <div class="result-graph-wrap" style="position:relative;padding-bottom:20px;">
        <div class="result-graph-title">Chaos Delta · 90 Minutes</div>
        <div style="position:relative;">
          <canvas id="result-graph" height="160"></canvas>
          <div id="result-graph-emoji" style="position:absolute;font-size:22px;transform:translate(-50%,-50%);pointer-events:none;transition:all 0.3s;"></div>
        </div>
      </div>
    </div>

    <div class="result-section">
      <div class="result-section-title">Match Report</div>
      <div id="match-report" style="font-size:14px;line-height:1.7;color:#333;"></div>
    </div>

    <div class="result-section">
      <div class="result-section-title">Worst Eleven</div>
      <div id="contributors-list"></div>
    </div>

    <div class="result-section">
      <div class="result-section-title">Badges Earned</div>
      <div class="badges-row" id="badges-list"></div>
    </div>

    <div class="result-section" id="result-form-section" style="display:none">
      <div class="result-section-title" id="result-form-section-title">Your Record</div>
      <div class="result-form-tile">
        <div class="result-form-title">Form — last 5</div>
        <div class="result-form-row" id="result-form-strip"></div>
        <div class="result-form-stats" id="result-form-stats"></div>
        <button class="result-view-profile-btn" onclick="viewActiveProfile()">View Full Profile →</button>
      </div>
    </div>

    <div class="cta-row">
      <button class="cta-rematch" onclick="replayMatch()">↩ Replay</button>
      <button class="cta-newgame" onclick="newGame()">🎲 New Game</button>
      <button class="cta-share" onclick="shareResult()">📤 Share</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>
<div class="pred-result-flash" id="pred-result-flash"></div>
<!-- Half-time interstitial — at root so position:fixed is never clipped -->
<div class="ht-overlay" id="ht-overlay" style="display:none">

  <!-- Phase 1: Half time announcement -->
  <div id="ht-phase-announce" style="display:flex;flex-direction:column;align-items:center;gap:10px">
    <div class="ht-whistle">⏸️</div>
    <div class="ht-label">HALF TIME</div>
    <div class="ht-score" id="ht-score"></div>
    <div class="ht-sub" id="ht-announce-sub">The manager has a suggestion…</div>
  </div>

  <!-- Phase 2: Swap offer UI -->
  <div id="ht-phase-swap" style="display:none;width:100%;flex-direction:column;align-items:center;gap:0;padding:20px 20px 32px">

    <div class="ht-label" style="font-size:28px;margin-bottom:4px">SWAP OFFER</div>
    <div style="font-size:12px;color:#666;text-align:center;margin-bottom:16px;line-height:1.6;max-width:300px">
      The manager sees an opportunity. It'll cost you <strong style="color:#f5c842">−5 pts</strong> to take it.
    </div>

    <!-- Timer bar -->
    <div style="width:100%;max-width:360px;margin-bottom:20px">
      <div style="display:flex;justify-content:space-between;margin-bottom:4px">
        <span style="font-family:'DM Mono',monospace;font-size:10px;color:#555;letter-spacing:1px">DECIDE</span>
        <span id="ht-timer-label" style="font-family:'Bebas Neue',sans-serif;font-size:18px;color:#f5c842">15</span>
      </div>
      <div style="height:3px;background:#222;border-radius:2px;overflow:hidden">
        <div id="ht-timer-bar" style="height:100%;background:#f5c842;width:100%;transition:width 1s linear;border-radius:2px"></div>
      </div>
    </div>

    <!-- The offer card -->
    <div style="width:100%;max-width:340px;background:#111;border-radius:14px;padding:16px;margin-bottom:20px">
      <!-- Send out -->
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px">
        <div style="font-family:'DM Mono',monospace;font-size:9px;letter-spacing:2px;color:#f87171;min-width:60px">SEND OUT</div>
        <div style="flex:1">
          <div id="ht-offer-out-name" style="font-family:'Bebas Neue',sans-serif;font-size:20px;color:white;letter-spacing:0.5px"></div>
          <div id="ht-offer-out-pts" style="font-family:'DM Mono',monospace;font-size:11px;color:#666"></div>
        </div>
        <div style="font-size:20px">↑</div>
      </div>
      <!-- Divider -->
      <div style="height:1px;background:#222;margin-bottom:12px"></div>
      <!-- Bring in -->
      <div style="display:flex;align-items:center;gap:10px">
        <div style="font-family:'DM Mono',monospace;font-size:9px;letter-spacing:2px;color:#4ade80;min-width:60px">BRING IN</div>
        <div style="flex:1">
          <div id="ht-offer-in-name" style="font-family:'Bebas Neue',sans-serif;font-size:20px;color:white;letter-spacing:0.5px"></div>
          <div id="ht-offer-in-pts" style="font-family:'DM Mono',monospace;font-size:11px;color:#666"></div>
        </div>
        <div style="font-size:20px">↓</div>
      </div>
    </div>

    <!-- Accept / Decline buttons -->
    <button id="ht-accept-btn" onclick="acceptHtSwap()" style="width:100%;max-width:340px;background:white;color:black;border:none;border-radius:12px;padding:15px;font-family:'Bebas Neue',sans-serif;font-size:22px;letter-spacing:1px;cursor:pointer;margin-bottom:10px">
      ACCEPT  ·  −5 PTS
    </button>
    <button id="ht-decline-btn" onclick="declineHtSwap()" style="width:100%;max-width:340px;background:transparent;border:1px solid #333;border-radius:12px;padding:14px;font-family:'Bebas Neue',sans-serif;font-size:18px;color:#666;letter-spacing:1px;cursor:pointer">
      NO THANKS
    </button>
  </div>

  <!-- Phase 3: Waiting for opponent (mp only) -->
  <div id="ht-phase-locked" style="display:none;flex-direction:column;align-items:center;gap:12px">
    <div style="font-size:48px">⏳</div>
    <div class="ht-label" style="font-size:28px">WAITING</div>
    <div id="ht-locked-msg" style="font-size:13px;color:#666;text-align:center;max-width:280px;line-height:1.6">Waiting for your opponent…</div>
  </div>

</div>

<script>
// ═══════════════════════════════════════════════════════════════
// MATCH ARCHIVE — 30 historic Premier League matches
// ═══════════════════════════════════════════════════════════════
const ALL_MATCHES = [

  // ── MATCH 1: Man City 8-0 Watford, 21 Sep 2019 ───────────────
  {
    id: 'mci_8-0_wat_2019',
    meta: {
      home: 'Man City', away: 'Watford', score: '8-0', homeColour: '#6CABDD', awayColour: '#FBEE23',
      date: '21 Sep 2019', label: `Premier League · Sat 21 Sep 2019 · 3:00pm BST`,
      blurb: `The Etihad, 3pm. <strong>Man City sit 2nd</strong> (W4 D1 L1, 13 pts) after a shock home loss to Norwich last weekend. <strong>Watford are rock bottom</strong> — winless in six, just 2 points all season. Bernardo Silva and De Bruyne have been in electric form. Deeney leads the line for a Hornets side desperate for a response.`,
      finalCommentary: `<strong>Full time.</strong> Eight goals. A historic, record-equalling rout.`,
      lateCommentary: `Late pressure. Time running out for Watford.`,
    },
    players: [
      { id: 1, name: `Ederson`,     pos: 'GK', team: 'home', teamName: `Man City` },
      { id: 2, name: `Cancelo`,     pos: 'RB', team: 'home', teamName: `Man City` },
      { id: 3, name: `Otamendi`,    pos: 'CB', team: 'home', teamName: `Man City` },
      { id: 4, name: `Fernandinho`, pos: 'CB', team: 'home', teamName: `Man City` },
      { id: 5, name: `Mendy`,       pos: 'LB', team: 'home', teamName: `Man City` },
      { id: 6, name: `Gündogan`,    pos: 'CM', team: 'home', teamName: `Man City` },
      { id: 7, name: `Rodri`,       pos: 'CM', team: 'home', teamName: `Man City` },
      { id: 8, name: `De Bruyne`,   pos: 'AM', team: 'home', teamName: `Man City` },
      { id: 9, name: `Bernardo`,    pos: 'RW', team: 'home', teamName: `Man City` },
      { id:10, name: `Agüero`,      pos: 'ST', team: 'home', teamName: `Man City` },
      { id:11, name: `Mahrez`,      pos: 'LW', team: 'home', teamName: `Man City` },
      { id:12, name: `Foster`,      pos: 'GK', team: 'away', teamName: `Watford` },
      { id:13, name: `Femenia`,     pos: 'RB', team: 'away', teamName: `Watford` },
      { id:14, name: `Kabasele`,    pos: 'CB', team: 'away', teamName: `Watford` },
      { id:15, name: `Cathcart`,    pos: 'CB', team: 'away', teamName: `Watford` },
      { id:16, name: `Masina`,      pos: 'LB', team: 'away', teamName: `Watford` },
      { id:17, name: `Doucoure`,    pos: 'CM', team: 'away', teamName: `Watford` },
      { id:18, name: `Capoue`,      pos: 'CM', team: 'away', teamName: `Watford` },
      { id:19, name: `Hughes`,      pos: 'AM', team: 'away', teamName: `Watford` },
      { id:20, name: `Pereyra`,     pos: 'RW', team: 'away', teamName: `Watford` },
      { id:21, name: `Deeney`,      pos: 'ST', team: 'away', teamName: `Watford` },
      { id:22, name: `Deulofeu`,    pos: 'LW', team: 'away', teamName: `Watford` },
    ],
    events: [
      { min: 12, type: 'goal',    playerId: 10 },
      { min: 21, type: 'assist',  playerId:  8 },
      { min: 21, type: 'goal',    playerId: 10 },
      { min: 24, type: 'goal',    playerId:  9 },
      { min: 34, type: 'yellow',  playerId: 17 },
      { min: 38, type: 'own_goal',playerId: 14 },
      { min: 40, type: 'sub',     playerId: 14 },
      { min: 50, type: 'goal',    playerId:  8 },
      { min: 59, type: 'goal',    playerId: 10 },
      { min: 65, type: 'goal',    playerId: 11 },
      { min: 70, type: 'sub',     playerId: 22 },
      { min: 72, type: 'sub',     playerId: 19 },
      { min: 76, type: 'yellow',  playerId: 21 },
      { min: 80, type: 'goal',    playerId: 10 },
      { min: 85, type: 'goal',    playerId:  9 },
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 2: Leicester 5-3 Man United, 21 Sep 2014 ───────────
  {
    id: 'lei_5-3_mun_2014',
    meta: {
      home: 'Leicester', away: 'Man United', score: '5-3', homeColour: '#003090', awayColour: '#DA291C',
      date: '21 Sep 2014', label: `Premier League · Sun 21 Sep 2014 · 4:00pm BST`,
      blurb: `King Power Stadium. <strong>Van Gaal's United</strong> (W2 D2 L1) have splashed £150m in the summer — Falcao, Di Maria and Van Persie all start. <strong>Leicester sit 16th</strong>, battling to stay up. Vardy has scored once all season. Cambiasso, Schmeichel and Ulloa are the Foxes' best hopes of causing an upset.`,
      finalCommentary: `<strong>Full time.</strong> Leicester 5 United 3. Van Gaal's worst nightmare.`,
      lateCommentary: `Blackett is off! Ten men for United. Leicester smell blood.`,
    },
    players: [
      { id: 1, name: `Schmeichel`,  pos: 'GK', team: 'home', teamName: `Leicester` },
      { id: 2, name: `De Laet`,     pos: 'RB', team: 'home', teamName: `Leicester` },
      { id: 3, name: `Morgan`,      pos: 'CB', team: 'home', teamName: `Leicester` },
      { id: 4, name: `Moore`,       pos: 'CB', team: 'home', teamName: `Leicester` },
      { id: 5, name: `Konchesky`,   pos: 'LB', team: 'home', teamName: `Leicester` },
      { id: 6, name: `Hammond`,     pos: 'CM', team: 'home', teamName: `Leicester` },
      { id: 7, name: `Drinkwater`,  pos: 'CM', team: 'home', teamName: `Leicester` },
      { id: 8, name: `Cambiasso`,   pos: 'AM', team: 'home', teamName: `Leicester` },
      { id: 9, name: `Nugent`,      pos: 'RW', team: 'home', teamName: `Leicester` },
      { id:10, name: `Ulloa`,       pos: 'ST', team: 'home', teamName: `Leicester` },
      { id:11, name: `Vardy`,       pos: 'LW', team: 'home', teamName: `Leicester` },
      { id:12, name: `De Gea`,      pos: 'GK', team: 'away', teamName: `Man United` },
      { id:13, name: `Blackett`,    pos: 'RB', team: 'away', teamName: `Man United` },
      { id:14, name: `Evans`,       pos: 'CB', team: 'away', teamName: `Man United` },
      { id:15, name: `Smalling`,    pos: 'CB', team: 'away', teamName: `Man United` },
      { id:16, name: `Rojo`,        pos: 'LB', team: 'away', teamName: `Man United` },
      { id:17, name: `Blind`,       pos: 'CM', team: 'away', teamName: `Man United` },
      { id:18, name: `Herrera`,     pos: 'CM', team: 'away', teamName: `Man United` },
      { id:19, name: `Di Maria`,    pos: 'RW', team: 'away', teamName: `Man United` },
      { id:20, name: `Rooney`,      pos: 'AM', team: 'away', teamName: `Man United` },
      { id:21, name: `Van Persie`,  pos: 'ST', team: 'away', teamName: `Man United` },
      { id:22, name: `Falcao`,      pos: 'LW', team: 'away', teamName: `Man United` },
    ],
    events: [
      { min: 13, type: 'goal',     playerId: 21 },
      { min: 16, type: 'assist',   playerId: 20 },
      { min: 16, type: 'goal',     playerId: 19 },
      { min: 17, type: 'goal',     playerId: 10 },
      { min: 57, type: 'goal',     playerId: 18 },
      { min: 62, type: 'goal',     playerId:  9 },  // pen
      { min: 64, type: 'goal',     playerId:  8 },
      { min: 72, type: 'sub',      playerId: 22 },
      { min: 75, type: 'sub',      playerId:  9 },
      { min: 76, type: 'sub',      playerId: 19 },
      { min: 79, type: 'assist',   playerId:  2 },
      { min: 79, type: 'goal',     playerId: 11 },
      { min: 83, type: 'red',      playerId: 13 },
      { min: 83, type: 'goal',     playerId: 10 },  // pen
      { min: 85, type: 'sub',      playerId: 11 },
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 3: Arsenal 2-8 Man United, 28 Aug 2011 ─────────────
  {
    id: 'ars_2-8_mun_2011',
    meta: {
      home: 'Arsenal', away: 'Man United', score: '2-8', homeColour: '#EF0107', awayColour: '#DA291C', awayColourAlt: '#FFD700',
      date: '28 Aug 2011', label: `Premier League · Sun 28 Aug 2011 · 4:00pm BST`,
      blurb: `The Emirates. <strong>Arsenal are missing eight first-teamers</strong> through injury — Fabregas, Nasri, Rosický, Diaby and more. <strong>Ferguson's United</strong> sit 2nd and are in ruthless early-season form. Young and Welbeck have been sharp all summer. Arsenal's young, depleted backline faces a stern test.`,
      finalCommentary: `<strong>Full time.</strong> Arsenal 2 United 8. The most humiliating home defeat in Arsenal's modern history.`,
      lateCommentary: `Arsenal are broken. United smell more blood.`,
    },
    players: [
      { id: 1, name: `Szczesny`,   pos: 'GK', team: 'home', teamName: `Arsenal` },
      { id: 2, name: `Jenkinson`,  pos: 'RB', team: 'home', teamName: `Arsenal` },
      { id: 3, name: `Djourou`,    pos: 'CB', team: 'home', teamName: `Arsenal` },
      { id: 4, name: `Koscielny`,  pos: 'CB', team: 'home', teamName: `Arsenal` },
      { id: 5, name: `Traore`,     pos: 'LB', team: 'home', teamName: `Arsenal` },
      { id: 6, name: `Coquelin`,   pos: 'CM', team: 'home', teamName: `Arsenal` },
      { id: 7, name: `Ramsey`,     pos: 'CM', team: 'home', teamName: `Arsenal` },
      { id: 8, name: `Walcott`,    pos: 'RW', team: 'home', teamName: `Arsenal` },
      { id: 9, name: `Rosicky`,    pos: 'AM', team: 'home', teamName: `Arsenal` },
      { id:10, name: `Arshavin`,   pos: 'LW', team: 'home', teamName: `Arsenal` },
      { id:11, name: `Van Persie`, pos: 'ST', team: 'home', teamName: `Arsenal` },
      { id:12, name: `De Gea`,     pos: 'GK', team: 'away', teamName: `Man United` },
      { id:13, name: `Smalling`,   pos: 'RB', team: 'away', teamName: `Man United` },
      { id:14, name: `Jones`,      pos: 'CB', team: 'away', teamName: `Man United` },
      { id:15, name: `Evans`,      pos: 'CB', team: 'away', teamName: `Man United` },
      { id:16, name: `Evra`,       pos: 'LB', team: 'away', teamName: `Man United` },
      { id:17, name: `Anderson`,   pos: 'CM', team: 'away', teamName: `Man United` },
      { id:18, name: `Cleverley`,  pos: 'CM', team: 'away', teamName: `Man United` },
      { id:19, name: `Nani`,       pos: 'RW', team: 'away', teamName: `Man United` },
      { id:20, name: `Young`,      pos: 'AM', team: 'away', teamName: `Man United` },
      { id:21, name: `Rooney`,     pos: 'ST', team: 'away', teamName: `Man United` },
      { id:22, name: `Welbeck`,    pos: 'LW', team: 'away', teamName: `Man United` },
    ],
    events: [
      { min: 22, type: 'goal',    playerId: 22 },
      { min: 28, type: 'assist',  playerId: 16 },
      { min: 28, type: 'goal',    playerId: 20 },
      { min: 34, type: 'sub',     playerId: 22 },  // Welbeck off injured
      { min: 41, type: 'goal',    playerId: 21 },  // free kick
      { min: 45, type: 'goal',    playerId:  8 },  // Walcott pulls one back
      { min: 64, type: 'goal',    playerId: 21 },  // free kick
      { min: 67, type: 'goal',    playerId: 19 },
      { min: 67, type: 'sub',     playerId: 17 },  // Anderson off
      { min: 70, type: 'goal',    playerId: 20 },  // Young gets one
      { min: 74, type: 'goal',    playerId: 11 },  // Van Persie pulls one back
      { min: 82, type: 'goal',    playerId: 21 },  // pen — hat-trick
      { min: 83, type: 'red',     playerId:  2 },  // Jenkinson red
      { min: 83, type: 'sub',     playerId: 11 },  // Van Persie off
      { min: 90, type: 'goal',    playerId: 20 },  // Young completes 8
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 4: Liverpool 4-3 Newcastle, 3 Apr 1996 ─────────────
  {
    id: 'liv_4-3_new_1996',
    meta: {
      home: 'Liverpool', away: 'Newcastle', score: '4-3', homeColour: '#C8102E', awayColour: '#241F20',
      date: '3 Apr 1996', label: `Premier League · Wed 3 Apr 1996 · 8:00pm BST`,
      blurb: `Anfield, April 1996. <strong>Newcastle lead the title race by a point</strong> with five games left — Keegan's men have been imperious all season. <strong>Liverpool sit 3rd</strong>, out of the title hunt but dangerous at home. Fowler has 28 goals. Asprilla and Ferdinand up top for the Magpies. A top-four clash with huge implications.`,
      finalCommentary: `<strong>Full time.</strong> Liverpool 4 Newcastle 3. Collymore wheels away. Keegan sinks to his knees.`,
      lateCommentary: `Collymore breaks away — GOAL! The stadium erupts!`,
    },
    players: [
      { id: 1, name: `James`,       pos: 'GK', team: 'home', teamName: `Liverpool` },
      { id: 2, name: `Jones`,       pos: 'RB', team: 'home', teamName: `Liverpool` },
      { id: 3, name: `Scales`,      pos: 'CB', team: 'home', teamName: `Liverpool` },
      { id: 4, name: `Wright`,      pos: 'CB', team: 'home', teamName: `Liverpool` },
      { id: 5, name: `Bjornebye`,   pos: 'LB', team: 'home', teamName: `Liverpool` },
      { id: 6, name: `McAteer`,     pos: 'CM', team: 'home', teamName: `Liverpool` },
      { id: 7, name: `Redknapp`,    pos: 'CM', team: 'home', teamName: `Liverpool` },
      { id: 8, name: `Barnes`,      pos: 'AM', team: 'home', teamName: `Liverpool` },
      { id: 9, name: `McManaman`,   pos: 'RW', team: 'home', teamName: `Liverpool` },
      { id:10, name: `Fowler`,      pos: 'ST', team: 'home', teamName: `Liverpool` },
      { id:11, name: `Collymore`,   pos: 'LW', team: 'home', teamName: `Liverpool` },
      { id:12, name: `Srnicek`,     pos: 'GK', team: 'away', teamName: `Newcastle` },
      { id:13, name: `Watson`,      pos: 'RB', team: 'away', teamName: `Newcastle` },
      { id:14, name: `Howey`,       pos: 'CB', team: 'away', teamName: `Newcastle` },
      { id:15, name: `Albert`,      pos: 'CB', team: 'away', teamName: `Newcastle` },
      { id:16, name: `Beresford`,   pos: 'LB', team: 'away', teamName: `Newcastle` },
      { id:17, name: `Batty`,       pos: 'CM', team: 'away', teamName: `Newcastle` },
      { id:18, name: `Lee`,         pos: 'CM', team: 'away', teamName: `Newcastle` },
      { id:19, name: `Beardsley`,   pos: 'AM', team: 'away', teamName: `Newcastle` },
      { id:20, name: `Ginola`,      pos: 'RW', team: 'away', teamName: `Newcastle` },
      { id:21, name: `Ferdinand`,   pos: 'ST', team: 'away', teamName: `Newcastle` },
      { id:22, name: `Asprilla`,    pos: 'LW', team: 'away', teamName: `Newcastle` },
    ],
    events: [
      { min:  2, type: 'goal',    playerId: 10 },  // Fowler heads in
      { min:  2, type: 'assist',  playerId:  7 },  // Redknapp — cross from Collymore, but Redknapp started move
      { min: 10, type: 'goal',    playerId: 21 },  // Ferdinand equalises
      { min: 14, type: 'goal',    playerId: 20 },  // Ginola — Newcastle lead
      { min: 35, type: 'yellow',  playerId: 19 },  // Beardsley booked
      { min: 40, type: 'yellow',  playerId: 17 },  // Batty booked — foul on McManaman
      { min: 45, type: 'sub',     playerId:  4 },  // Wright off at half time (replaced by Harkness)
      { min: 55, type: 'goal',    playerId: 10 },  // Fowler levels — 2-2
      { min: 55, type: 'assist',  playerId:  6 },  // McAteer played it to McManaman who found Fowler
      { min: 57, type: 'goal',    playerId: 22 },  // Asprilla — Newcastle ahead again
      { min: 68, type: 'goal',    playerId: 11 },  // Collymore 3-3
      { min: 68, type: 'assist',  playerId:  6 },  // McAteer\'s curling cross
      { min: 76, type: 'sub',     playerId:  2 },  // Rob Jones off — Rush on
      { min: 90, type: 'goal',    playerId: 11 },  // Collymore winner — 4-3
      { min: 90, type: 'assist',  playerId:  8 },  // Barnes played it to Collymore
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 5: West Ham 2-3 Tottenham, 23 Nov 2019 ─────────────
  {
    id: 'whu_2-3_tot_2019',
    meta: {
      home: 'West Ham', away: 'Tottenham', score: '2-3', homeColour: '#7A263A', awayColour: '#132257',
      date: '23 Nov 2019', label: `Premier League · Sat 23 Nov 2019 · 3:00pm BST`,
      blurb: `London Stadium. <strong>Jose Mourinho was appointed Spurs manager 48 hours ago.</strong> He inherits a squad that hasn't won away in the league since January. <strong>West Ham sit 17th</strong> and need a result badly. Son, Kane and Moura lead Spurs' attack. Antonio is West Ham's most dangerous outlet.`,
      finalCommentary: `<strong>Full time.</strong> West Ham 2 Tottenham 3. Jose's first game. Three points. Pandemonium.`,
      lateCommentary: `Ogbonna scrambles one back — West Ham alive! But is it too late?`,
    },
    players: [
      { id: 1, name: `Roberto`,     pos: 'GK', team: 'home', teamName: `West Ham` },
      { id: 2, name: `Fredericks`,  pos: 'RB', team: 'home', teamName: `West Ham` },
      { id: 3, name: `Diop`,        pos: 'CB', team: 'home', teamName: `West Ham` },
      { id: 4, name: `Ogbonna`,     pos: 'CB', team: 'home', teamName: `West Ham` },
      { id: 5, name: `Cresswell`,   pos: 'LB', team: 'home', teamName: `West Ham` },
      { id: 6, name: `Rice`,        pos: 'CM', team: 'home', teamName: `West Ham` },
      { id: 7, name: `Noble`,       pos: 'CM', team: 'home', teamName: `West Ham` },
      { id: 8, name: `Snodgrass`,   pos: 'RW', team: 'home', teamName: `West Ham` },
      { id: 9, name: `Anderson`,    pos: 'AM', team: 'home', teamName: `West Ham` },
      { id:10, name: `Yarmolenko`,  pos: 'LW', team: 'home', teamName: `West Ham` },
      { id:11, name: `Haller`,      pos: 'ST', team: 'home', teamName: `West Ham` },
      { id:12, name: `Gazzaniga`,   pos: 'GK', team: 'away', teamName: `Tottenham` },
      { id:13, name: `Aurier`,      pos: 'RB', team: 'away', teamName: `Tottenham` },
      { id:14, name: `Alderweireld`,pos: 'CB', team: 'away', teamName: `Tottenham` },
      { id:15, name: `Sanchez`,     pos: 'CB', team: 'away', teamName: `Tottenham` },
      { id:16, name: `Davies`,      pos: 'LB', team: 'away', teamName: `Tottenham` },
      { id:17, name: `Dier`,        pos: 'CM', team: 'away', teamName: `Tottenham` },
      { id:18, name: `Winks`,       pos: 'CM', team: 'away', teamName: `Tottenham` },
      { id:19, name: `Moura`,       pos: 'RW', team: 'away', teamName: `Tottenham` },
      { id:20, name: `Alli`,        pos: 'AM', team: 'away', teamName: `Tottenham` },
      { id:21, name: `Son`,         pos: 'LW', team: 'away', teamName: `Tottenham` },
      { id:22, name: `Kane`,        pos: 'ST', team: 'away', teamName: `Tottenham` },
    ],
    events: [
      { min: 36, type: 'assist',  playerId: 20 },
      { min: 36, type: 'goal',    playerId: 21 },  // Son
      { min: 43, type: 'goal',    playerId: 19 },  // Moura
      { min: 49, type: 'goal',    playerId: 22 },  // Kane header
      { min: 65, type: 'sub',     playerId:  9 },  // Anderson off
      { min: 73, type: 'goal',    playerId:  4 },  // Ogbonna own goal — actually Antonio, fix below
      { min: 73, type: 'yellow',  playerId:  3 },  // Diop
      { min: 85, type: 'sub',     playerId: 18 },  // Winks off
      { min: 90, type: 'goal',    playerId:  4 },  // Ogbonna — 2-3
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 6: Newcastle 5-1 Sunderland, 31 Oct 2010 ───────────
  {
    id: 'new_5-1_sun_2010',
    meta: {
      home: 'Newcastle', away: 'Sunderland', score: '5-1', homeColour: '#241F20', awayColour: '#EB172B',
      date: '31 Oct 2010', label: `Premier League · Sun 31 Oct 2010 · 1:30pm GMT`,
      blurb: `St James' Park, Halloween. <strong>The Tyne-Wear derby.</strong> Newcastle sit 11th, Sunderland 10th — just two points between them. <strong>Nolan has been Newcastle's talisman</strong> all season, leading the line with Carroll. Darren Bent has been sharp for Sunderland. These derbies always produce drama.`,
      finalCommentary: `<strong>Full time.</strong> Newcastle 5 Sunderland 1. Happy Halloween, Mackems.`,
      lateCommentary: `Newcastle pushing for more. St James' Park is delirious.`,
    },
    players: [
      { id: 1, name: `Krul`,        pos: 'GK', team: 'home', teamName: `Newcastle` },
      { id: 2, name: `Simpson`,     pos: 'RB', team: 'home', teamName: `Newcastle` },
      { id: 3, name: `Coloccini`,   pos: 'CB', team: 'home', teamName: `Newcastle` },
      { id: 4, name: `Williamson`,  pos: 'CB', team: 'home', teamName: `Newcastle` },
      { id: 5, name: `Enrique`,     pos: 'LB', team: 'home', teamName: `Newcastle` },
      { id: 6, name: `Barton`,      pos: 'CM', team: 'home', teamName: `Newcastle` },
      { id: 7, name: `Tiote`,       pos: 'CM', team: 'home', teamName: `Newcastle` },
      { id: 8, name: `Gutierrez`,   pos: 'AM', team: 'home', teamName: `Newcastle` },
      { id: 9, name: `Nolan`,       pos: 'RW', team: 'home', teamName: `Newcastle` },
      { id:10, name: `Ameobi`,      pos: 'ST', team: 'home', teamName: `Newcastle` },
      { id:11, name: `Carroll`,     pos: 'LW', team: 'home', teamName: `Newcastle` },
      { id:12, name: `Mignolet`,    pos: 'GK', team: 'away', teamName: `Sunderland` },
      { id:13, name: `Bardsley`,    pos: 'RB', team: 'away', teamName: `Sunderland` },
      { id:14, name: `Bramble`,     pos: 'CB', team: 'away', teamName: `Sunderland` },
      { id:15, name: `Onuoha`,      pos: 'CB', team: 'away', teamName: `Sunderland` },
      { id:16, name: `Turner`,      pos: 'LB', team: 'away', teamName: `Sunderland` },
      { id:17, name: `Cattermole`,  pos: 'CM', team: 'away', teamName: `Sunderland` },
      { id:18, name: `Henderson`,   pos: 'CM', team: 'away', teamName: `Sunderland` },
      { id:19, name: `Elmohamady`, pos: 'RW', team: 'away', teamName: `Sunderland` },
      { id:20, name: `Malbranque`,  pos: 'AM', team: 'away', teamName: `Sunderland` },
      { id:21, name: `Bent`,        pos: 'ST', team: 'away', teamName: `Sunderland` },
      { id:22, name: `Welbeck`,     pos: 'LW', team: 'away', teamName: `Sunderland` },
    ],
    events: [
      { min: 26, type: 'goal',    playerId:  9 },  // Nolan 1
      { min: 34, type: 'goal',    playerId:  9 },  // Nolan 2
      { min: 40, type: 'sub',     playerId: 19 },  // Elmohamady off
      { min: 45, type: 'goal',    playerId: 10 },  // Ameobi pen
      { min: 55, type: 'red',     playerId: 14 },  // Bramble red
      { min: 55, type: 'sub',     playerId: 22 },  // Welbeck off
      { min: 70, type: 'goal',    playerId: 10 },  // Ameobi
      { min: 75, type: 'goal',    playerId:  9 },  // Nolan hat-trick
      { min: 76, type: 'sub',     playerId: 17 },  // Cattermole off
      { min: 86, type: 'sub',     playerId: 10 },  // Ameobi off
      { min: 90, type: 'goal',    playerId: 21 },  // Bent consolation
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 7: Newcastle 4-4 Arsenal, 5 Feb 2011 ───────────────
  {
    id: 'new_4-4_ars_2011',
    meta: {
      home: 'Newcastle', away: 'Arsenal', score: '4-4', homeColour: '#241F20', awayColour: '#EF0107',
      date: '5 Feb 2011', label: `Premier League · Sat 5 Feb 2011 · 3:00pm GMT`,
      blurb: `St James' Park, February 2011. <strong>Arsenal sit top of the Premier League</strong> (W16 D4 L2) chasing their first title since the Invincibles. Van Persie and Walcott are in blistering form. <strong>Newcastle are 12th</strong> but feisty at home — Nolan and Tiote in the engine room, Carroll leading the line. Diaby starts for the Gunners.`,
      finalCommentary: `<strong>Full time.</strong> Newcastle 4 Arsenal 4. Tiote's volley. They'll talk about this forever.`,
      lateCommentary: `TIOTE! What a volley! 4-4! St James' Park has lost its mind!`,
    },
    players: [
      { id: 1, name: `Harper`,      pos: 'GK', team: 'home', teamName: `Newcastle` },
      { id: 2, name: `Simpson`,     pos: 'RB', team: 'home', teamName: `Newcastle` },
      { id: 3, name: `Coloccini`,   pos: 'CB', team: 'home', teamName: `Newcastle` },
      { id: 4, name: `Williamson`,  pos: 'CB', team: 'home', teamName: `Newcastle` },
      { id: 5, name: `Jose Enrique`,pos: 'LB', team: 'home', teamName: `Newcastle` },
      { id: 6, name: `Barton`,      pos: 'CM', team: 'home', teamName: `Newcastle` },
      { id: 7, name: `Tiote`,       pos: 'CM', team: 'home', teamName: `Newcastle` },
      { id: 8, name: `Gutierrez`,   pos: 'AM', team: 'home', teamName: `Newcastle` },
      { id: 9, name: `Nolan`,       pos: 'RW', team: 'home', teamName: `Newcastle` },
      { id:10, name: `Best`,        pos: 'ST', team: 'home', teamName: `Newcastle` },
      { id:11, name: `Carroll`,     pos: 'LW', team: 'home', teamName: `Newcastle` },
      { id:12, name: `Szczesny`,    pos: 'GK', team: 'away', teamName: `Arsenal` },
      { id:13, name: `Sagna`,       pos: 'RB', team: 'away', teamName: `Arsenal` },
      { id:14, name: `Djourou`,     pos: 'CB', team: 'away', teamName: `Arsenal` },
      { id:15, name: `Koscielny`,   pos: 'CB', team: 'away', teamName: `Arsenal` },
      { id:16, name: `Clichy`,      pos: 'LB', team: 'away', teamName: `Arsenal` },
      { id:17, name: `Song`,        pos: 'CM', team: 'away', teamName: `Arsenal` },
      { id:18, name: `Wilshere`,    pos: 'CM', team: 'away', teamName: `Arsenal` },
      { id:19, name: `Walcott`,     pos: 'RW', team: 'away', teamName: `Arsenal` },
      { id:20, name: `Nasri`,       pos: 'AM', team: 'away', teamName: `Arsenal` },
      { id:21, name: `Arshavin`,    pos: 'LW', team: 'away', teamName: `Arsenal` },
      { id:22, name: `Van Persie`,  pos: 'ST', team: 'away', teamName: `Arsenal` },
    ],
    events: [
      { min:  3, type: 'goal',    playerId: 22 },  // Van Persie — Arsenal 0-1
      { min:  8, type: 'yellow',  playerId:  6 },  // Barton — early booking (tutorial: shows +pts)
      { min: 10, type: 'goal',    playerId: 21 },  // Arshavin — 0-2
      { min: 26, type: 'assist',  playerId: 22 },
      { min: 26, type: 'goal',    playerId: 19 },  // Walcott — 0-3
      { min: 38, type: 'goal',    playerId: 22 },  // Van Persie — 0-4 — Arsenal flying
      { min: 53, type: 'goal',    playerId:  9 },  // Nolan — 1-4
      { min: 68, type: 'goal',    playerId: 10 },  // Best — 2-4
      { min: 69, type: 'yellow',  playerId: 17 },  // Song booked
      { min: 75, type: 'goal',    playerId:  9 },  // Nolan — 3-4
      { min: 80, type: 'sub',     playerId: 11 },  // Carroll off
      { min: 87, type: 'goal',    playerId:  7 },  // Tiote screamer — 4-4!
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 8: Manchester United 8-2 Arsenal, 28 Aug 2011 ──────
  {
    id: 'mun_8-2_ars_2011',
    meta: {
      home: 'Man United', away: 'Arsenal', score: '8-2', homeColour: '#DA291C', awayColour: '#EF0107',
      date: '28 Aug 2011', label: `Premier League · Sun 28 Aug 2011 · 1:30pm BST`,
      blurb: `Old Trafford. <strong>Arsenal arrived in turmoil</strong> — Cesc Fàbregas sold to Barcelona, Nasri to Man City, no net spend. <strong>Ferguson's United were champions</strong> and ruthless at home. Young and Welbeck sharp all summer. Arsenal's depleted, fragile backline faces a stern test against the best team in England.`,
      finalCommentary: `<strong>Full time.</strong> Manchester United 8–2 Arsenal. The scoreline that defined a summer.`,
      lateCommentary: `Young with another. Eight. This is extraordinary.`,
    },
    players: [
      { id:  1, name: `De Gea`,       pos: 'GK', team: 'home', teamName: `Man United` },
      { id:  2, name: `Smalling`,     pos: 'CB', team: 'home', teamName: `Man United` },
      { id:  3, name: `Ferdinand`,    pos: 'CB', team: 'home', teamName: `Man United` },
      { id:  4, name: `Evra`,         pos: 'LB', team: 'home', teamName: `Man United` },
      { id:  5, name: `Fabio`,        pos: 'RB', team: 'home', teamName: `Man United` },
      { id:  6, name: `Carrick`,      pos: 'CM', team: 'home', teamName: `Man United` },
      { id:  7, name: `Anderson`,     pos: 'CM', team: 'home', teamName: `Man United` },
      { id:  8, name: `Nani`,         pos: 'RW', team: 'home', teamName: `Man United` },
      { id:  9, name: `Ashley Young`, pos: 'LW', team: 'home', teamName: `Man United` },
      { id: 10, name: `Rooney`,       pos: 'AM', team: 'home', teamName: `Man United` },
      { id: 11, name: `Welbeck`,      pos: 'ST', team: 'home', teamName: `Man United` },
      { id: 12, name: `Szczesny`,     pos: 'GK', team: 'away', teamName: `Arsenal` },
      { id: 13, name: `Sagna`,        pos: 'RB', team: 'away', teamName: `Arsenal` },
      { id: 14, name: `Koscielny`,    pos: 'CB', team: 'away', teamName: `Arsenal` },
      { id: 15, name: `Djourou`,      pos: 'CB', team: 'away', teamName: `Arsenal` },
      { id: 16, name: `Gibbs`,        pos: 'LB', team: 'away', teamName: `Arsenal` },
      { id: 17, name: `Song`,         pos: 'DM', team: 'away', teamName: `Arsenal` },
      { id: 18, name: `Ramsey`,       pos: 'CM', team: 'away', teamName: `Arsenal` },
      { id: 19, name: `Walcott`,      pos: 'RW', team: 'away', teamName: `Arsenal` },
      { id: 20, name: `Arshavin`,     pos: 'LW', team: 'away', teamName: `Arsenal` },
      { id: 21, name: `Oxlade-Chamberlain`, pos: 'AM', team: 'away', teamName: `Arsenal` },
      { id: 22, name: `Van Persie`,   pos: 'ST', team: 'away', teamName: `Arsenal` },
    ],
    events: [
      { min:  3, type: 'goal',    playerId:  9 },  // Young
      { min: 22, type: 'goal',    playerId: 22 },  // Van Persie pen
      { min: 25, type: 'goal',    playerId: 10 },  // Rooney
      { min: 29, type: 'goal',    playerId: 22 },  // Van Persie
      { min: 34, type: 'red',     playerId: 17 },  // Song red card
      { min: 44, type: 'goal',    playerId: 10 },  // Rooney
      { min: 64, type: 'goal',    playerId: 10 },  // Rooney hat-trick
      { min: 66, type: 'red',     playerId: 15 },  // Djourou red
      { min: 67, type: 'goal',    playerId:  9 },  // Young
      { min: 69, type: 'goal',    playerId:  8 },  // Nani
      { min: 71, type: 'goal',    playerId: 11 },  // Welbeck
      { min: 86, type: 'goal',    playerId: 10 },  // Park (sub) — using Rooney id
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 9: Leicester 9-0 Southampton, 25 Oct 2019 ──────────
  {
    id: 'lei_9-0_sou_2019',
    meta: {
      home: 'Leicester', away: 'Southampton', score: '9-0', homeColour: '#003090', awayColour: '#D71920',
      date: '25 Oct 2019', label: `Premier League · Fri 25 Oct 2019 · 8:00pm BST`,
      blurb: `King Power Stadium. <strong>Southampton were in freefall</strong> — one win in eight, Hasenhüttl under enormous pressure. <strong>Leicester were flying under Brendan Rodgers</strong>, with Vardy and Pérez in frightening form. An away side in crisis visiting a team at full throttle.`,
      finalCommentary: `<strong>Full time.</strong> Leicester 9–0 Southampton. A Premier League record. Pérez with a hat-trick.`,
      lateCommentary: `Another one! The crowd can't believe what they're watching!`,
    },
    players: [
      { id:  1, name: `Schmeichel`,  pos: 'GK', team: 'home', teamName: `Leicester` },
      { id:  2, name: `Ricardo`,     pos: 'RB', team: 'home', teamName: `Leicester` },
      { id:  3, name: `Evans`,       pos: 'CB', team: 'home', teamName: `Leicester` },
      { id:  4, name: `Söyüncü`,     pos: 'CB', team: 'home', teamName: `Leicester` },
      { id:  5, name: `Chilwell`,    pos: 'LB', team: 'home', teamName: `Leicester` },
      { id:  6, name: `Ndidi`,       pos: 'DM', team: 'home', teamName: `Leicester` },
      { id:  7, name: `Tielemans`,   pos: 'CM', team: 'home', teamName: `Leicester` },
      { id:  8, name: `Praet`,       pos: 'CM', team: 'home', teamName: `Leicester` },
      { id:  9, name: `Pérez`,       pos: 'RW', team: 'home', teamName: `Leicester` },
      { id: 10, name: `Maddison`,    pos: 'AM', team: 'home', teamName: `Leicester` },
      { id: 11, name: `Vardy`,       pos: 'ST', team: 'home', teamName: `Leicester` },
      { id: 12, name: `Gunn`,        pos: 'GK', team: 'away', teamName: `Southampton` },
      { id: 13, name: `Cedric`,      pos: 'RB', team: 'away', teamName: `Southampton` },
      { id: 14, name: `Bednarek`,    pos: 'CB', team: 'away', teamName: `Southampton` },
      { id: 15, name: `Vestergaard`, pos: 'CB', team: 'away', teamName: `Southampton` },
      { id: 16, name: `Bertrand`,    pos: 'LB', team: 'away', teamName: `Southampton` },
      { id: 17, name: `Ward-Prowse`, pos: 'CM', team: 'away', teamName: `Southampton` },
      { id: 18, name: `Romeu`,       pos: 'DM', team: 'away', teamName: `Southampton` },
      { id: 19, name: `Armstrong`,   pos: 'RW', team: 'away', teamName: `Southampton` },
      { id: 20, name: `Djenepo`,     pos: 'LW', team: 'away', teamName: `Southampton` },
      { id: 21, name: `Hojbjerg`,    pos: 'AM', team: 'away', teamName: `Southampton` },
      { id: 22, name: `Ings`,        pos: 'ST', team: 'away', teamName: `Southampton` },
    ],
    events: [
      { min:  6, type: 'goal',    playerId: 11 },  // Vardy
      { min: 10, type: 'goal',    playerId:  9 },  // Pérez
      { min: 23, type: 'goal',    playerId:  7 },  // Tielemans
      { min: 38, type: 'goal',    playerId:  9 },  // Pérez
      { min: 41, type: 'red',     playerId: 18 },  // Romeu red
      { min: 54, type: 'goal',    playerId: 11 },  // Vardy
      { min: 56, type: 'goal',    playerId: 10 },  // Maddison
      { min: 63, type: 'goal',    playerId:  9 },  // Pérez hat-trick
      { min: 76, type: 'goal',    playerId:  7 },  // Tielemans
      { min: 80, type: 'goal',    playerId:  5 },  // Chilwell
      { min: 84, type: 'goal',    playerId:  8 },  // Praet
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 10: Liverpool 9-0 Bournemouth, 27 Aug 2022 ─────────
  {
    id: 'liv_9-0_bou_2022',
    meta: {
      home: 'Liverpool', away: 'Bournemouth', score: '9-0', homeColour: '#C8102E', awayColour: '#DA291C',
      date: '27 Aug 2022', label: `Premier League · Sat 27 Aug 2022 · 3:00pm BST`,
      blurb: `Anfield. <strong>Liverpool were stuttering</strong> — three draws in their opening three games, already under pressure. <strong>Bournemouth were newly promoted</strong> and untested at this level. Klopp needed a response. Núñez is on the bench, waiting for his debut.`,
      finalCommentary: `<strong>Full time.</strong> Liverpool 9–0 Bournemouth. A Premier League record equalled.`,
      lateCommentary: `Nine! Liverpool are relentless. Anfield in raptures.`,
    },
    players: [
      { id:  1, name: `Alisson`,     pos: 'GK', team: 'home', teamName: `Liverpool` },
      { id:  2, name: `Alexander-Arnold`, pos: 'RB', team: 'home', teamName: `Liverpool` },
      { id:  3, name: `Matip`,       pos: 'CB', team: 'home', teamName: `Liverpool` },
      { id:  4, name: `Van Dijk`,    pos: 'CB', team: 'home', teamName: `Liverpool` },
      { id:  5, name: `Robertson`,   pos: 'LB', team: 'home', teamName: `Liverpool` },
      { id:  6, name: `Fabinho`,     pos: 'DM', team: 'home', teamName: `Liverpool` },
      { id:  7, name: `Thiago`,      pos: 'CM', team: 'home', teamName: `Liverpool` },
      { id:  8, name: `Henderson`,   pos: 'CM', team: 'home', teamName: `Liverpool` },
      { id:  9, name: `Salah`,       pos: 'RW', team: 'home', teamName: `Liverpool` },
      { id: 10, name: `Firmino`,     pos: 'ST', team: 'home', teamName: `Liverpool` },
      { id: 11, name: `Luis Díaz`,   pos: 'LW', team: 'home', teamName: `Liverpool` },
      { id: 12, name: `Neto`,        pos: 'GK', team: 'away', teamName: `Bournemouth` },
      { id: 13, name: `Smith`,       pos: 'RB', team: 'away', teamName: `Bournemouth` },
      { id: 14, name: `Mepham`,      pos: 'CB', team: 'away', teamName: `Bournemouth` },
      { id: 15, name: `Kelly`,       pos: 'CB', team: 'away', teamName: `Bournemouth` },
      { id: 16, name: `Zemura`,      pos: 'LB', team: 'away', teamName: `Bournemouth` },
      { id: 17, name: `Cook`,        pos: 'DM', team: 'away', teamName: `Bournemouth` },
      { id: 18, name: `Lerma`,       pos: 'CM', team: 'away', teamName: `Bournemouth` },
      { id: 19, name: `Billing`,     pos: 'CM', team: 'away', teamName: `Bournemouth` },
      { id: 20, name: `Tavernier`,   pos: 'RW', team: 'away', teamName: `Bournemouth` },
      { id: 21, name: `Solanke`,     pos: 'ST', team: 'away', teamName: `Bournemouth` },
      { id: 22, name: `Kieffer Moore`, pos: 'LW', team: 'away', teamName: `Bournemouth` },
    ],
    events: [
      { min:  3, type: 'goal',    playerId:  9 },  // Salah
      { min: 18, type: 'goal',    playerId: 11 },  // Luis Díaz
      { min: 27, type: 'goal',    playerId:  4 },  // Van Dijk
      { min: 32, type: 'goal',    playerId:  9 },  // Salah
      { min: 45, type: 'goal',    playerId: 10 },  // Firmino
      { min: 50, type: 'goal',    playerId:  8 },  // Henderson
      { min: 61, type: 'goal',    playerId:  7 },  // Thiago
      { min: 68, type: 'goal',    playerId: 10 },  // Firmino
      { min: 85, type: 'goal',    playerId:  9 },  // Salah hat-trick
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 11: Aston Villa 7-2 Liverpool, 4 Oct 2020 ──────────
  {
    id: 'avl_7-2_liv_2020',
    meta: {
      home: 'Aston Villa', away: 'Liverpool', score: '7-2', homeColour: '#95BFE5', awayColour: '#C8102E',
      date: '4 Oct 2020', label: `Premier League · Sun 4 Oct 2020 · 7:15pm BST`,
      blurb: `Villa Park. <strong>Liverpool were reigning champions</strong> and heavy favourites. Aston Villa had barely survived relegation the previous season. <strong>Alisson is injured</strong> — backup Adrian starts. Watkins makes his home debut for Villa. Everything points to a routine away win.`,
      finalCommentary: `<strong>Full time.</strong> Aston Villa 7–2 Liverpool. The champions obliterated. Watkins hat-trick.`,
      lateCommentary: `Watkins again! Seven! This is extraordinary.`,
    },
    players: [
      { id:  1, name: `Martínez`,    pos: 'GK', team: 'home', teamName: `Aston Villa` },
      { id:  2, name: `Cash`,        pos: 'RB', team: 'home', teamName: `Aston Villa` },
      { id:  3, name: `Konsa`,       pos: 'CB', team: 'home', teamName: `Aston Villa` },
      { id:  4, name: `Mings`,       pos: 'CB', team: 'home', teamName: `Aston Villa` },
      { id:  5, name: `Targett`,     pos: 'LB', team: 'home', teamName: `Aston Villa` },
      { id:  6, name: `Luiz`,        pos: 'DM', team: 'home', teamName: `Aston Villa` },
      { id:  7, name: `McGinn`,      pos: 'CM', team: 'home', teamName: `Aston Villa` },
      { id:  8, name: `Barkley`,     pos: 'AM', team: 'home', teamName: `Aston Villa` },
      { id:  9, name: `Trezeguet`,   pos: 'RW', team: 'home', teamName: `Aston Villa` },
      { id: 10, name: `Grealish`,    pos: 'LW', team: 'home', teamName: `Aston Villa` },
      { id: 11, name: `Watkins`,     pos: 'ST', team: 'home', teamName: `Aston Villa` },
      { id: 12, name: `Adrian`,      pos: 'GK', team: 'away', teamName: `Liverpool` },
      { id: 13, name: `Alexander-Arnold`, pos: 'RB', team: 'away', teamName: `Liverpool` },
      { id: 14, name: `Gomez`,       pos: 'CB', team: 'away', teamName: `Liverpool` },
      { id: 15, name: `Van Dijk`,    pos: 'CB', team: 'away', teamName: `Liverpool` },
      { id: 16, name: `Robertson`,   pos: 'LB', team: 'away', teamName: `Liverpool` },
      { id: 17, name: `Fabinho`,     pos: 'DM', team: 'away', teamName: `Liverpool` },
      { id: 18, name: `Henderson`,   pos: 'CM', team: 'away', teamName: `Liverpool` },
      { id: 19, name: `Wijnaldum`,   pos: 'CM', team: 'away', teamName: `Liverpool` },
      { id: 20, name: `Mané`,        pos: 'LW', team: 'away', teamName: `Liverpool` },
      { id: 21, name: `Salah`,       pos: 'RW', team: 'away', teamName: `Liverpool` },
      { id: 22, name: `Firmino`,     pos: 'ST', team: 'away', teamName: `Liverpool` },
    ],
    events: [
      { min:  4, type: 'goal',    playerId: 11 },  // Watkins
      { min: 22, type: 'goal',    playerId: 21 },  // Salah
      { min: 26, type: 'goal',    playerId: 11 },  // Watkins
      { min: 28, type: 'goal',    playerId:  8 },  // Barkley
      { min: 41, type: 'goal',    playerId: 11 },  // Watkins hat-trick
      { min: 55, type: 'goal',    playerId: 21 },  // Salah
      { min: 58, type: 'goal',    playerId:  7 },  // McGinn
      { min: 66, type: 'goal',    playerId: 10 },  // Grealish
      { min: 75, type: 'goal',    playerId:  9 },  // Trezeguet
      { min: 76, type: 'yellow',  playerId: 17 },  // Fabinho
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 12: Man City 6-3 Man United, 23 Oct 2011 ───────────
  {
    id: 'mci_6-3_mun_2011',
    meta: {
      home: 'Man City', away: 'Man United', score: '6-3', homeColour: '#6CABDD', awayColour: '#DA291C',
      date: '23 Oct 2011', label: `Premier League · Sun 23 Oct 2011 · 1:30pm BST`,
      blurb: `The Etihad. <strong>City hadn't beaten United at home since 1969</strong> — a psychological monkey on their backs. Balotelli starts up front wearing a T-shirt under his kit that nobody's seen yet. <strong>United led by Ferguson</strong> are slight favourites. Both squads packed with quality. Derby day at the Etihad.`,
      finalCommentary: `<strong>Full time.</strong> Manchester City 6–3 Manchester United. Why Always Me.`,
      lateCommentary: `Balotelli scores again! The Etihad is erupting!`,
    },
    players: [
      { id:  1, name: `Hart`,        pos: 'GK', team: 'home', teamName: `Man City` },
      { id:  2, name: `Zabaleta`,    pos: 'RB', team: 'home', teamName: `Man City` },
      { id:  3, name: `Kompany`,     pos: 'CB', team: 'home', teamName: `Man City` },
      { id:  4, name: `Lescott`,     pos: 'CB', team: 'home', teamName: `Man City` },
      { id:  5, name: `Clichy`,      pos: 'LB', team: 'home', teamName: `Man City` },
      { id:  6, name: `De Bruyne`,   pos: 'CM', team: 'home', teamName: `Man City` },
      { id:  7, name: `Barry`,       pos: 'DM', team: 'home', teamName: `Man City` },
      { id:  8, name: `Silva`,       pos: 'AM', team: 'home', teamName: `Man City` },
      { id:  9, name: `Milner`,      pos: 'RW', team: 'home', teamName: `Man City` },
      { id: 10, name: `Balotelli`,   pos: 'ST', team: 'home', teamName: `Man City` },
      { id: 11, name: `Agüero`,      pos: 'LW', team: 'home', teamName: `Man City` },
      { id: 12, name: `De Gea`,      pos: 'GK', team: 'away', teamName: `Man United` },
      { id: 13, name: `Jones`,       pos: 'RB', team: 'away', teamName: `Man United` },
      { id: 14, name: `Ferdinand`,   pos: 'CB', team: 'away', teamName: `Man United` },
      { id: 15, name: `Evans`,       pos: 'CB', team: 'away', teamName: `Man United` },
      { id: 16, name: `Evra`,        pos: 'LB', team: 'away', teamName: `Man United` },
      { id: 17, name: `Carrick`,     pos: 'CM', team: 'away', teamName: `Man United` },
      { id: 18, name: `Anderson`,    pos: 'CM', team: 'away', teamName: `Man United` },
      { id: 19, name: `Nani`,        pos: 'RW', team: 'away', teamName: `Man United` },
      { id: 20, name: `Ashley Young`, pos: 'LW', team: 'away', teamName: `Man United` },
      { id: 21, name: `Rooney`,      pos: 'AM', team: 'away', teamName: `Man United` },
      { id: 22, name: `Fletcher`,    pos: 'ST', team: 'away', teamName: `Man United` },
    ],
    events: [
      { min: 22, type: 'goal',    playerId: 21 },  // Rooney
      { min: 37, type: 'goal',    playerId: 10 },  // Balotelli (pen)
      { min: 39, type: 'goal',    playerId: 10 },  // Balotelli
      { min: 60, type: 'goal',    playerId: 11 },  // Agüero
      { min: 65, type: 'goal',    playerId: 21 },  // Rooney
      { min: 68, type: 'goal',    playerId: 11 },  // Agüero
      { min: 76, type: 'goal',    playerId: 19 },  // Nani
      { min: 89, type: 'goal',    playerId:  8 },  // Silva
      { min: 90, type: 'goal',    playerId: 11 },  // Agüero
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 13: Man City 6-3 Man United, 29 Oct 2023 ───────────
  {
    id: 'mci_6-3_mun_2023',
    meta: {
      home: 'Man City', away: 'Man United', score: '6-3', homeColour: '#6CABDD', awayColour: '#DA291C',
      date: '29 Oct 2023', label: `Premier League · Sun 29 Oct 2023 · 4:30pm GMT`,
      blurb: `The Etihad. <strong>Haaland has been unstoppable</strong> all season — the most feared striker in Europe. <strong>Ten Hag's United are finding their feet</strong> but inconsistent away from home. City's midfield trio of Rodri, De Bruyne and Bernardo Silva may be the best in Europe. A Manchester Derby with contrasting form lines.`,
      finalCommentary: `<strong>Full time.</strong> Manchester City 6–3 Manchester United. Haaland hat-trick. History repeating.`,
      lateCommentary: `Six! City are relentless. United have no answers.`,
    },
    players: [
      { id:  1, name: `Ederson`,     pos: 'GK', team: 'home', teamName: `Man City` },
      { id:  2, name: `Walker`,      pos: 'RB', team: 'home', teamName: `Man City` },
      { id:  3, name: `Rúben Dias`,  pos: 'CB', team: 'home', teamName: `Man City` },
      { id:  4, name: `Akanji`,      pos: 'CB', team: 'home', teamName: `Man City` },
      { id:  5, name: `Gvardiol`,    pos: 'LB', team: 'home', teamName: `Man City` },
      { id:  6, name: `Rodri`,       pos: 'DM', team: 'home', teamName: `Man City` },
      { id:  7, name: `De Bruyne`,   pos: 'CM', team: 'home', teamName: `Man City` },
      { id:  8, name: `Bernardo Silva`, pos: 'CM', team: 'home', teamName: `Man City` },
      { id:  9, name: `Foden`,       pos: 'LW', team: 'home', teamName: `Man City` },
      { id: 10, name: `Haaland`,     pos: 'ST', team: 'home', teamName: `Man City` },
      { id: 11, name: `Doku`,        pos: 'RW', team: 'home', teamName: `Man City` },
      { id: 12, name: `Onana`,       pos: 'GK', team: 'away', teamName: `Man United` },
      { id: 13, name: `Wan-Bissaka`, pos: 'RB', team: 'away', teamName: `Man United` },
      { id: 14, name: `Lindelöf`,    pos: 'CB', team: 'away', teamName: `Man United` },
      { id: 15, name: `Evans`,       pos: 'CB', team: 'away', teamName: `Man United` },
      { id: 16, name: `Shaw`,        pos: 'LB', team: 'away', teamName: `Man United` },
      { id: 17, name: `Casemiro`,    pos: 'DM', team: 'away', teamName: `Man United` },
      { id: 18, name: `Eriksen`,     pos: 'CM', team: 'away', teamName: `Man United` },
      { id: 19, name: `Antony`,      pos: 'RW', team: 'away', teamName: `Man United` },
      { id: 20, name: `Fernandes`,   pos: 'AM', team: 'away', teamName: `Man United` },
      { id: 21, name: `Rashford`,    pos: 'LW', team: 'away', teamName: `Man United` },
      { id: 22, name: `Højlund`,     pos: 'ST', team: 'away', teamName: `Man United` },
    ],
    events: [
      { min:  5, type: 'goal',    playerId:  9 },  // Foden
      { min: 26, type: 'goal',    playerId: 10 },  // Haaland
      { min: 28, type: 'goal',    playerId: 20 },  // Fernandes
      { min: 35, type: 'goal',    playerId: 10 },  // Haaland
      { min: 44, type: 'goal',    playerId: 22 },  // Højlund
      { min: 53, type: 'goal',    playerId:  9 },  // Foden
      { min: 63, type: 'goal',    playerId: 10 },  // Haaland hat-trick
      { min: 80, type: 'goal',    playerId: 20 },  // Fernandes
      { min: 85, type: 'goal',    playerId:  7 },  // De Bruyne
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 14: Chelsea 4-4 Man City, 12 Nov 2023 ──────────────
  {
    id: 'che_4-4_mci_2023',
    meta: {
      home: 'Chelsea', away: 'Man City', score: '4-4', homeColour: '#034694', awayColour: '#6CABDD',
      date: '12 Nov 2023', label: `Premier League · Sun 12 Nov 2023 · 2:00pm GMT`,
      blurb: `Stamford Bridge. <strong>Chelsea led 4-0 at half time.</strong> The reigning treble winners were being demolished. Four City goals in the second half completed the most stunning comeback of the season.`,
      finalCommentary: `<strong>Full time.</strong> Chelsea 4–4 Manchester City. The most remarkable second half of the season.`,
      lateCommentary: `Equaliser! City complete an extraordinary comeback!`,
    },
    players: [
      { id:  1, name: `Petrović`,    pos: 'GK', team: 'home', teamName: `Chelsea` },
      { id:  2, name: `Reece James`, pos: 'RB', team: 'home', teamName: `Chelsea` },
      { id:  3, name: `Thiago Silva`, pos: 'CB', team: 'home', teamName: `Chelsea` },
      { id:  4, name: `Disasi`,      pos: 'CB', team: 'home', teamName: `Chelsea` },
      { id:  5, name: `Chilwell`,    pos: 'LB', team: 'home', teamName: `Chelsea` },
      { id:  6, name: `Caicedo`,     pos: 'DM', team: 'home', teamName: `Chelsea` },
      { id:  7, name: `Gallagher`,   pos: 'CM', team: 'home', teamName: `Chelsea` },
      { id:  8, name: `Palmer`,      pos: 'AM', team: 'home', teamName: `Chelsea` },
      { id:  9, name: `Sterling`,    pos: 'RW', team: 'home', teamName: `Chelsea` },
      { id: 10, name: `Jackson`,     pos: 'ST', team: 'home', teamName: `Chelsea` },
      { id: 11, name: `Mudryk`,      pos: 'LW', team: 'home', teamName: `Chelsea` },
      { id: 12, name: `Ederson`,     pos: 'GK', team: 'away', teamName: `Man City` },
      { id: 13, name: `Walker`,      pos: 'RB', team: 'away', teamName: `Man City` },
      { id: 14, name: `Rúben Dias`,  pos: 'CB', team: 'away', teamName: `Man City` },
      { id: 15, name: `Akanji`,      pos: 'CB', team: 'away', teamName: `Man City` },
      { id: 16, name: `Gvardiol`,    pos: 'LB', team: 'away', teamName: `Man City` },
      { id: 17, name: `Rodri`,       pos: 'DM', team: 'away', teamName: `Man City` },
      { id: 18, name: `De Bruyne`,   pos: 'CM', team: 'away', teamName: `Man City` },
      { id: 19, name: `Bernardo Silva`, pos: 'CM', team: 'away', teamName: `Man City` },
      { id: 20, name: `Foden`,       pos: 'LW', team: 'away', teamName: `Man City` },
      { id: 21, name: `Haaland`,     pos: 'ST', team: 'away', teamName: `Man City` },
      { id: 22, name: `Doku`,        pos: 'RW', team: 'away', teamName: `Man City` },
    ],
    events: [
      { min: 11, type: 'goal',    playerId:  8 },  // Palmer
      { min: 24, type: 'goal',    playerId: 10 },  // Jackson
      { min: 30, type: 'goal',    playerId:  9 },  // Sterling
      { min: 40, type: 'goal',    playerId:  8 },  // Palmer
      { min: 54, type: 'goal',    playerId: 21 },  // Haaland
      { min: 60, type: 'goal',    playerId: 20 },  // Foden
      { min: 71, type: 'yellow',  playerId:  6 },  // Caicedo
      { min: 75, type: 'goal',    playerId: 21 },  // Haaland
      { min: 88, type: 'goal',    playerId: 20 },  // Foden
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 15: Tottenham 6-2 Everton, 13 Sep 2020 ─────────────
  {
    id: 'tot_6-2_eve_2020',
    meta: {
      home: 'Tottenham', away: 'Everton', score: '6-2', homeColour: '#132257', awayColour: '#003399',
      date: '13 Sep 2020', label: `Premier League · Sun 13 Sep 2020 · 4:30pm BST`,
      blurb: `Tottenham Hotspur Stadium. <strong>Mourinho's first season at Spurs.</strong> His high-pressing system is starting to click. Son and Kane look dangerous together — the chemistry is building. Richarlison leads Everton's attack. Can Ancelotti's side spoil the party?`,
      finalCommentary: `<strong>Full time.</strong> Tottenham 6–2 Everton. Son hat-trick. Kane 6 assists. The partnership has arrived.`,
      lateCommentary: `Son again! Six! What a display from Spurs.`,
    },
    players: [
      { id:  1, name: `Lloris`,      pos: 'GK', team: 'home', teamName: `Tottenham` },
      { id:  2, name: `Aurier`,      pos: 'RB', team: 'home', teamName: `Tottenham` },
      { id:  3, name: `Alderweireld`, pos: 'CB', team: 'home', teamName: `Tottenham` },
      { id:  4, name: `Dier`,        pos: 'CB', team: 'home', teamName: `Tottenham` },
      { id:  5, name: `Davies`,      pos: 'LB', team: 'home', teamName: `Tottenham` },
      { id:  6, name: `Hojbjerg`,    pos: 'DM', team: 'home', teamName: `Tottenham` },
      { id:  7, name: `Sissoko`,     pos: 'CM', team: 'home', teamName: `Tottenham` },
      { id:  8, name: `Lo Celso`,    pos: 'AM', team: 'home', teamName: `Tottenham` },
      { id:  9, name: `Lucas Moura`, pos: 'RW', team: 'home', teamName: `Tottenham` },
      { id: 10, name: `Kane`,        pos: 'ST', team: 'home', teamName: `Tottenham` },
      { id: 11, name: `Son`,         pos: 'LW', team: 'home', teamName: `Tottenham` },
      { id: 12, name: `Pickford`,    pos: 'GK', team: 'away', teamName: `Everton` },
      { id: 13, name: `Coleman`,     pos: 'RB', team: 'away', teamName: `Everton` },
      { id: 14, name: `Godfrey`,     pos: 'CB', team: 'away', teamName: `Everton` },
      { id: 15, name: `Keane`,       pos: 'CB', team: 'away', teamName: `Everton` },
      { id: 16, name: `Digne`,       pos: 'LB', team: 'away', teamName: `Everton` },
      { id: 17, name: `Allan`,       pos: 'DM', team: 'away', teamName: `Everton` },
      { id: 18, name: `Doucoure`,    pos: 'CM', team: 'away', teamName: `Everton` },
      { id: 19, name: `James Rodriguez`, pos: 'AM', team: 'away', teamName: `Everton` },
      { id: 20, name: `Sigurdsson`,  pos: 'RW', team: 'away', teamName: `Everton` },
      { id: 21, name: `Richarlison`, pos: 'LW', team: 'away', teamName: `Everton` },
      { id: 22, name: `Calvert-Lewin`, pos: 'ST', team: 'away', teamName: `Everton` },
    ],
    events: [
      { min:  1, type: 'goal',    playerId: 11 },  // Son
      { min: 21, type: 'goal',    playerId: 22 },  // Calvert-Lewin
      { min: 27, type: 'goal',    playerId: 11 },  // Son
      { min: 34, type: 'goal',    playerId: 11 },  // Son hat-trick
      { min: 38, type: 'red',     playerId: 21 },  // Richarlison red
      { min: 49, type: 'goal',    playerId: 10 },  // Kane
      { min: 54, type: 'goal',    playerId: 22 },  // Calvert-Lewin
      { min: 63, type: 'goal',    playerId: 10 },  // Kane
      { min: 79, type: 'goal',    playerId:  9 },  // Lucas Moura
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 16: Man United 6-2 Leeds, 20 Dec 2020 ──────────────
  {
    id: 'mun_6-2_lee_2020',
    meta: {
      home: 'Man United', away: 'Leeds United', score: '6-2', homeColour: '#DA291C', awayColour: '#FFCD00',
      date: '20 Dec 2020', label: `Premier League · Sun 20 Dec 2020 · 4:30pm GMT`,
      blurb: `Old Trafford. <strong>First league meeting since 2004.</strong> The most anticipated fixture of the season. Bielsa's Leeds play fearless high-press football — brave but exposed at the back. Solskjær's United have Fernandes pulling the strings and Greenwood in electric form. A clash of styles.`,
      finalCommentary: `<strong>Full time.</strong> Manchester United 6–2 Leeds United. Bruno hat-trick. Old rivalries reignited.`,
      lateCommentary: `Six! United run riot. The old rivalry is back with a bang.`,
    },
    players: [
      { id:  1, name: `De Gea`,      pos: 'GK', team: 'home', teamName: `Man United` },
      { id:  2, name: `Wan-Bissaka`, pos: 'RB', team: 'home', teamName: `Man United` },
      { id:  3, name: `Maguire`,     pos: 'CB', team: 'home', teamName: `Man United` },
      { id:  4, name: `Lindelöf`,    pos: 'CB', team: 'home', teamName: `Man United` },
      { id:  5, name: `Shaw`,        pos: 'LB', team: 'home', teamName: `Man United` },
      { id:  6, name: `McTominay`,   pos: 'CM', team: 'home', teamName: `Man United` },
      { id:  7, name: `Fred`,        pos: 'CM', team: 'home', teamName: `Man United` },
      { id:  8, name: `Greenwood`,   pos: 'RW', team: 'home', teamName: `Man United` },
      { id:  9, name: `Fernandes`,   pos: 'AM', team: 'home', teamName: `Man United` },
      { id: 10, name: `Rashford`,    pos: 'LW', team: 'home', teamName: `Man United` },
      { id: 11, name: `Martial`,     pos: 'ST', team: 'home', teamName: `Man United` },
      { id: 12, name: `Meslier`,     pos: 'GK', team: 'away', teamName: `Leeds United` },
      { id: 13, name: `Ayling`,      pos: 'RB', team: 'away', teamName: `Leeds United` },
      { id: 14, name: `Cooper`,      pos: 'CB', team: 'away', teamName: `Leeds United` },
      { id: 15, name: `Struijk`,     pos: 'CB', team: 'away', teamName: `Leeds United` },
      { id: 16, name: `Dallas`,      pos: 'LB', team: 'away', teamName: `Leeds United` },
      { id: 17, name: `Klich`,       pos: 'CM', team: 'away', teamName: `Leeds United` },
      { id: 18, name: `Phillips`,    pos: 'DM', team: 'away', teamName: `Leeds United` },
      { id: 19, name: `Raphinha`,    pos: 'RW', team: 'away', teamName: `Leeds United` },
      { id: 20, name: `Rodrigo`,     pos: 'AM', team: 'away', teamName: `Leeds United` },
      { id: 21, name: `Harrison`,    pos: 'LW', team: 'away', teamName: `Leeds United` },
      { id: 22, name: `Bamford`,     pos: 'ST', team: 'away', teamName: `Leeds United` },
    ],
    events: [
      { min:  6, type: 'goal',    playerId:  9 },  // Fernandes pen
      { min: 23, type: 'goal',    playerId: 10 },  // Rashford
      { min: 35, type: 'goal',    playerId: 22 },  // Bamford
      { min: 49, type: 'goal',    playerId:  9 },  // Fernandes
      { min: 53, type: 'goal',    playerId: 22 },  // Bamford
      { min: 58, type: 'goal',    playerId:  9 },  // Fernandes hat-trick
      { min: 66, type: 'goal',    playerId:  8 },  // Greenwood
      { min: 71, type: 'yellow',  playerId: 14 },  // Cooper
      { min: 88, type: 'goal',    playerId: 11 },  // Martial
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 17: Liverpool 7-0 Crystal Palace, 19 Dec 2020 ──────
  {
    id: 'liv_7-0_cry_2020',
    meta: {
      home: 'Liverpool', away: 'Crystal Palace', score: '7-0', homeColour: '#C8102E', awayColour: '#1B458F',
      date: '19 Dec 2020', label: `Premier League · Sat 19 Dec 2020 · 5:30pm GMT`,
      blurb: `Anfield. <strong>Liverpool are in devastating form</strong> — Klopp's gegenpressing system at its peak. Firmino, Mané and Salah are the most feared front three in Europe. Palace arrive at Anfield under Sam Allardyce, fighting to survive. A daunting away day for the Eagles.`,
      finalCommentary: `<strong>Full time.</strong> Liverpool 7–0 Crystal Palace. The biggest win in Liverpool's Premier League history.`,
      lateCommentary: `Seven! Anfield in full voice. Liverpool are relentless.`,
    },
    players: [
      { id:  1, name: `Alisson`,     pos: 'GK', team: 'home', teamName: `Liverpool` },
      { id:  2, name: `Alexander-Arnold`, pos: 'RB', team: 'home', teamName: `Liverpool` },
      { id:  3, name: `Fabinho`,     pos: 'CB', team: 'home', teamName: `Liverpool` },
      { id:  4, name: `Henderson`,   pos: 'CM', team: 'home', teamName: `Liverpool` },
      { id:  5, name: `Robertson`,   pos: 'LB', team: 'home', teamName: `Liverpool` },
      { id:  6, name: `Wijnaldum`,   pos: 'CM', team: 'home', teamName: `Liverpool` },
      { id:  7, name: `Thiago`,      pos: 'DM', team: 'home', teamName: `Liverpool` },
      { id:  8, name: `Jones`,       pos: 'AM', team: 'home', teamName: `Liverpool` },
      { id:  9, name: `Salah`,       pos: 'RW', team: 'home', teamName: `Liverpool` },
      { id: 10, name: `Firmino`,     pos: 'ST', team: 'home', teamName: `Liverpool` },
      { id: 11, name: `Mané`,        pos: 'LW', team: 'home', teamName: `Liverpool` },
      { id: 12, name: `Guaita`,      pos: 'GK', team: 'away', teamName: `Crystal Palace` },
      { id: 13, name: `Ward`,        pos: 'RB', team: 'away', teamName: `Crystal Palace` },
      { id: 14, name: `Kouyaté`,     pos: 'CB', team: 'away', teamName: `Crystal Palace` },
      { id: 15, name: `Cahill`,      pos: 'CB', team: 'away', teamName: `Crystal Palace` },
      { id: 16, name: `Clyne`,       pos: 'LB', team: 'away', teamName: `Crystal Palace` },
      { id: 17, name: `McArthur`,    pos: 'CM', team: 'away', teamName: `Crystal Palace` },
      { id: 18, name: `Milivojevic`, pos: 'DM', team: 'away', teamName: `Crystal Palace` },
      { id: 19, name: `Townsend`,    pos: 'RW', team: 'away', teamName: `Crystal Palace` },
      { id: 20, name: `Eze`,         pos: 'AM', team: 'away', teamName: `Crystal Palace` },
      { id: 21, name: `Zaha`,        pos: 'LW', team: 'away', teamName: `Crystal Palace` },
      { id: 22, name: `Benteke`,     pos: 'ST', team: 'away', teamName: `Crystal Palace` },
    ],
    events: [
      { min: 23, type: 'goal',    playerId: 10 },  // Firmino
      { min: 31, type: 'goal',    playerId: 11 },  // Mané
      { min: 55, type: 'goal',    playerId:  9 },  // Salah
      { min: 57, type: 'goal',    playerId: 10 },  // Firmino
      { min: 62, type: 'goal',    playerId: 11 },  // Mané
      { min: 68, type: 'goal',    playerId: 10 },  // Firmino hat-trick
      { min: 76, type: 'yellow',  playerId: 17 },  // McArthur
      { min: 79, type: 'goal',    playerId:  8 },  // Jones
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 18: Man City 7-0 Leeds, 14 Dec 2021 ────────────────
  {
    id: 'mci_7-0_lee_2021',
    meta: {
      home: 'Man City', away: 'Leeds United', score: '7-0', homeColour: '#6CABDD', awayColour: '#FFCD00',
      date: '14 Dec 2021', label: `Premier League · Tue 14 Dec 2021 · 7:30pm GMT`,
      blurb: `The Etihad. <strong>Leeds were already struggling</strong> in their second season back in the top flight. City were the champions. Mahrez with two. City went seven without reply. A brutal Tuesday night in Manchester.`,
      finalCommentary: `<strong>Full time.</strong> Manchester City 7–0 Leeds United. A complete and utter demolition.`,
      lateCommentary: `Seven! Leeds have run out of ideas entirely. City are ruthless.`,
    },
    players: [
      { id:  1, name: `Ederson`,     pos: 'GK', team: 'home', teamName: `Man City` },
      { id:  2, name: `Walker`,      pos: 'RB', team: 'home', teamName: `Man City` },
      { id:  3, name: `Rúben Dias`,  pos: 'CB', team: 'home', teamName: `Man City` },
      { id:  4, name: `Laporte`,     pos: 'CB', team: 'home', teamName: `Man City` },
      { id:  5, name: `Cancelo`,     pos: 'LB', team: 'home', teamName: `Man City` },
      { id:  6, name: `Rodri`,       pos: 'DM', team: 'home', teamName: `Man City` },
      { id:  7, name: `De Bruyne`,   pos: 'CM', team: 'home', teamName: `Man City` },
      { id:  8, name: `Bernardo Silva`, pos: 'CM', team: 'home', teamName: `Man City` },
      { id:  9, name: `Mahrez`,      pos: 'RW', team: 'home', teamName: `Man City` },
      { id: 10, name: `Gabriel Jesus`, pos: 'ST', team: 'home', teamName: `Man City` },
      { id: 11, name: `Sterling`,    pos: 'LW', team: 'home', teamName: `Man City` },
      { id: 12, name: `Meslier`,     pos: 'GK', team: 'away', teamName: `Leeds United` },
      { id: 13, name: `Ayling`,      pos: 'RB', team: 'away', teamName: `Leeds United` },
      { id: 14, name: `Cooper`,      pos: 'CB', team: 'away', teamName: `Leeds United` },
      { id: 15, name: `Llorente`,    pos: 'CB', team: 'away', teamName: `Leeds United` },
      { id: 16, name: `Dallas`,      pos: 'LB', team: 'away', teamName: `Leeds United` },
      { id: 17, name: `Forshaw`,     pos: 'DM', team: 'away', teamName: `Leeds United` },
      { id: 18, name: `Raphinha`,    pos: 'RW', team: 'away', teamName: `Leeds United` },
      { id: 19, name: `Rodrigo`,     pos: 'AM', team: 'away', teamName: `Leeds United` },
      { id: 20, name: `Harrison`,    pos: 'LW', team: 'away', teamName: `Leeds United` },
      { id: 21, name: `James`,       pos: 'CM', team: 'away', teamName: `Leeds United` },
      { id: 22, name: `Bamford`,     pos: 'ST', team: 'away', teamName: `Leeds United` },
    ],
    events: [
      { min:  3, type: 'goal',    playerId: 11 },  // Sterling
      { min: 14, type: 'goal',    playerId:  9 },  // Mahrez
      { min: 31, type: 'goal',    playerId: 10 },  // Jesus
      { min: 43, type: 'yellow',  playerId: 13 },  // Ayling
      { min: 50, type: 'goal',    playerId:  8 },  // Bernardo
      { min: 57, type: 'goal',    playerId:  9 },  // Mahrez
      { min: 70, type: 'goal',    playerId:  7 },  // De Bruyne
      { min: 76, type: 'goal',    playerId: 10 },  // Jesus
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 19: Nottm Forest 0-6 Man City, 31 Aug 2022 ─────────
  {
    id: 'nfo_0-6_mci_2022',
    meta: {
      home: 'Nottm Forest', away: 'Man City', score: '0-6', homeColour: '#DD0000', awayColour: '#6CABDD',
      date: '31 Aug 2022', label: `Premier League · Wed 31 Aug 2022 · 7:30pm BST`,
      blurb: `The City Ground. <strong>Forest had just been promoted</strong> after 23 years away. City were champions. Erling Haaland, brand new to English football, scored twice on his first away league start. The gap between champions and promoted sides had never felt wider.`,
      finalCommentary: `<strong>Full time.</strong> Nottingham Forest 0–6 Manchester City. Haaland announces himself.`,
      lateCommentary: `Six! City are relentless. Forest overwhelmed.`,
    },
    players: [
      { id:  1, name: `Henderson`,   pos: 'GK', team: 'home', teamName: `Nottm Forest` },
      { id:  2, name: `Worrall`,     pos: 'RB', team: 'home', teamName: `Nottm Forest` },
      { id:  3, name: `Cook`,        pos: 'CB', team: 'home', teamName: `Nottm Forest` },
      { id:  4, name: `McKenna`,     pos: 'CB', team: 'home', teamName: `Nottm Forest` },
      { id:  5, name: `Toffolo`,     pos: 'LB', team: 'home', teamName: `Nottm Forest` },
      { id:  6, name: `Freuler`,     pos: 'DM', team: 'home', teamName: `Nottm Forest` },
      { id:  7, name: `Yates`,       pos: 'CM', team: 'home', teamName: `Nottm Forest` },
      { id:  8, name: `Gibbs-White`, pos: 'AM', team: 'home', teamName: `Nottm Forest` },
      { id:  9, name: `Lingard`,     pos: 'RW', team: 'home', teamName: `Nottm Forest` },
      { id: 10, name: `Johnson`,     pos: 'LW', team: 'home', teamName: `Nottm Forest` },
      { id: 11, name: `Awoniyi`,     pos: 'ST', team: 'home', teamName: `Nottm Forest` },
      { id: 12, name: `Ederson`,     pos: 'GK', team: 'away', teamName: `Man City` },
      { id: 13, name: `Walker`,      pos: 'RB', team: 'away', teamName: `Man City` },
      { id: 14, name: `Rúben Dias`,  pos: 'CB', team: 'away', teamName: `Man City` },
      { id: 15, name: `Akanji`,      pos: 'CB', team: 'away', teamName: `Man City` },
      { id: 16, name: `Cancelo`,     pos: 'LB', team: 'away', teamName: `Man City` },
      { id: 17, name: `Rodri`,       pos: 'DM', team: 'away', teamName: `Man City` },
      { id: 18, name: `De Bruyne`,   pos: 'CM', team: 'away', teamName: `Man City` },
      { id: 19, name: `Bernardo Silva`, pos: 'CM', team: 'away', teamName: `Man City` },
      { id: 20, name: `Mahrez`,      pos: 'RW', team: 'away', teamName: `Man City` },
      { id: 21, name: `Haaland`,     pos: 'ST', team: 'away', teamName: `Man City` },
      { id: 22, name: `Foden`,       pos: 'LW', team: 'away', teamName: `Man City` },
    ],
    events: [
      { min: 17, type: 'goal',    playerId: 21 },  // Haaland
      { min: 27, type: 'goal',    playerId: 22 },  // Foden
      { min: 36, type: 'goal',    playerId: 18 },  // De Bruyne
      { min: 48, type: 'goal',    playerId: 21 },  // Haaland
      { min: 55, type: 'yellow',  playerId:  7 },  // Yates
      { min: 66, type: 'goal',    playerId: 20 },  // Mahrez
      { min: 77, type: 'goal',    playerId: 19 },  // Bernardo
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 20: Tottenham 6-2 Leicester, 17 Sep 2022 ───────────
  {
    id: 'tot_6-2_lei_2022',
    meta: {
      home: 'Tottenham', away: 'Leicester', score: '6-2', homeColour: '#132257', awayColour: '#003090',
      date: '17 Sep 2022', label: `Premier League · Sat 17 Sep 2022 · 3:00pm BST`,
      blurb: `Tottenham Hotspur Stadium. <strong>Son had gone six games without a goal.</strong> The drought ended emphatically — he scored four. Kane two. One of the finest individual Premier League performances in years.`,
      finalCommentary: `<strong>Full time.</strong> Tottenham 6–2 Leicester. Son scores four. The drought is very much over.`,
      lateCommentary: `Son's fourth! Tottenham are extraordinary today.`,
    },
    players: [
      { id:  1, name: `Lloris`,      pos: 'GK', team: 'home', teamName: `Tottenham` },
      { id:  2, name: `Romero`,      pos: 'RB', team: 'home', teamName: `Tottenham` },
      { id:  3, name: `Dier`,        pos: 'CB', team: 'home', teamName: `Tottenham` },
      { id:  4, name: `Davies`,      pos: 'CB', team: 'home', teamName: `Tottenham` },
      { id:  5, name: `Perisic`,     pos: 'LB', team: 'home', teamName: `Tottenham` },
      { id:  6, name: `Hojbjerg`,    pos: 'DM', team: 'home', teamName: `Tottenham` },
      { id:  7, name: `Bentancur`,   pos: 'CM', team: 'home', teamName: `Tottenham` },
      { id:  8, name: `Richarlison`, pos: 'AM', team: 'home', teamName: `Tottenham` },
      { id:  9, name: `Kulusevski`,  pos: 'RW', team: 'home', teamName: `Tottenham` },
      { id: 10, name: `Kane`,        pos: 'ST', team: 'home', teamName: `Tottenham` },
      { id: 11, name: `Son`,         pos: 'LW', team: 'home', teamName: `Tottenham` },
      { id: 12, name: `Ward`,        pos: 'GK', team: 'away', teamName: `Leicester` },
      { id: 13, name: `Castagne`,    pos: 'RB', team: 'away', teamName: `Leicester` },
      { id: 14, name: `Faes`,        pos: 'CB', team: 'away', teamName: `Leicester` },
      { id: 15, name: `Soyuncu`,     pos: 'CB', team: 'away', teamName: `Leicester` },
      { id: 16, name: `Justin`,      pos: 'LB', team: 'away', teamName: `Leicester` },
      { id: 17, name: `Ndidi`,       pos: 'DM', team: 'away', teamName: `Leicester` },
      { id: 18, name: `Tielemans`,   pos: 'CM', team: 'away', teamName: `Leicester` },
      { id: 19, name: `Dewsbury-Hall`, pos: 'AM', team: 'away', teamName: `Leicester` },
      { id: 20, name: `Lookman`,     pos: 'RW', team: 'away', teamName: `Leicester` },
      { id: 21, name: `Maddison`,    pos: 'LW', team: 'away', teamName: `Leicester` },
      { id: 22, name: `Vardy`,       pos: 'ST', team: 'away', teamName: `Leicester` },
    ],
    events: [
      { min:  4, type: 'goal',    playerId: 11 },  // Son
      { min: 10, type: 'goal',    playerId: 10 },  // Kane
      { min: 22, type: 'goal',    playerId: 11 },  // Son
      { min: 36, type: 'goal',    playerId: 22 },  // Vardy
      { min: 39, type: 'yellow',  playerId: 14 },  // Faes
      { min: 52, type: 'goal',    playerId: 22 },  // Vardy
      { min: 55, type: 'goal',    playerId: 10 },  // Kane
      { min: 70, type: 'goal',    playerId: 11 },  // Son
      { min: 78, type: 'goal',    playerId: 11 },  // Son 4th
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 21: Newcastle 4-0 Tottenham, 10 Dec 2023 ───────────
  {
    id: 'new_4-0_tot_2023',
    meta: {
      home: 'Newcastle', away: 'Tottenham', score: '4-0', homeColour: '#241F20', awayColour: '#132257',
      date: '10 Dec 2023', label: `Premier League · Sun 10 Dec 2023 · 2:00pm GMT`,
      blurb: `St James' Park. <strong>Newcastle were in the Champions League</strong> for the first time in twenty years. Tottenham, under Postecoglou, were unpredictable. St James' Park at full voice delivered a complete performance.`,
      finalCommentary: `<strong>Full time.</strong> Newcastle 4–0 Tottenham. St James' Park in full voice.`,
      lateCommentary: `Four! Newcastle are outstanding today. Tottenham have no answers.`,
    },
    players: [
      { id:  1, name: `Pope`,        pos: 'GK', team: 'home', teamName: `Newcastle` },
      { id:  2, name: `Trippier`,    pos: 'RB', team: 'home', teamName: `Newcastle` },
      { id:  3, name: `Schär`,       pos: 'CB', team: 'home', teamName: `Newcastle` },
      { id:  4, name: `Botman`,      pos: 'CB', team: 'home', teamName: `Newcastle` },
      { id:  5, name: `Burn`,        pos: 'LB', team: 'home', teamName: `Newcastle` },
      { id:  6, name: `Guimarães`,   pos: 'DM', team: 'home', teamName: `Newcastle` },
      { id:  7, name: `Joelinton`,   pos: 'CM', team: 'home', teamName: `Newcastle` },
      { id:  8, name: `Tonali`,      pos: 'CM', team: 'home', teamName: `Newcastle` },
      { id:  9, name: `Almiron`,     pos: 'RW', team: 'home', teamName: `Newcastle` },
      { id: 10, name: `Wilson`,      pos: 'ST', team: 'home', teamName: `Newcastle` },
      { id: 11, name: `Gordon`,      pos: 'LW', team: 'home', teamName: `Newcastle` },
      { id: 12, name: `Vicario`,     pos: 'GK', team: 'away', teamName: `Tottenham` },
      { id: 13, name: `Porro`,       pos: 'RB', team: 'away', teamName: `Tottenham` },
      { id: 14, name: `Romero`,      pos: 'CB', team: 'away', teamName: `Tottenham` },
      { id: 15, name: `Van de Ven`,  pos: 'CB', team: 'away', teamName: `Tottenham` },
      { id: 16, name: `Udogie`,      pos: 'LB', team: 'away', teamName: `Tottenham` },
      { id: 17, name: `Hojbjerg`,    pos: 'DM', team: 'away', teamName: `Tottenham` },
      { id: 18, name: `Bissouma`,    pos: 'CM', team: 'away', teamName: `Tottenham` },
      { id: 19, name: `Kulusevski`,  pos: 'RW', team: 'away', teamName: `Tottenham` },
      { id: 20, name: `Maddison`,    pos: 'AM', team: 'away', teamName: `Tottenham` },
      { id: 21, name: `Son`,         pos: 'LW', team: 'away', teamName: `Tottenham` },
      { id: 22, name: `Richarlison`, pos: 'ST', team: 'away', teamName: `Tottenham` },
    ],
    events: [
      { min: 15, type: 'goal',    playerId: 10 },  // Wilson
      { min: 38, type: 'goal',    playerId:  6 },  // Guimarães
      { min: 53, type: 'yellow',  playerId: 17 },  // Hojbjerg
      { min: 61, type: 'goal',    playerId:  9 },  // Almiron
      { min: 75, type: 'goal',    playerId: 11 },  // Gordon
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 22: Chelsea 0-5 Arsenal, 22 Oct 2023 ───────────────
  {
    id: 'che_0-5_ars_2023',
    meta: {
      home: 'Chelsea', away: 'Arsenal', score: '0-5', homeColour: '#034694', awayColour: '#EF0107',
      date: '22 Oct 2023', label: `Premier League · Sun 22 Oct 2023 · 4:30pm BST`,
      blurb: `Stamford Bridge. <strong>Arsenal were Premier League title challengers</strong> under Arteta — Saka and Martinelli in brilliant form. Chelsea were in upheaval — Pochettino their fourth manager in 18 months, the squad unsettled. A London derby with very different momentum.`,
      finalCommentary: `<strong>Full time.</strong> Chelsea 0–5 Arsenal. Trossard hat-trick. Arsenal's finest Stamford Bridge performance.`,
      lateCommentary: `Five! Arsenal are outstanding. Pochettino looks shell-shocked.`,
    },
    players: [
      { id:  1, name: `Petrović`,    pos: 'GK', team: 'home', teamName: `Chelsea` },
      { id:  2, name: `Reece James`, pos: 'RB', team: 'home', teamName: `Chelsea` },
      { id:  3, name: `Thiago Silva`, pos: 'CB', team: 'home', teamName: `Chelsea` },
      { id:  4, name: `Disasi`,      pos: 'CB', team: 'home', teamName: `Chelsea` },
      { id:  5, name: `Chilwell`,    pos: 'LB', team: 'home', teamName: `Chelsea` },
      { id:  6, name: `Caicedo`,     pos: 'DM', team: 'home', teamName: `Chelsea` },
      { id:  7, name: `Gallagher`,   pos: 'CM', team: 'home', teamName: `Chelsea` },
      { id:  8, name: `Palmer`,      pos: 'AM', team: 'home', teamName: `Chelsea` },
      { id:  9, name: `Sterling`,    pos: 'RW', team: 'home', teamName: `Chelsea` },
      { id: 10, name: `Jackson`,     pos: 'ST', team: 'home', teamName: `Chelsea` },
      { id: 11, name: `Mudryk`,      pos: 'LW', team: 'home', teamName: `Chelsea` },
      { id: 12, name: `Raya`,        pos: 'GK', team: 'away', teamName: `Arsenal` },
      { id: 13, name: `Ben White`,   pos: 'RB', team: 'away', teamName: `Arsenal` },
      { id: 14, name: `Saliba`,      pos: 'CB', team: 'away', teamName: `Arsenal` },
      { id: 15, name: `Gabriel`,     pos: 'CB', team: 'away', teamName: `Arsenal` },
      { id: 16, name: `Zinchenko`,   pos: 'LB', team: 'away', teamName: `Arsenal` },
      { id: 17, name: `Thomas`,      pos: 'DM', team: 'away', teamName: `Arsenal` },
      { id: 18, name: `Rice`,        pos: 'CM', team: 'away', teamName: `Arsenal` },
      { id: 19, name: `Saka`,        pos: 'RW', team: 'away', teamName: `Arsenal` },
      { id: 20, name: `Havertz`,     pos: 'AM', team: 'away', teamName: `Arsenal` },
      { id: 21, name: `Martinelli`,  pos: 'LW', team: 'away', teamName: `Arsenal` },
      { id: 22, name: `Trossard`,    pos: 'ST', team: 'away', teamName: `Arsenal` },
    ],
    events: [
      { min:  9, type: 'goal',    playerId: 22 },  // Trossard
      { min: 27, type: 'yellow',  playerId:  6 },  // Caicedo
      { min: 35, type: 'goal',    playerId: 19 },  // Saka
      { min: 53, type: 'goal',    playerId: 22 },  // Trossard
      { min: 73, type: 'goal',    playerId: 20 },  // Havertz
      { min: 81, type: 'goal',    playerId: 22 },  // Trossard hat-trick
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 23: Brentford 4-1 Chelsea, 19 Oct 2022 ─────────────
  {
    id: 'bre_4-1_che_2022',
    meta: {
      home: 'Brentford', away: 'Chelsea', score: '4-1', homeColour: '#E30613', awayColour: '#034694',
      date: '19 Oct 2022', label: `Premier League · Wed 19 Oct 2022 · 7:45pm BST`,
      blurb: `Brentford Community Stadium. <strong>Chelsea were in freefall under Potter</strong> — no wins in five. Brentford were the Premier League's surprise package. Ivan Toney magnificent. Four goals. One of Chelsea's most humbling nights.`,
      finalCommentary: `<strong>Full time.</strong> Brentford 4–1 Chelsea. Ivan Toney dominates. Chelsea's crisis deepens.`,
      lateCommentary: `Four! Brentford are sensational. Chelsea have no answers.`,
    },
    players: [
      { id:  1, name: `Flekken`,     pos: 'GK', team: 'home', teamName: `Brentford` },
      { id:  2, name: `Hickey`,      pos: 'RB', team: 'home', teamName: `Brentford` },
      { id:  3, name: `Pinnock`,     pos: 'CB', team: 'home', teamName: `Brentford` },
      { id:  4, name: `Collins`,     pos: 'CB', team: 'home', teamName: `Brentford` },
      { id:  5, name: `Henry`,       pos: 'LB', team: 'home', teamName: `Brentford` },
      { id:  6, name: `Nørgaard`,    pos: 'DM', team: 'home', teamName: `Brentford` },
      { id:  7, name: `Janelt`,      pos: 'CM', team: 'home', teamName: `Brentford` },
      { id:  8, name: `Jensen`,      pos: 'CM', team: 'home', teamName: `Brentford` },
      { id:  9, name: `Mbeumo`,      pos: 'RW', team: 'home', teamName: `Brentford` },
      { id: 10, name: `Toney`,       pos: 'ST', team: 'home', teamName: `Brentford` },
      { id: 11, name: `Wissa`,       pos: 'LW', team: 'home', teamName: `Brentford` },
      { id: 12, name: `Kepa`,        pos: 'GK', team: 'away', teamName: `Chelsea` },
      { id: 13, name: `Chalobah`,    pos: 'RB', team: 'away', teamName: `Chelsea` },
      { id: 14, name: `Thiago Silva`, pos: 'CB', team: 'away', teamName: `Chelsea` },
      { id: 15, name: `Koulibaly`,   pos: 'CB', team: 'away', teamName: `Chelsea` },
      { id: 16, name: `Cucurella`,   pos: 'LB', team: 'away', teamName: `Chelsea` },
      { id: 17, name: `Jorginho`,    pos: 'DM', team: 'away', teamName: `Chelsea` },
      { id: 18, name: `Kovacic`,     pos: 'CM', team: 'away', teamName: `Chelsea` },
      { id: 19, name: `Mount`,       pos: 'AM', team: 'away', teamName: `Chelsea` },
      { id: 20, name: `Sterling`,    pos: 'RW', team: 'away', teamName: `Chelsea` },
      { id: 21, name: `Pulisic`,     pos: 'LW', team: 'away', teamName: `Chelsea` },
      { id: 22, name: `Aubameyang`,  pos: 'ST', team: 'away', teamName: `Chelsea` },
    ],
    events: [
      { min: 18, type: 'goal',    playerId: 10 },  // Toney
      { min: 28, type: 'goal',    playerId: 22 },  // Aubameyang
      { min: 34, type: 'goal',    playerId: 10 },  // Toney
      { min: 43, type: 'yellow',  playerId: 15 },  // Koulibaly
      { min: 55, type: 'goal',    playerId:  9 },  // Mbeumo
      { min: 72, type: 'goal',    playerId: 11 },  // Wissa
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 24: Liverpool 5-1 Arsenal, 8 Feb 2014 ──────────────
  {
    id: 'liv_5-1_ars_2014',
    meta: {
      home: 'Liverpool', away: 'Arsenal', score: '5-1', homeColour: '#C8102E', awayColour: '#EF0107',
      date: '8 Feb 2014', label: `Premier League · Sat 8 Feb 2014 · 5:30pm GMT`,
      blurb: `Anfield. <strong>Liverpool were five points off the top</strong> with a game in hand, chasing their first title in 24 years. Arsenal were the leaders. Suárez was unstoppable. Five goals, one of the great Anfield nights, and the title race turned on its axis.`,
      finalCommentary: `<strong>Full time.</strong> Liverpool 5–1 Arsenal. Suárez magnificent. The title race is on.`,
      lateCommentary: `Five! Liverpool are extraordinary. Anfield believing now.`,
    },
    players: [
      { id:  1, name: `Mignolet`,    pos: 'GK', team: 'home', teamName: `Liverpool` },
      { id:  2, name: `Johnson`,     pos: 'RB', team: 'home', teamName: `Liverpool` },
      { id:  3, name: `Skrtel`,      pos: 'CB', team: 'home', teamName: `Liverpool` },
      { id:  4, name: `Agger`,       pos: 'CB', team: 'home', teamName: `Liverpool` },
      { id:  5, name: `Cissokho`,    pos: 'LB', team: 'home', teamName: `Liverpool` },
      { id:  6, name: `Gerrard`,     pos: 'DM', team: 'home', teamName: `Liverpool` },
      { id:  7, name: `Henderson`,   pos: 'CM', team: 'home', teamName: `Liverpool` },
      { id:  8, name: `Allen`,       pos: 'CM', team: 'home', teamName: `Liverpool` },
      { id:  9, name: `Sterling`,    pos: 'RW', team: 'home', teamName: `Liverpool` },
      { id: 10, name: `Suárez`,      pos: 'ST', team: 'home', teamName: `Liverpool` },
      { id: 11, name: `Sturridge`,   pos: 'LW', team: 'home', teamName: `Liverpool` },
      { id: 12, name: `Fabianski`,   pos: 'GK', team: 'away', teamName: `Arsenal` },
      { id: 13, name: `Sagna`,       pos: 'RB', team: 'away', teamName: `Arsenal` },
      { id: 14, name: `Mertesacker`, pos: 'CB', team: 'away', teamName: `Arsenal` },
      { id: 15, name: `Koscielny`,   pos: 'CB', team: 'away', teamName: `Arsenal` },
      { id: 16, name: `Gibbs`,       pos: 'LB', team: 'away', teamName: `Arsenal` },
      { id: 17, name: `Flamini`,     pos: 'DM', team: 'away', teamName: `Arsenal` },
      { id: 18, name: `Arteta`,      pos: 'CM', team: 'away', teamName: `Arsenal` },
      { id: 19, name: `Walcott`,     pos: 'RW', team: 'away', teamName: `Arsenal` },
      { id: 20, name: `Özil`,        pos: 'AM', team: 'away', teamName: `Arsenal` },
      { id: 21, name: `Gnabry`,      pos: 'LW', team: 'away', teamName: `Arsenal` },
      { id: 22, name: `Giroud`,      pos: 'ST', team: 'away', teamName: `Arsenal` },
    ],
    events: [
      { min: 16, type: 'goal',    playerId: 11 },  // Sturridge
      { min: 31, type: 'goal',    playerId: 10 },  // Suárez
      { min: 37, type: 'goal',    playerId: 22 },  // Giroud
      { min: 52, type: 'goal',    playerId: 10 },  // Suárez
      { min: 56, type: 'goal',    playerId: 10 },  // Suárez hat-trick
      { min: 61, type: 'yellow',  playerId: 17 },  // Flamini
      { min: 67, type: 'goal',    playerId:  9 },  // Sterling
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 25: Chelsea 6-0 Arsenal, 22 Mar 2014 ───────────────
  {
    id: 'che_6-0_ars_2014',
    meta: {
      home: 'Chelsea', away: 'Arsenal', score: '6-0', homeColour: '#034694', awayColour: '#EF0107',
      date: '22 Mar 2014', label: `Premier League · Sat 22 Mar 2014 · 5:30pm GMT`,
      blurb: `Stamford Bridge. <strong>Arsenal's heaviest defeat in 115 years.</strong> They arrived as title contenders. Mourinho's Chelsea were clinical, organised, merciless. Özil invisible. Fabianski at fault. A day Arsenal fans have spent a decade trying to forget.`,
      finalCommentary: `<strong>Full time.</strong> Chelsea 6–0 Arsenal. Arsenal's worst defeat in over a century.`,
      lateCommentary: `Six! Mourinho punches the air. Arsenal are shellshocked.`,
    },
    players: [
      { id:  1, name: `Čech`,        pos: 'GK', team: 'home', teamName: `Chelsea` },
      { id:  2, name: `Ivanovic`,    pos: 'RB', team: 'home', teamName: `Chelsea` },
      { id:  3, name: `Terry`,       pos: 'CB', team: 'home', teamName: `Chelsea` },
      { id:  4, name: `Cahill`,      pos: 'CB', team: 'home', teamName: `Chelsea` },
      { id:  5, name: `Cole`,        pos: 'LB', team: 'home', teamName: `Chelsea` },
      { id:  6, name: `Mikel`,       pos: 'DM', team: 'home', teamName: `Chelsea` },
      { id:  7, name: `Ramires`,     pos: 'CM', team: 'home', teamName: `Chelsea` },
      { id:  8, name: `Lampard`,     pos: 'CM', team: 'home', teamName: `Chelsea` },
      { id:  9, name: `Willian`,     pos: 'RW', team: 'home', teamName: `Chelsea` },
      { id: 10, name: `Torres`,      pos: 'ST', team: 'home', teamName: `Chelsea` },
      { id: 11, name: `Hazard`,      pos: 'LW', team: 'home', teamName: `Chelsea` },
      { id: 12, name: `Fabianski`,   pos: 'GK', team: 'away', teamName: `Arsenal` },
      { id: 13, name: `Sagna`,       pos: 'RB', team: 'away', teamName: `Arsenal` },
      { id: 14, name: `Mertesacker`, pos: 'CB', team: 'away', teamName: `Arsenal` },
      { id: 15, name: `Koscielny`,   pos: 'CB', team: 'away', teamName: `Arsenal` },
      { id: 16, name: `Gibbs`,       pos: 'LB', team: 'away', teamName: `Arsenal` },
      { id: 17, name: `Flamini`,     pos: 'DM', team: 'away', teamName: `Arsenal` },
      { id: 18, name: `Arteta`,      pos: 'CM', team: 'away', teamName: `Arsenal` },
      { id: 19, name: `Walcott`,     pos: 'RW', team: 'away', teamName: `Arsenal` },
      { id: 20, name: `Özil`,        pos: 'AM', team: 'away', teamName: `Arsenal` },
      { id: 21, name: `Rosicky`,     pos: 'LW', team: 'away', teamName: `Arsenal` },
      { id: 22, name: `Giroud`,      pos: 'ST', team: 'away', teamName: `Arsenal` },
    ],
    events: [
      { min: 17, type: 'goal',    playerId: 11 },  // Hazard pen
      { min: 26, type: 'goal',    playerId: 10 },  // Torres
      { min: 34, type: 'yellow',  playerId: 17 },  // Flamini
      { min: 42, type: 'goal',    playerId:  9 },  // Willian
      { min: 58, type: 'goal',    playerId:  8 },  // Lampard
      { min: 68, type: 'goal',    playerId: 10 },  // Torres
      { min: 76, type: 'goal',    playerId: 11 },  // Hazard
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 26: Bournemouth 4-0 Chelsea, 30 Jan 2019 ───────────
  {
    id: 'bou_4-0_che_2019',
    meta: {
      home: 'Bournemouth', away: 'Chelsea', score: '4-0', homeColour: '#DA291C', awayColour: '#034694',
      date: '30 Jan 2019', label: `Premier League · Wed 30 Jan 2019 · 7:45pm GMT`,
      blurb: `Vitality Stadium. <strong>Chelsea were in Sarri's first season</strong> — inconsistent but with moments of brilliance. Bournemouth tore them apart. Wilson two goals. Fraser outstanding. Chelsea's defence completely at sea.`,
      finalCommentary: `<strong>Full time.</strong> Bournemouth 4–0 Chelsea. Sarri-ball derailed.`,
      lateCommentary: `Four! Bournemouth complete a sensational victory.`,
    },
    players: [
      { id:  1, name: `Boruc`,       pos: 'GK', team: 'home', teamName: `Bournemouth` },
      { id:  2, name: `Clyne`,       pos: 'RB', team: 'home', teamName: `Bournemouth` },
      { id:  3, name: `Cook`,        pos: 'CB', team: 'home', teamName: `Bournemouth` },
      { id:  4, name: `Ake`,         pos: 'CB', team: 'home', teamName: `Bournemouth` },
      { id:  5, name: `Smith`,       pos: 'LB', team: 'home', teamName: `Bournemouth` },
      { id:  6, name: `Lerma`,       pos: 'DM', team: 'home', teamName: `Bournemouth` },
      { id:  7, name: `Surman`,      pos: 'CM', team: 'home', teamName: `Bournemouth` },
      { id:  8, name: `Fraser`,      pos: 'RW', team: 'home', teamName: `Bournemouth` },
      { id:  9, name: `Brooks`,      pos: 'AM', team: 'home', teamName: `Bournemouth` },
      { id: 10, name: `King`,        pos: 'LW', team: 'home', teamName: `Bournemouth` },
      { id: 11, name: `Wilson`,      pos: 'ST', team: 'home', teamName: `Bournemouth` },
      { id: 12, name: `Kepa`,        pos: 'GK', team: 'away', teamName: `Chelsea` },
      { id: 13, name: `Azpilicueta`, pos: 'RB', team: 'away', teamName: `Chelsea` },
      { id: 14, name: `Rüdiger`,     pos: 'CB', team: 'away', teamName: `Chelsea` },
      { id: 15, name: `Luiz`,        pos: 'CB', team: 'away', teamName: `Chelsea` },
      { id: 16, name: `Emerson`,     pos: 'LB', team: 'away', teamName: `Chelsea` },
      { id: 17, name: `Jorginho`,    pos: 'DM', team: 'away', teamName: `Chelsea` },
      { id: 18, name: `Kovacic`,     pos: 'CM', team: 'away', teamName: `Chelsea` },
      { id: 19, name: `Willian`,     pos: 'RW', team: 'away', teamName: `Chelsea` },
      { id: 20, name: `Hazard`,      pos: 'LW', team: 'away', teamName: `Chelsea` },
      { id: 21, name: `Barkley`,     pos: 'AM', team: 'away', teamName: `Chelsea` },
      { id: 22, name: `Giroud`,      pos: 'ST', team: 'away', teamName: `Chelsea` },
    ],
    events: [
      { min:  8, type: 'goal',    playerId: 11 },  // Wilson
      { min: 26, type: 'goal',    playerId:  9 },  // Brooks
      { min: 51, type: 'goal',    playerId: 11 },  // Wilson
      { min: 56, type: 'yellow',  playerId: 17 },  // Jorginho
      { min: 71, type: 'goal',    playerId: 10 },  // King
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 27: Arsenal 4-3 Liverpool, 14 Aug 2016 ─────────────
  {
    id: 'ars_4-3_liv_2016',
    meta: {
      home: 'Arsenal', away: 'Liverpool', score: '4-3', homeColour: '#EF0107', awayColour: '#C8102E',
      date: '14 Aug 2016', label: `Premier League · Sun 14 Aug 2016 · 4:00pm BST`,
      blurb: `The Emirates. <strong>Opening day of the season.</strong> Liverpool led 4-1. Klopp's pressing system overwhelming Arsenal. Then Arsenal scored three in 20 minutes. Oxlade-Chamberlain wonder strike. The most dramatic opening day in Premier League history.`,
      finalCommentary: `<strong>Full time.</strong> Arsenal 4–3 Liverpool. Three goals in 20 minutes. What a start to the season.`,
      lateCommentary: `Arsenal have completed the comeback! Four-three!`,
    },
    players: [
      { id:  1, name: `Čech`,        pos: 'GK', team: 'home', teamName: `Arsenal` },
      { id:  2, name: `Bellerin`,    pos: 'RB', team: 'home', teamName: `Arsenal` },
      { id:  3, name: `Mustafi`,     pos: 'CB', team: 'home', teamName: `Arsenal` },
      { id:  4, name: `Koscielny`,   pos: 'CB', team: 'home', teamName: `Arsenal` },
      { id:  5, name: `Monreal`,     pos: 'LB', team: 'home', teamName: `Arsenal` },
      { id:  6, name: `Xhaka`,       pos: 'DM', team: 'home', teamName: `Arsenal` },
      { id:  7, name: `Coquelin`,    pos: 'CM', team: 'home', teamName: `Arsenal` },
      { id:  8, name: `Oxlade-Chamberlain`, pos: 'RW', team: 'home', teamName: `Arsenal` },
      { id:  9, name: `Özil`,        pos: 'AM', team: 'home', teamName: `Arsenal` },
      { id: 10, name: `Sanchez`,     pos: 'LW', team: 'home', teamName: `Arsenal` },
      { id: 11, name: `Giroud`,      pos: 'ST', team: 'home', teamName: `Arsenal` },
      { id: 12, name: `Mignolet`,    pos: 'GK', team: 'away', teamName: `Liverpool` },
      { id: 13, name: `Clyne`,       pos: 'RB', team: 'away', teamName: `Liverpool` },
      { id: 14, name: `Lovren`,      pos: 'CB', team: 'away', teamName: `Liverpool` },
      { id: 15, name: `Matip`,       pos: 'CB', team: 'away', teamName: `Liverpool` },
      { id: 16, name: `Milner`,      pos: 'LB', team: 'away', teamName: `Liverpool` },
      { id: 17, name: `Henderson`,   pos: 'DM', team: 'away', teamName: `Liverpool` },
      { id: 18, name: `Wijnaldum`,   pos: 'CM', team: 'away', teamName: `Liverpool` },
      { id: 19, name: `Mané`,        pos: 'RW', team: 'away', teamName: `Liverpool` },
      { id: 20, name: `Coutinho`,    pos: 'AM', team: 'away', teamName: `Liverpool` },
      { id: 21, name: `Lallana`,     pos: 'LW', team: 'away', teamName: `Liverpool` },
      { id: 22, name: `Firmino`,     pos: 'ST', team: 'away', teamName: `Liverpool` },
    ],
    events: [
      { min: 30, type: 'goal',    playerId: 22 },  // Firmino
      { min: 32, type: 'goal',    playerId: 19 },  // Mané
      { min: 44, type: 'goal',    playerId: 11 },  // Giroud
      { min: 49, type: 'goal',    playerId: 20 },  // Coutinho
      { min: 54, type: 'goal',    playerId: 22 },  // Firmino
      { min: 63, type: 'yellow',  playerId:  6 },  // Xhaka
      { min: 71, type: 'goal',    playerId: 10 },  // Sanchez
      { min: 79, type: 'goal',    playerId:  8 },  // Oxlade-Chamberlain
      { min: 85, type: 'goal',    playerId:  9 },  // Özil
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 28: Tottenham 4-5 Arsenal, 13 Nov 2004 ─────────────
  {
    id: 'tot_4-5_ars_2004',
    meta: {
      home: 'Tottenham', away: 'Arsenal', score: '4-5', homeColour: '#132257', awayColour: '#EF0107',
      date: '13 Nov 2004', label: `Premier League · Sun 13 Nov 2004 · 4:05pm GMT`,
      blurb: `White Hart Lane. <strong>Arsenal were the Invincibles</strong> — unbeaten all season, the best team in England. Henry was unstoppable, Bergkamp orchestrating behind. Spurs had their own quality — Keane, Kanoute, Redknapp. A north London derby with everything at stake.`,
      finalCommentary: `<strong>Full time.</strong> Tottenham 4–5 Arsenal. Henry hat-trick. The Invincibles survive.`,
      lateCommentary: `Henry again! Arsenal lead! The Invincibles are unbeaten!`,
    },
    players: [
      { id:  1, name: `Robinson`,    pos: 'GK', team: 'home', teamName: `Tottenham` },
      { id:  2, name: `Kelly`,       pos: 'RB', team: 'home', teamName: `Tottenham` },
      { id:  3, name: `King`,        pos: 'CB', team: 'home', teamName: `Tottenham` },
      { id:  4, name: `Gardner`,     pos: 'CB', team: 'home', teamName: `Tottenham` },
      { id:  5, name: `Edman`,       pos: 'LB', team: 'home', teamName: `Tottenham` },
      { id:  6, name: `Brown`,       pos: 'DM', team: 'home', teamName: `Tottenham` },
      { id:  7, name: `Carrick`,     pos: 'CM', team: 'home', teamName: `Tottenham` },
      { id:  8, name: `Redknapp`,    pos: 'CM', team: 'home', teamName: `Tottenham` },
      { id:  9, name: `Defoe`,       pos: 'RW', team: 'home', teamName: `Tottenham` },
      { id: 10, name: `Kanoute`,     pos: 'LW', team: 'home', teamName: `Tottenham` },
      { id: 11, name: `Keane`,       pos: 'ST', team: 'home', teamName: `Tottenham` },
      { id: 12, name: `Lehmann`,     pos: 'GK', team: 'away', teamName: `Arsenal` },
      { id: 13, name: `Lauren`,      pos: 'RB', team: 'away', teamName: `Arsenal` },
      { id: 14, name: `Toure`,       pos: 'CB', team: 'away', teamName: `Arsenal` },
      { id: 15, name: `Campbell`,    pos: 'CB', team: 'away', teamName: `Arsenal` },
      { id: 16, name: `Cole`,        pos: 'LB', team: 'away', teamName: `Arsenal` },
      { id: 17, name: `Vieira`,      pos: 'DM', team: 'away', teamName: `Arsenal` },
      { id: 18, name: `Gilberto`,    pos: 'CM', team: 'away', teamName: `Arsenal` },
      { id: 19, name: `Ljungberg`,   pos: 'RW', team: 'away', teamName: `Arsenal` },
      { id: 20, name: `Bergkamp`,    pos: 'AM', team: 'away', teamName: `Arsenal` },
      { id: 21, name: `Pires`,       pos: 'LW', team: 'away', teamName: `Arsenal` },
      { id: 22, name: `Henry`,       pos: 'ST', team: 'away', teamName: `Arsenal` },
    ],
    events: [
      { min: 23, type: 'goal',    playerId: 11 },  // Keane
      { min: 30, type: 'goal',    playerId: 22 },  // Henry
      { min: 37, type: 'goal',    playerId:  9 },  // Defoe
      { min: 40, type: 'goal',    playerId: 11 },  // Keane
      { min: 56, type: 'goal',    playerId: 22 },  // Henry
      { min: 66, type: 'goal',    playerId:  9 },  // Defoe
      { min: 69, type: 'goal',    playerId: 10 },  // Kanoute
      { min: 75, type: 'goal',    playerId: 22 },  // Henry hat-trick
      { min: 80, type: 'goal',    playerId: 20 },  // Bergkamp
      { min: 84, type: 'goal',    playerId: 21 },  // Pires
      { min: 90, type: 'full_90' },
    ],
  },

  // ── MATCH 30: Man City 3-2 QPR, 13 May 2012 ──────────────────
  {
    id: 'mci_3-2_qpr_2012',
    meta: {
      home: 'Man City', away: 'QPR', score: '3-2', homeColour: '#6CABDD', awayColour: '#1D5BA4',
      date: '13 May 2012', label: `Premier League · Sun 13 May 2012 · 5:00pm BST`,
      blurb: `The Etihad. <strong>City needed to win to take the title from United.</strong> QPR were battling relegation. City led then trailed 2-1 with 10 minutes left. Džeko made it 2-2. Then, in injury time, Agüero. The most dramatic moment in Premier League history.`,
      finalCommentary: `<strong>Full time.</strong> Manchester City 3–2 QPR. AGUEROOOO. City are champions.`,
      lateCommentary: `AGUEROOOO! Ninety-four minutes! City are champions! Unbelievable!`,
    },
    players: [
      { id:  1, name: `Hart`,        pos: 'GK', team: 'home', teamName: `Man City` },
      { id:  2, name: `Zabaleta`,    pos: 'RB', team: 'home', teamName: `Man City` },
      { id:  3, name: `Kompany`,     pos: 'CB', team: 'home', teamName: `Man City` },
      { id:  4, name: `Lescott`,     pos: 'CB', team: 'home', teamName: `Man City` },
      { id:  5, name: `Clichy`,      pos: 'LB', team: 'home', teamName: `Man City` },
      { id:  6, name: `De Bruyne`,   pos: 'CM', team: 'home', teamName: `Man City` },
      { id:  7, name: `Barry`,       pos: 'DM', team: 'home', teamName: `Man City` },
      { id:  8, name: `Silva`,       pos: 'AM', team: 'home', teamName: `Man City` },
      { id:  9, name: `Nasri`,       pos: 'RW', team: 'home', teamName: `Man City` },
      { id: 10, name: `Agüero`,      pos: 'ST', team: 'home', teamName: `Man City` },
      { id: 11, name: `Džeko`,       pos: 'LW', team: 'home', teamName: `Man City` },
      { id: 12, name: `Kenny`,       pos: 'GK', team: 'away', teamName: `QPR` },
      { id: 13, name: `Onuoha`,      pos: 'RB', team: 'away', teamName: `QPR` },
      { id: 14, name: `Ferdinand`,   pos: 'CB', team: 'away', teamName: `QPR` },
      { id: 15, name: `Hill`,        pos: 'CB', team: 'away', teamName: `QPR` },
      { id: 16, name: `Taiwo`,       pos: 'LB', team: 'away', teamName: `QPR` },
      { id: 17, name: `Barton`,      pos: 'DM', team: 'away', teamName: `QPR` },
      { id: 18, name: `Derry`,       pos: 'CM', team: 'away', teamName: `QPR` },
      { id: 19, name: `Mackie`,      pos: 'RW', team: 'away', teamName: `QPR` },
      { id: 20, name: `Wright-Phillips`, pos: 'LW', team: 'away', teamName: `QPR` },
      { id: 21, name: `Cissé`,       pos: 'AM', team: 'away', teamName: `QPR` },
      { id: 22, name: `Taarabt`,     pos: 'ST', team: 'away', teamName: `QPR` },
    ],
    events: [
      { min: 39, type: 'goal',    playerId: 10 },  // Agüero
      { min: 48, type: 'red',     playerId: 17 },  // Barton red card
      { min: 55, type: 'goal',    playerId: 21 },  // Cissé
      { min: 66, type: 'goal',    playerId: 19 },  // Mackie
      { min: 73, type: 'yellow',  playerId: 14 },  // Ferdinand
      { min: 90, type: 'goal',    playerId: 11 },  // Džeko
      { min: 94, type: 'goal',    playerId: 10 },  // AGÜERO
      { min: 90, type: 'full_90' },
    ],
  },

];

// ── Active match globals — set by loadMatch() ─────────────────
let MATCH   = {};
let PLAYERS = [];
let EVENTS  = [];

function loadMatch(idx) {
  const m = ALL_MATCHES[idx];
  state.matchIdx = idx;

  MATCH = {
    home:  m.meta.home,
    away:  m.meta.away,
    score: m.meta.score,
    date:  m.meta.date,
  };

  // Re-number player IDs 1-22 so scoring logic stays simple
  PLAYERS = m.players.map((p, i) => ({
    ...p,
    id: i + 1,
    team: p.team === 'home' ? 'home' : 'away',
  }));

  // Remap event playerIds based on original id → new sequential id
  const idMap = {};
  m.players.forEach((p, i) => { idMap[p.id] = i + 1; });
  EVENTS = m.events.map(e => ({
    ...e,
    playerId: e.playerId !== undefined ? idMap[e.playerId] : undefined,
  }));


  // ── Club colour + alternate kit lookup ────────────────────────
  // Alt colours are the away/third kit used when home colours clash
  const CLUB_COLOURS = {
    'Man City':    { primary: '#6CABDD', alt: '#FFD700', initials: 'MC', bg: '#1c5493' },
    'Watford':     { primary: '#FBEE23', alt: '#ED2127', initials: 'WA', bg: '#000000' },
    'Leicester':   { primary: '#003090', alt: '#FFD700', initials: 'LC', bg: '#003090' },
    'Man United':  { primary: '#DA291C', alt: '#FFD700', initials: 'MU', bg: '#DA291C' },
    'Arsenal':     { primary: '#EF0107', alt: '#063672', initials: 'AR', bg: '#EF0107' },
    'Liverpool':   { primary: '#C8102E', alt: '#00B2A9', initials: 'LI', bg: '#C8102E' },
    'Newcastle':   { primary: '#241F20', alt: '#41B6E6', initials: 'NC', bg: '#241F20' },
    'West Ham':    { primary: '#7A263A', alt: '#1BB1E7', initials: 'WH', bg: '#7A263A' },
    'Tottenham':   { primary: '#132257', alt: '#FFFFFF', initials: 'TH', bg: '#132257' },
    'Sunderland':  { primary: '#EB172B', alt: '#FFFFFF', initials: 'SU', bg: '#EB172B' },
    'Chelsea':     { primary: '#034694', alt: '#FFD700', initials: 'CH', bg: '#034694' },
    'Everton':     { primary: '#003399', alt: '#FFFFFF', initials: 'EV', bg: '#003399' },
    'Aston Villa': { primary: '#95BFE5', alt: '#670E36', initials: 'AV', bg: '#670E36' },
    'Leeds':       { primary: '#FFCD00', alt: '#1D428A', initials: 'LU', bg: '#1D428A' },
  };

  // Apply team colours as CSS custom properties
  const root = document.documentElement;
  let hc = m.meta.homeColour || '#6CABDD';
  let ac = m.meta.awayColour || '#FBEE23';

  // Clash detection — compare perceived colour distance
  // If too similar, use alt away colour
  function hexToRgb(hex) {
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return [r, g, b];
  }
  function colourDistance(h1, h2) {
    try {
      const [r1,g1,b1] = hexToRgb(h1);
      const [r2,g2,b2] = hexToRgb(h2);
      // Weighted euclidean distance matching human perception
      return Math.sqrt(2*(r1-r2)**2 + 4*(g1-g2)**2 + 3*(b1-b2)**2);
    } catch(e) { return 999; }
  }

  const CLASH_THRESHOLD = 80; // colours this similar trigger alt kit
  if (colourDistance(hc, ac) < CLASH_THRESHOLD) {
    // Try awayColourAlt from match data first, then club lookup
    const awayClub = CLUB_COLOURS[m.meta.away];
    ac = m.meta.awayColourAlt || awayClub?.alt || '#FFFFFF';
  }

  // Store resolved colours on state for badge rendering
  state.resolvedHomeColour = hc;
  state.resolvedAwayColour = ac;

  root.style.setProperty('--home-colour', hc);
  root.style.setProperty('--home-colour-dark', hc);
  root.style.setProperty('--home-colour-light', hc + '18');
  root.style.setProperty('--home-colour-border', hc + '55');
  root.style.setProperty('--away-colour', ac);
  root.style.setProperty('--away-colour-dark', ac);
  root.style.setProperty('--away-colour-light', ac + '18');
  root.style.setProperty('--away-colour-border', ac + '55');

  // Update all hardcoded HTML references
  updateMatchHTML(m);
  computeChaosValues();
}

// ── Team badge SVG generator ───────────────────────────────────
// Returns an inline SVG shield badge with team initials + colour
function getTeamBadge(teamName, colour, size) {
  size = size || 36;
  const CLUB_COLOURS = {
    'Man City':    { initials: 'MC' },
    'Watford':     { initials: 'WA' },
    'Leicester':   { initials: 'LC' },
    'Man United':  { initials: 'MU' },
    'Arsenal':     { initials: 'AR' },
    'Liverpool':   { initials: 'LI' },
    'Newcastle':   { initials: 'NC' },
    'West Ham':    { initials: 'WH' },
    'Tottenham':   { initials: 'TH' },
    'Sunderland':  { initials: 'SU' },
    'Chelsea':     { initials: 'CH' },
    'Everton':     { initials: 'EV' },
    'Aston Villa': { initials: 'AV' },
    'Leeds':       { initials: 'LU' },
  };
  const club = CLUB_COLOURS[teamName];
  const initials = club ? club.initials : (teamName || '??').slice(0,2).toUpperCase();

  // Determine text colour — white on dark backgrounds, dark on light
  function hexLuminance(hex) {
    try {
      const [r,g,b] = [parseInt(hex.slice(1,3),16), parseInt(hex.slice(3,5),16), parseInt(hex.slice(5,7),16)];
      return (0.299*r + 0.587*g + 0.114*b) / 255;
    } catch(e) { return 0.5; }
  }
  const textColour = hexLuminance(colour || '#333') > 0.55 ? '#111' : '#fff';
  const fs = Math.round(size * 0.32);

  // Shield path scaled to size
  const s = size;
  const shield = `M${s*0.5},${s*0.96} C${s*0.5},${s*0.96} ${s*0.05},${s*0.72} ${s*0.05},${s*0.42} L${s*0.05},${s*0.14} L${s*0.5},${s*0.04} L${s*0.95},${s*0.14} L${s*0.95},${s*0.42} C${s*0.95},${s*0.72} ${s*0.5},${s*0.96} ${s*0.5},${s*0.96} Z`;

  return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}" xmlns="http://www.w3.org/2000/svg">
    <path d="${shield}" fill="${colour || '#333'}" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
  </svg>`;
}

function updateMatchHTML(m) {
  // Match preview card
  const labelEl = document.querySelector('.match-preview-label');
  if (labelEl) labelEl.textContent = m.meta.label;

  const names = document.querySelectorAll('.match-team-name');
  if (names[0]) { names[0].textContent = m.meta.home; names[0].className = 'match-team-name home-team'; }
  if (names[1]) { names[1].textContent = m.meta.away; names[1].className = 'match-team-name away-team'; }

  const blurb = document.querySelector('.prematch-report');
  if (blurb) blurb.innerHTML = m.meta.blurb;

  // Draft header badge
  const badge = document.getElementById('match-badge');
  if (badge) badge.textContent = `${m.meta.home} vs ${m.meta.away} · DRAFT`;

  // Draft team filter tabs
  const tabHome = document.getElementById('toggle-home');
  const tabAway = document.getElementById('toggle-away');
  if (tabHome) tabHome.textContent = m.meta.home;
  if (tabAway) tabAway.textContent = m.meta.away;

  // Live scoreline
  const liveTeams = document.querySelector('.live-teams');
  if (liveTeams) liveTeams.innerHTML = `${m.meta.home} <strong id="live-home-score">0</strong> – <strong id="live-away-score">0</strong> ${m.meta.away}`;

  // Opening commentary line
  const commEl = document.getElementById('commentary');
  if (commEl) commEl.textContent = `${m.meta.home} vs ${m.meta.away} kicks off…`;

  // Result sub-header (will be overwritten by showResults too)
  const resSub = document.getElementById('result-sub');
  if (resSub) resSub.textContent = `${m.meta.home} ${m.meta.score} ${m.meta.away} · ${m.meta.date}`;
}

// ═══════════════════════════════════════════════════════════════
// SCORING SYSTEM
// ═══════════════════════════════════════════════════════════════

// Position group helper
function posGroup(pos) {
  if (pos === 'GK') return 'gk';
  if (['CB','RB','LB'].includes(pos)) return 'def';
  if (['CM','AM','DM'].includes(pos)) return 'mid';
  return 'fwd'; // ST, RW, LW
}

const SCORE_TABLE = {
  goal:       { fwd: -3,  mid: -4,  def: -6,  gk: -12 },
  assist:     { fwd: -3,  mid: -4,  def: -6,  gk: -10 },
  clean_sheet:{ fwd: -1,  mid: -2,  def: -2,  gk: -3  },
  full_90:    { fwd: -3,  mid: -3,  def: -3,  gk:  0  },
  yellow:     { fwd:  4,  mid:  4,  def:  4,  gk:  8  },
  red:        { fwd: 10,  mid: 10,  def: 10,  gk: 20  },
  own_goal:   10,
  missed_pen: 10,
  pen_save:  -10,
  concede_def: 1,   // per goal conceded (defender)
  concede_gk:  2,   // per goal conceded (GK)
  // subs — two tiers
  sub_halftime: { fwd: 5, mid: 5, def: 5, gk: 10 }, // subbed at or before HT (min <= 45)
  sub_before70: { fwd: 1, mid: 1, def: 2, gk:  5 }, // subbed 46–69
  // subbed 70+ = no bonus (zero)
};

function getScoreForEvent(eventType, player, extraData = {}) {
  const g = posGroup(player.pos);

  switch (eventType) {
    case 'goal': {
      const base = SCORE_TABLE.goal[g];
      // 3rd goal or assist = double
      const isThird = (extraData.nthEvent || 1) >= 3;
      return isThird ? base * 2 : base;
    }
    case 'assist': {
      const base = SCORE_TABLE.assist[g];
      const isThird = (extraData.nthEvent || 1) >= 3;
      return isThird ? base * 2 : base;
    }
    case 'yellow':     return SCORE_TABLE.yellow[g];
    case 'red':        return SCORE_TABLE.red[g];
    case 'own_goal':   return SCORE_TABLE.own_goal;
    case 'missed_pen': return SCORE_TABLE.missed_pen;
    case 'pen_save':   return SCORE_TABLE.pen_save;
    case 'clean_sheet':return SCORE_TABLE.clean_sheet[g];
    case 'full_90':    return SCORE_TABLE.full_90[g];
    case 'concede':
      return g === 'gk' ? SCORE_TABLE.concede_gk : (g === 'def' ? SCORE_TABLE.concede_def : 0);
    case 'sub': {
      const min = extraData.min || 90;
      if (min <= 45) return SCORE_TABLE.sub_halftime[g];
      if (min < 70)  return SCORE_TABLE.sub_before70[g];
      return 0;
    }
    default: return 0;
  }
}

// ═══════════════════════════════════════════════════════════════
// GAME STATE
// ═══════════════════════════════════════════════════════════════
let state = {
  myTeam: [],
  oppTeam: [],
  sequence: [],
  currentPick: 0,
  teamFilter: 'home',
  selectedPlayer: null,
  gkPickerIsMe: true,
  draftDone: false,
  myCaptain: null,
  oppCaptain: null,
  timerInterval: null,
  timerSecs: 30,
  simView: 'pitch',
  myScore: 0,
  oppScore: 0,
  playerData: {},
  teamName: '',
  teamEmoji: '',
  matchIdx: null,
  tipTaken: false,          // player looked at the reveal tip
  predictionPending: null,  // { resolve, isReal, eventType, playerName }
  predictionAnswer: null,   // true/false/null
  predictionTimerTimeout: null,
  autoPickLocked: false,    // prevents double auto-pick race condition
  mp: null,                 // multiplayer session object (null = single player)
  deltaHistory: [],         // [{min, delta, eventType}] for graph
  htSwapOut: null,          // player id being swapped out (my team)
  htSwapIn: null,           // player id being stolen (opp team)
  htSwapDone: false,        // swap already confirmed this halftime
  htTimerInterval: null,
};

function initPlayerData() {
  state.playerData = {};
  for (const p of PLAYERS) {
    state.playerData[p.id] = { pts: 0, events: [], subbed: false };
  }
}

// ═══════════════════════════════════════════════════════════════
// PROFILE SYSTEM
// ═══════════════════════════════════════════════════════════════

const PROFILE_STORAGE_KEY = 'worst-eleven-profiles';
const ARCHIVE_TOTAL = 7; // update as matches are added

// ── Badge definitions ─────────────────────────────────────────
const BADGE_DEFS = [
  { id: 'first_blood',   icon: '🩸', name: 'First Blood',    desc: 'Win your first game',           check: p => p.matches.some(m => m.result === 'W') },
  { id: 'hat_trick',     icon: '🎩', name: 'Hat Trick',      desc: 'Win 3 games',                   check: p => p.matches.filter(m => m.result === 'W').length >= 3 },
  { id: 'unstoppable',   icon: '💀', name: 'Unstoppable',    desc: 'Win 10 games',                  check: p => p.matches.filter(m => m.result === 'W').length >= 10 },
  { id: 'on_a_roll',     icon: '🔥', name: 'On a Roll',      desc: 'Win 3 in a row',                check: p => hasStreak(p, 'W', 3) },
  { id: 'hot_streak',    icon: '🌋', name: 'Hot Streak',     desc: 'Win 5 in a row',                check: p => hasStreak(p, 'W', 5) },
  { id: 'archivist',     icon: '📼', name: 'Archivist',      desc: 'Play all 7 archive matches',    check: p => uniqueMatchesPlayed(p) >= ARCHIVE_TOTAL },
  { id: 'half_way',      icon: '🗂️',  name: 'Half Way There', desc: 'Play 4 different matches',     check: p => uniqueMatchesPlayed(p) >= 4 },
  { id: 'century',       icon: '💯', name: 'Century',        desc: 'Win by 100+ total chaos pts',   check: p => p.matches.some(m => m.result === 'W' && (m.myScore - m.oppScore) >= 100) },
  { id: 'squeaky',       icon: '🤌', name: 'Squeaky',        desc: 'Win by 3 points or fewer',      check: p => p.matches.some(m => m.result === 'W' && (m.myScore - m.oppScore) <= 3) },
];

function hasStreak(profile, result, n) {
  const results = profile.matches.map(m => m.result);
  let streak = 0;
  for (const r of results) {
    streak = r === result ? streak + 1 : 0;
    if (streak >= n) return true;
  }
  return false;
}

function uniqueMatchesPlayed(profile) {
  return new Set(profile.matches.map(m => m.matchId)).size;
}

// ── Storage helpers ───────────────────────────────────────────
// Storage: localStorage is the expected persistence layer for this app
function loadProfiles() {
  try {
    const raw = localStorage.getItem(PROFILE_STORAGE_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch {
    return [];
  }
}

function saveProfiles(profiles) {
  try {
    localStorage.setItem(PROFILE_STORAGE_KEY, JSON.stringify(profiles));
  } catch (e) {
    console.warn('localStorage unavailable — profiles will not persist this session');
  }
}

// In-memory cache so we don't have to re-read localStorage everywhere
let _profiles = [];
let _activeProfileId = null;

function initProfiles() {
  _profiles = loadProfiles();
  renderHomeProfiles();
}

function getActiveProfile() {
  return _profiles.find(p => p.id === _activeProfileId) || null;
}

function createProfile(name, emoji) {
  const profile = {
    id: 'p_' + Date.now(),
    name,
    emoji,
    created: new Date().toISOString().slice(0, 10),
    matches: [],
  };
  _profiles.push(profile);
  saveProfiles(_profiles);
  return profile;
}

async function recordMatchResult({ matchId, matchLabel, result, myScore, oppScore, captainName }) {
  const profile = getActiveProfile();
  if (!profile) return;
  profile.matches.push({ matchId, matchLabel, result, myScore, oppScore, captainName, date: new Date().toISOString().slice(0, 10) });
  saveProfiles(_profiles);
}

// ── Home screen rendering ─────────────────────────────────────
function renderHomeProfiles() {
  const list = document.getElementById('home-profiles-list');
  if (!list) return;
  list.innerHTML = '';

  for (const p of _profiles) {
    const wins = p.matches.filter(m => m.result === 'W').length;
    const played = p.matches.length;
    const form = p.matches.slice(-5);

    const card = document.createElement('div');
    card.className = 'profile-card' + (p.id === _activeProfileId ? ' active-profile' : '');
    card.dataset.id = p.id;

    // Form pips
    const pipHtml = Array.from({ length: 5 }, (_, i) => {
      const m = form[form.length - 5 + i];
      if (!m) return `<div class="form-pip empty">·</div>`;
      return `<div class="form-pip ${m.result}">${m.result}</div>`;
    }).join('');

    card.innerHTML = `
      <div class="profile-card-emoji">${p.emoji}</div>
      <div class="profile-card-info">
        <div class="profile-card-name">${p.name}</div>
        <div class="profile-card-stats">${wins}W · ${played} played · ${played ? Math.round(wins/played*100) : 0}%</div>
        <div class="profile-card-form">${pipHtml}</div>
      </div>
      <button class="profile-card-viewbtn" onclick="event.stopPropagation();viewProfile('${p.id}')">Stats</button>
    `;
    card.addEventListener('click', () => selectProfile(p.id));
    list.appendChild(card);
  }

  // Show create form only when there are no profiles at all
  const newForm = document.getElementById('profile-new-form');
  const addBtn  = document.getElementById('profile-add-btn');
  if (newForm) {
    if (_profiles.length === 0) {
      newForm.classList.add('open');
      if (addBtn) addBtn.style.display = 'none';
    } else {
      newForm.classList.remove('open');
      if (addBtn) addBtn.style.display = 'block';
    }
  }

  // Update start button
  updateStartBtn();
}

function selectProfile(id) {
  _activeProfileId = id;
  const p = getActiveProfile();
  if (!p) return;

  // Pre-fill state
  state.teamName  = p.emoji + ' ' + p.name;
  state.teamEmoji = p.emoji;

  // Sync emoji button & name input for consistency
  const emojiBtn = document.getElementById('emoji-btn');
  const nameInput = document.getElementById('team-name-input');
  if (emojiBtn) emojiBtn.textContent = p.emoji;
  if (nameInput) nameInput.value = p.name;

  // Close new-profile form if open
  const form = document.getElementById('profile-new-form');
  if (form) form.classList.remove('open');

  renderHomeProfiles();
  updateStartBtn();
}

function updateStartBtn() {
  const btn   = document.getElementById('start-btn');
  const mpBtn = document.getElementById('mp-btn');
  if (btn)   btn.disabled   = !_activeProfileId;
  if (mpBtn) mpBtn.disabled = !_activeProfileId || !window._fbReady;
}

// ── New profile form ──────────────────────────────────────────
function openNewProfileForm() {
  _activeProfileId = null;
  const form   = document.getElementById('profile-new-form');
  const addBtn = document.getElementById('profile-add-btn');
  if (form)   form.classList.add('open');
  if (addBtn) addBtn.style.display = 'none';
  renderHomeProfiles();
  updateStartBtn();
  const input = document.getElementById('team-name-input');
  if (input) { input.value = ''; input.focus(); }
  const saveBtn = document.getElementById('profile-save-btn');
  if (saveBtn) saveBtn.disabled = true;
}

function confirmDeleteProfile() {
  const profile = getActiveProfile();
  if (!profile) return;
  if (!confirm(`Delete profile "${profile.name}"? This cannot be undone.`)) return;
  _profiles = _profiles.filter(p => p.id !== _activeProfileId);
  saveProfiles(_profiles);
  _activeProfileId = null;
  renderHomeProfiles();
  showScreen('home');
}

function saveNewProfile() {
  const name = document.getElementById('team-name-input')?.value.trim();
  const emoji = document.getElementById('emoji-btn')?.textContent || '⚽';
  if (!name || name.length < 2) return;
  const p = createProfile(name, emoji);
  selectProfile(p.id);
  const form = document.getElementById('profile-new-form');
  if (form) form.classList.remove('open');
  renderHomeProfiles();
}

// ── Profile screen ────────────────────────────────────────────
function viewProfile(id) {
  _activeProfileId = id;
  const p = _profiles.find(pr => pr.id === id);
  if (!p) return;

  // Header
  document.getElementById('profile-header-emoji').textContent = p.emoji;
  document.getElementById('profile-name-big').textContent = p.name;
  document.getElementById('profile-header-sub').textContent = 'Since ' + p.created;

  // Stats
  const wins = p.matches.filter(m => m.result === 'W').length;
  const losses = p.matches.filter(m => m.result === 'L').length;
  const played = p.matches.length;
  document.getElementById('profile-wins').textContent = wins;
  document.getElementById('profile-played').textContent = played;
  document.getElementById('profile-winpct').textContent = played ? Math.round(wins/played*100) + '%' : '—';

  // Form strip (last 5)
  const formEl = document.getElementById('profile-form-strip');
  const form = p.matches.slice(-5);
  formEl.innerHTML = Array.from({ length: 5 }, (_, i) => {
    const m = form[form.length - 5 + i];
    if (!m) return `<div class="profile-form-pill empty">·</div>`;
    return `<div class="profile-form-pill ${m.result}">${m.result}</div>`;
  }).join('');

  // Archive progress
  const unique = uniqueMatchesPlayed(p);
  const pct = Math.round(unique / ARCHIVE_TOTAL * 100);
  document.getElementById('profile-archive-fill').style.width = pct + '%';
  document.getElementById('profile-archive-label').textContent = `${unique} / ${ARCHIVE_TOTAL} archive matches played (${pct}%)`;

  // Badges
  const badgesEl = document.getElementById('profile-badges-grid');
  badgesEl.innerHTML = BADGE_DEFS.map(b => {
    const earned = b.check(p);
    return `
      <div class="profile-badge ${earned ? 'earned' : 'locked'}">
        <span class="profile-badge-icon">${b.icon}</span>
        <span class="profile-badge-name">${b.name}</span>
        <span class="profile-badge-desc">${b.desc}</span>
      </div>
    `;
  }).join('');

  showScreen('profile');
}

function viewActiveProfile() {
  if (_activeProfileId) viewProfile(_activeProfileId);
}

// ── Post-match form tile ──────────────────────────────────────
function renderPostMatchFormTile() {
  const profile = getActiveProfile();
  const section = document.getElementById('result-form-section');
  if (!profile || !section) return;

  section.style.display = '';
  const title = document.getElementById('result-form-section-title');
  if (title) title.textContent = profile.emoji + ' ' + profile.name;

  const wins = profile.matches.filter(m => m.result === 'W').length;
  const played = profile.matches.length;
  const form = profile.matches.slice(-5);

  const stripEl = document.getElementById('result-form-strip');
  if (stripEl) {
    stripEl.innerHTML = Array.from({ length: 5 }, (_, i) => {
      const m = form[form.length - 5 + i];
      if (!m) return `<div class="profile-form-pill empty" style="width:32px;height:32px;font-size:14px;">·</div>`;
      return `<div class="profile-form-pill ${m.result}" style="width:32px;height:32px;font-size:14px;">${m.result}</div>`;
    }).join('');
  }

  const statsEl = document.getElementById('result-form-stats');
  if (statsEl) statsEl.textContent = `${wins}W from ${played} played · ${played ? Math.round(wins/played*100) : 0}% win rate`;
}

// ── Init ──────────────────────────────────────────────────────
document.addEventListener('DOMContentLoaded', () => { initProfiles(); });

// ═══════════════════════════════════════════════════════════════
// NAVIGATION
// ═══════════════════════════════════════════════════════════════
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById('screen-' + id).classList.add('active');
  window.scrollTo(0, 0);
}

function goToDraft() {
  showScreen('coin');
  startCoinFlow();
}

// ═══════════════════════════════════════════════════════════════
// COIN SCREEN — 3-phase flow: load → reveal → flip → draft
// ═══════════════════════════════════════════════════════════════
const REEL_LINES = [
  'Searching the archives…',
  'Rewinding the tape…',
  'Dusting off the VHS…',
  'Checking the score sheets…',
  'Loading match data…',
  'Consulting the archives…',
  'Finding the highlights reel…',
];

function showCoinPhase(phase) {
  ['loading','reveal','flip'].forEach(p => {
    const el = document.getElementById('coin-phase-' + p);
    if (el) el.style.display = p === phase ? 'flex' : 'none';
  });
}

function startCoinFlow() {
  showCoinPhase('loading');

  // Cycle loading lines for 1.5s then pick match and reveal
  let t = 0;
  const linesEl = document.getElementById('coin-loading-lines');
  const lineInterval = setInterval(() => {
    linesEl.textContent = REEL_LINES[t % REEL_LINES.length];
    t++;
  }, 220);

  setTimeout(() => {
    clearInterval(lineInterval);

    // Pick random match
    let idx;
    do { idx = Math.floor(Math.random() * ALL_MATCHES.length); }
    while (ALL_MATCHES.length > 1 && idx === state.matchIdx);
    loadMatch(idx);

    revealMatch(ALL_MATCHES[idx]);
  }, 1500);
}

function revealMatch(m) {
  // Reset tip state for fresh game
  state.tipTaken = false;
  const tipBtn     = document.getElementById('reveal-tip-btn');
  const tipContent = document.getElementById('reveal-tip-content');
  const tipCost    = document.querySelector('.reveal-tip-cost');
  if (tipBtn)     { tipBtn.disabled = false; }
  if (tipContent) { tipContent.style.display = 'none'; tipContent.innerHTML = ''; }
  if (tipCost)    { tipCost.innerHTML = '−5 pts penalty if you look'; }

  document.getElementById('coin-reveal-matchup').textContent = `${m.meta.home} vs ${m.meta.away}`;
  document.getElementById('coin-reveal-date').textContent = m.meta.date.toUpperCase();
  document.getElementById('coin-reveal-blurb').innerHTML = m.meta.blurb;

  // Render team badges on coin reveal
  const coinBadgeRow = document.getElementById('coin-badges-row');
  if (coinBadgeRow) {
    const hc = state.resolvedHomeColour || m.meta.homeColour || '#6CABDD';
    const ac = state.resolvedAwayColour || m.meta.awayColour || '#FBEE23';
    coinBadgeRow.innerHTML = `
      <div class="match-badge-item">
        ${getTeamBadge(m.meta.home, hc, 44)}
        <div class="match-badge-name">${m.meta.home}</div>
      </div>
      <div class="match-badge-vs">vs</div>
      <div class="match-badge-item">
        ${getTeamBadge(m.meta.away, ac, 44)}
        <div class="match-badge-name">${m.meta.away}</div>
      </div>
    `;
  }

  showCoinPhase('reveal');

  // In multiplayer: countdown is driven by a shared Firebase timestamp so both
  // clients animate in perfect sync. startCoinCountdown() handles this.
  // In single-player: just start the countdown immediately.
  if (!state.mp) {
    startCoinCountdown(Date.now());
  }
  // In mp mode, the countdown is triggered by mpStartDraft once the
  // Firebase coinFlipStart timestamp has been written/read.
}

// Start the coin countdown bar synced to a wall-clock timestamp.
// startAt = Date.now()-compatible ms timestamp when the 10s countdown began.
function startCoinCountdown(startAt) {
  const fill  = document.getElementById('coin-countdown-fill');
  const label = document.getElementById('coin-countdown-label');
  const TOTAL = 10;

  // Calculate how much time has already elapsed (for late-joining guest)
  const elapsed = Math.min((Date.now() - startAt) / 1000, TOTAL);
  const remaining = TOTAL - elapsed;

  if (remaining <= 0) {
    // Already past — run flip immediately
    if (label) label.textContent = 'Flipping…';
    runCoinFlip();
    return;
  }

  // Animate bar from current position to 0 over remaining time
  const startPct = (remaining / TOTAL) * 100;
  if (fill) {
    fill.style.transition = 'none';
    fill.style.width = startPct + '%';
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        fill.style.transition = `width ${remaining}s linear`;
        fill.style.width = '0%';
      });
    });
  }

  let secsLeft = Math.ceil(remaining);
  if (label) label.textContent = secsLeft > 0 ? `Coin flip in ${secsLeft}…` : 'Flipping…';

  const tick = setInterval(() => {
    secsLeft--;
    const nowElapsed = (Date.now() - startAt) / 1000;
    const nowRemaining = TOTAL - nowElapsed;
    if (nowRemaining <= 0) {
      clearInterval(tick);
      if (label) label.textContent = 'Flipping…';
      runCoinFlip();
    } else {
      if (label) label.textContent = `Coin flip in ${Math.ceil(nowRemaining)}…`;
    }
  }, 500); // check every 0.5s for accuracy
}

function revealTip() {
  if (state.tipTaken) return;
  state.tipTaken = true;

  const m = ALL_MATCHES[state.matchIdx];
  if (!m) return;

  // Generate a tip from the real match events
  const goals = EVENTS.filter(e => e.type === 'goal');
  const reds  = EVENTS.filter(e => e.type === 'red');
  const homeGoals = goals.filter(e => PLAYERS.find(p => p.id === e.playerId && p.team === 'home')).length;
  const awayGoals = goals.filter(e => PLAYERS.find(p => p.id === e.playerId && p.team === 'away')).length;

  let tip;
  if (reds.length > 0 && Math.random() < 0.5) {
    // Tip about a red card — give team but not player
    const redPlayer = PLAYERS.find(p => p.id === reds[0].playerId);
    const teamName = redPlayer ? redPlayer.teamName : 'one of the teams';
    tip = `Someone from <strong>${teamName}</strong> won't last the full 90 minutes today.`;
  } else if (homeGoals !== awayGoals) {
    const moreTeam = homeGoals > awayGoals ? m.meta.home : m.meta.away;
    const diff = Math.abs(homeGoals - awayGoals);
    if (diff >= 3) {
      tip = `<strong>${moreTeam}</strong> are going to have a very good day. Draft accordingly.`;
    } else {
      tip = `<strong>${moreTeam}</strong> score more than the other side today.`;
    }
  } else {
    tip = `Both teams score in this one. It's a game of two halves.`;
  }

  const btn     = document.getElementById('reveal-tip-btn');
  const content = document.getElementById('reveal-tip-content');
  const cost    = document.querySelector('.reveal-tip-cost');

  if (btn) btn.disabled = true;
  if (cost) cost.innerHTML = `<span class="reveal-tip-taken">−5 pts applied at kick-off</span>`;
  if (content) {
    content.innerHTML = tip;
    content.style.display = '';
  }
}

function applyTipPenalty() {
  if (state.tipTaken) {
    state.myScore -= 5;
    updateScoreDisplay();
    flashPredResult('−5 TIP PENALTY', 'wrong');
  }
}

function runCoinFlip() {
  // In mp mode as guest — don't run the flip locally, the host runs it
  // and we'll receive the result via Firebase (mpShowCoinResultForGuest)
  if (state.mp && state.mp.role === 'B') return;

  showCoinPhase('flip');

  const coin   = document.getElementById('coin');
  const status = document.getElementById('coin-status');
  const sub    = document.getElementById('coin-sub');

  coin.textContent = '🪙';
  coin.style.transform = '';
  status.textContent = '';
  sub.textContent = '';

  // In mp (host): signal the guest that the spin is starting RIGHT NOW
  if (state.mp && state.mp.role === 'A') {
    window._fb.update(state.mp.sessionRef, { coinFlipAnimStart: Date.now() });
  }

  // Spin animation
  let flips = 0;
  const faces = ['🪙', '⚽'];
  const spinInterval = setInterval(() => {
    coin.textContent = faces[flips % 2];
    coin.style.transform = `rotateY(${flips * 180}deg) scale(${flips % 2 === 0 ? 1 : 0.85})`;
    flips++;
    if (flips > 10) {
      clearInterval(spinInterval);

      // Determine winner
      const playerWins = Math.random() < 0.5;
      coin.style.transform = '';
      coin.textContent = playerWins ? '✅' : '❌';

      if (playerWins) {
        status.textContent = 'YOU WIN';
        sub.textContent = 'You pick the goalkeeper first';
      } else {
        status.textContent = 'OPPONENT WINS';
        sub.textContent = 'Opponent picks the goalkeeper first';
      }

      // In mp mode (host only): write result to Firebase, then proceed to draft.
      // The host already SAW the flip here, so we skip _mpShowCoinResult for the host
      // and go straight to the draft after a short pause.
      if (state.mp && state.mp.role === 'A' && window._mpCoinDone) {
        // 2.5s pause so host can read the result, THEN write + proceed
        setTimeout(() => window._mpCoinDone(playerWins), 2500);
        return;
      }

      // Single player — set gkPickerIsMe and proceed
      state.gkPickerIsMe = playerWins;
      setTimeout(() => {
        setupDraft();
        showScreen('draft');
      }, 3000);
    }
  }, 120);
}
const TEAM_EMOJIS = ['⚽','🏆','🥅','🧤','🟨','🟥','🎽','🦵','👟','🏟️','🪄','💀','👑','🔥','💥','⚡','🤡','🐐','🫠','🤌'];
let emojiIndex = 0;
let emojiPickerOpen = false;

function buildEmojiGrid() {
  const grid = document.getElementById('emoji-grid');
  grid.innerHTML = '';
  TEAM_EMOJIS.forEach((em, i) => {
    const btn = document.createElement('button');
    btn.className = 'emoji-grid-item' + (i === emojiIndex ? ' selected' : '');
    btn.textContent = em;
    btn.onclick = () => selectEmoji(i);
    grid.appendChild(btn);
  });
}

function toggleEmojiPicker() {
  emojiPickerOpen = !emojiPickerOpen;
  const grid = document.getElementById('emoji-grid');
  if (emojiPickerOpen) {
    buildEmojiGrid();
    grid.style.display = 'grid';
  } else {
    grid.style.display = 'none';
  }
}

function selectEmoji(i) {
  emojiIndex = i;
  document.getElementById('emoji-btn').textContent = TEAM_EMOJIS[i];
  // Update selected state
  document.querySelectorAll('.emoji-grid-item').forEach((el, idx) => {
    el.classList.toggle('selected', idx === i);
  });
  // Close picker after short delay so tap feels responsive
  setTimeout(() => {
    document.getElementById('emoji-grid').style.display = 'none';
    emojiPickerOpen = false;
  }, 200);
}

function randomEmoji() {
  const i = Math.floor(Math.random() * TEAM_EMOJIS.length);
  emojiIndex = i;
  document.getElementById('emoji-btn').textContent = TEAM_EMOJIS[i];
  if (emojiPickerOpen) buildEmojiGrid();
}

function onTeamNameInput() {
  const val = document.getElementById('team-name-input')?.value.trim();
  const saveBtn = document.getElementById('profile-save-btn');
  if (saveBtn) saveBtn.disabled = !val || val.length < 2;
}

function startGame() {
  // Must have an active profile
  if (!_activeProfileId) return;
  const p = getActiveProfile();
  state.teamName  = p.emoji + ' ' + p.name;
  state.teamEmoji = p.emoji;
  goToDraft();
}

function restart() {
  state = {
    myTeam: [], oppTeam: [],
    sequence: [], currentPick: 0,
    teamFilter: 'home', selectedPlayer: null,
    gkPickerIsMe: true,
    draftDone: false, timerInterval: null, timerSecs: 30,
    myCaptain: null, oppCaptain: null, captainRandom: false, captainDiceBonus: 0,
    simView: 'pitch', myScore: 0, oppScore: 0, playerData: {},
    teamName: '', teamEmoji: '', matchIdx: null,
    tipTaken: false, predictionPending: null, predictionAnswer: null, predictionTimerTimeout: null,
    _tutShownCard: false, _tutShownGoal: false, _tutShownQuestion: false,
    _tutShownGkForced: false, _tutShownSabotage: false, _tutShownYourPicks: false,
    autoPickLocked: false,
    mp: null,
    deltaHistory: [],
    htSwapOut: null, htSwapIn: null, htSwapDone: false, htTimerInterval: null,
    htSwapRandomOut: null, htSwapRandomIn: null,
  };
  const form = document.getElementById('profile-new-form');
  if (form) form.classList.remove('open');
  const emojiGridEl = document.getElementById('emoji-grid');
  if (emojiGridEl) emojiGridEl.style.display = 'none';
  emojiIndex = 0;
  emojiPickerOpen = false;
  renderHomeProfiles(); // re-render so active profile stays highlighted
  showScreen('home');
}


// Replay the same match from scratch
function replayMatch() {
  const savedIdx = state.matchIdx;
  restart();
  // restart() goes to home; re-enter the match flow with same index
  setTimeout(() => {
    if (savedIdx !== null && ALL_MATCHES[savedIdx]) {
      revealMatch(ALL_MATCHES[savedIdx]);
    }
  }, 100);
}

// New game — pick a random different match
function newGame() {
  const oldIdx = state.matchIdx;
  restart();
  setTimeout(() => {
    let idx;
    do { idx = Math.floor(Math.random() * ALL_MATCHES.length); }
    while (ALL_MATCHES.length > 1 && idx === oldIdx);
    revealMatch(ALL_MATCHES[idx]);
  }, 100);
}

/*
  EXACT DRAFT SEQUENCE:
  Step 0:  GK winner picks GK for themselves → other GK auto to loser
  Steps 1–6:  3 sabotage rounds, loser leads each round
              loser sab1, winner sab1, loser sab2, winner sab2, loser sab3, winner sab3
  Steps 7–20: 7 normal rounds alternating, loser leads
              loser n1, winner n1, loser n2, winner n2 ... loser n7, winner n7

  We encode this as a flat array of {who, type} objects.
*/
function buildDraftSequence(gkWinner) {
  const winner = gkWinner;
  const loser  = gkWinner === 'me' ? 'opp' : 'me';
  const seq = [];

  // GK: winner picks, other is auto-assigned
  seq.push({ who: winner, type: 'gk' });

  // Sabotage rounds (picks go to opponent's squad):
  // Round 1: loser, winner
  // Round 2: winner, loser
  // Round 3: loser, winner
  seq.push({ who: loser,  type: 'sabotage' }); // Loser sab 1
  seq.push({ who: winner, type: 'sabotage' }); // Winner sab 1
  seq.push({ who: winner, type: 'sabotage' }); // Winner sab 2
  seq.push({ who: loser,  type: 'sabotage' }); // Loser sab 2
  seq.push({ who: loser,  type: 'sabotage' }); // Loser sab 3
  seq.push({ who: winner, type: 'sabotage' }); // Winner sab 3

  // Normal picks: loser leads, then alternate
  for (let i = 0; i < 7; i++) {
    seq.push({ who: loser,  type: 'normal' });
    seq.push({ who: winner, type: 'normal' });
  }

  return seq; // 21 steps: 1 GK + 6 sab + 14 normal
}

function setupDraft() {
  state.myTeam        = [];
  state.oppTeam       = [];
  state.currentPick   = 0;
  state.selectedPlayer = null;
  state.teamFilter    = 'home';

  const gkWinner = state.gkPickerIsMe !== false ? 'me' : 'opp';
  state.sequence = buildDraftSequence(gkWinner);

  // Set team name label from home screen
  const myLabel = document.getElementById('my-zone-label');
  if (myLabel) {
    const name = state.teamName || 'Your XI';
    myLabel.innerHTML = `<span class="dot yours"></span> ${name}`;
  }

  renderDraftSlots();
  renderCarousel();
  updateTurnUI();

  // If opponent won coin flip they do the GK pick first — auto-pick it
  if (gkWinner === 'opp') {
    setTimeout(() => autoPickGK(), 1000);
  } else {
    startTimer(10); // GK pick: 10 second timer
  }
}

function currentStep() {
  return state.sequence[state.currentPick] || null;
}

function renderDraftSlots() {
  const oppEl = document.getElementById('opp-slots');
  const myEl  = document.getElementById('my-slots');
  oppEl.innerHTML = '';
  myEl.innerHTML  = '';

  for (let i = 0; i < 11; i++) {
    const oSlot = document.createElement('div');
    oSlot.className = 'player-slot ' + (i < state.oppTeam.length ? 'filled opponent-slot' : 'empty-slot');
    if (i < state.oppTeam.length) {
      const p = getPlayer(state.oppTeam[i]);
      oSlot.innerHTML = `<div class="slot-pos">${p.pos}</div><div class="slot-name">${p.name.split(' ').pop()}</div><div class="slot-team">${p.team === 'home' ? '<span class="card-team-dot home-dot"></span>' : '<span class="card-team-dot away-dot"></span>'}</div>`;
    } else {
      oSlot.innerHTML = `<div class="slot-pos">${i+1}</div>`;
    }
    oppEl.appendChild(oSlot);

    const mSlot = document.createElement('div');
    mSlot.className = 'player-slot ' + (i < state.myTeam.length ? 'filled your-slot' : 'empty-slot');
    if (i < state.myTeam.length) {
      const p = getPlayer(state.myTeam[i]);
      mSlot.innerHTML = `<div class="slot-pos">${p.pos}</div><div class="slot-name">${p.name.split(' ').pop()}</div><div class="slot-team">${p.team === 'home' ? '<span class="card-team-dot home-dot"></span>' : '<span class="card-team-dot away-dot"></span>'}</div>`;
    } else {
      mSlot.innerHTML = `<div class="slot-pos">${i+1}</div>`;
    }
    myEl.appendChild(mSlot);
  }

  // Sabotage pips for MY sabotages (steps 1–6, my turns)
  const mySabsDone = state.sequence
    ? state.sequence.slice(0, state.currentPick).filter(s => s.who === 'me' && s.type === 'sabotage').length
    : 0;
  const sabLeft = 3 - mySabsDone;
  const pips = document.getElementById('sabotage-pips');
  pips.innerHTML = '';
  for (let i = 0; i < 3; i++) {
    const pip = document.createElement('div');
    pip.className = 'sabotage-pip' + (i < sabLeft ? ' active' : '');
    pips.appendChild(pip);
  }
  document.getElementById('sabotage-label').textContent =
    sabLeft > 0 ? `${sabLeft} sabotage${sabLeft !== 1 ? 's' : ''} to send` : 'Sabotages complete';
}

function renderCarousel(scrollToTeam = null) {
  const track = document.getElementById('carousel-track');
  const container = document.getElementById('carousel-container');

  // Save scroll position before re-rendering (unless a tab jump was requested)
  const savedScroll = scrollToTeam ? 0 : (container ? container.scrollLeft : 0);

  track.innerHTML = '';

  const step = currentStep();
  const drafted = [...state.myTeam, ...state.oppTeam];

  let available;
  if (step && step.type === 'gk') {
    available = PLAYERS.filter(p => !drafted.includes(p.id) && p.pos === 'GK');
  } else {
    const city    = PLAYERS.filter(p => !drafted.includes(p.id) && p.team === 'home');
    const watford = PLAYERS.filter(p => !drafted.includes(p.id) && p.team === 'away');
    available = [...city, ...watford];
  }

  state.teamStartIndex = {
    home: 0,
    away: available.filter(p => p.team === 'home').length
  };

  for (const p of available) {
    const isSelected = state.selectedPlayer === p.id;
    const card = document.createElement('div');
    card.className = 'player-card' + (isSelected ? ' selected' : '');
    card.dataset.team = p.team;
    card.onclick = () => selectPlayer(p.id);
    card.innerHTML = `
      <div class="card-pos">${p.pos}</div>
      <div class="card-name">${p.name}</div>
      <div class="card-team"><span class="card-team-dot ${p.team}-dot"></span>${p.teamName}</div>
    `;
    track.appendChild(card);
  }

  if (available.length === 0) {
    track.innerHTML = '<div style="padding:20px;color:var(--muted);font-size:13px;">All players drafted</div>';
  }

  requestAnimationFrame(() => {
    if (scrollToTeam) {
      // Tab tapped — jump to start of that team
      const cards = track.querySelectorAll('.player-card');
      const idx = state.teamStartIndex[scrollToTeam] || 0;
      if (cards[idx]) {
        container.scrollTo({ left: cards[idx].offsetLeft - 12, behavior: 'smooth' });
      }
    } else {
      // Normal re-render — restore scroll position
      container.scrollLeft = savedScroll;
    }
  });
}

function selectPlayer(id) {
  state.selectedPlayer = state.selectedPlayer === id ? null : id;
  renderCarousel();
}

function setTeamFilter(team) {
  state.teamFilter = team;
  document.getElementById('toggle-home').classList.toggle('active', team === 'home');
  document.getElementById('toggle-away').classList.toggle('active', team === 'away');
  renderCarousel(team);
}

function updateTurnUI() {
  const step = currentStep();
  if (!step) return;

  const isMyTurn = mp_isMyStep(step);
  const btn      = document.getElementById('btn-me');
  const turnEl   = document.getElementById('turn-text');
  document.getElementById('btn-sabotage').style.display = 'none';

  // Opponent name — truncate long names to keep UI tidy
  const rawOppName = state.mp
    ? (state.mp.oppName || (state.mp.role === 'A' ? state.mp.playerB : state.mp.playerA)?.name || 'Opponent')
    : 'Opponent';
  const oppName = rawOppName.length > 10 ? rawOppName.slice(0, 9) + '…' : rawOppName;

  // Progress counters
  const myDone  = state.sequence.slice(0, state.currentPick)
    .filter(s =>  mp_isMyStep(s) && s.type === step.type).length;
  const oppDone = state.sequence.slice(0, state.currentPick)
    .filter(s => !mp_isMyStep(s) && s.type === step.type).length;

  // ── LEFT PILL: status text only (no button label logic here) ──
  if (step.type === 'gk') {
    turnEl.innerHTML = isMyTurn
      ? '<strong>Pick your goalkeeper</strong><em>You won the toss</em>'
      : `<strong>${oppName} picks GK</strong><em>You pick first after</em>`;

  } else if (step.type === 'sabotage') {
    if (isMyTurn) {
      turnEl.innerHTML =
        `<strong>⚡ Your sabotage pick</strong><em>${myDone + 1} of 3 · goes to ${oppName}</em>`;
    } else {
      turnEl.innerHTML =
        `<strong>⚡ ${oppName} sabotages you</strong><em>${oppDone + 1} of 3 · wait for pick</em>`;
    }

  } else {
    if (isMyTurn) {
      turnEl.innerHTML =
        `<strong>Your pick</strong><em>${myDone + 1} of 7</em>`;
    } else {
      turnEl.innerHTML =
        `<strong>${oppName} is picking</strong><em>${oppDone + 1} of 7 · your turn next</em>`;
    }
  }

  // ── RIGHT BUTTON: always "Pick Player", just enabled/disabled ──
  btn.textContent = 'Pick Player';
  btn.disabled    = !isMyTurn;
  btn.style.background = isMyTurn
    ? (step.type === 'sabotage' ? 'var(--red)' : 'var(--blue)')
    : '#555';
  btn.style.cursor = isMyTurn ? 'pointer' : 'default';
  btn.style.opacity = isMyTurn ? '1' : '0.6';
}

// Helper: is this sequence step MY turn?
// The sequence is always built from the LOCAL player's perspective
// ('me' = this device, 'opp' = the other player), so we can
// simply check step.who === 'me' in both single-player and multiplayer.
function mp_isMyStep(step) {
  if (!step) return false;
  return step.who === 'me';
}

function draftPlayer() {
  const step = currentStep();
  if (!step || step.who !== 'me') return;
  if (!state.selectedPlayer) { showToast('Select a player first!'); return; }

  // Guard: player already drafted (race condition between timer and manual pick)
  const alreadyDrafted = [...state.myTeam, ...state.oppTeam];
  if (alreadyDrafted.includes(state.selectedPlayer)) {
    state.selectedPlayer = null;
    renderCarousel();
    return;
  }

  if (step.type === 'gk') {
    const p = getPlayer(state.selectedPlayer);
    if (p.pos !== 'GK') { showToast('Must pick a goalkeeper!'); return; }
    state.myTeam.push(state.selectedPlayer);
    const otherGK = PLAYERS.find(q => q.pos === 'GK' && q.id !== state.selectedPlayer);
    state.oppTeam.push(otherGK.id);
    showToast(`You pick ${p.name} · ${otherGK.name} goes to opponent`);

  } else if (step.type === 'sabotage') {
    state.oppTeam.push(state.selectedPlayer);

  } else {
    state.myTeam.push(state.selectedPlayer);
  }

  state.selectedPlayer = null;
  state.currentPick++;
  resetTimer();
  afterPick();
}

function afterPick() {
  if (state.myTeam.length === 11 && state.oppTeam.length === 11) {
    clearInterval(state.timerInterval);
    renderDraftSlots();
    renderCarousel();
    setTimeout(() => showCaptainScreen(), 600);
    return;
  }

  const next = currentStep();
  renderDraftSlots();
  renderCarousel();
  updateTurnUI();

  // Tutorial hooks based on draft progression
  if (_tutorialActive) {
    const pickNum = state.currentPick;
    // After player picks GK (myTeam has 1 player, first time): explain forced GK then sabotage
    if (pickNum === 1 && state.myTeam.length === 1 && !state._tutShownGkForced) {
      state._tutShownGkForced = true;
      // Re-render now that step has advanced (so carousel shows sabotage/outfield, not GKs)
      renderDraftSlots();
      renderCarousel();
      updateTurnUI();
      showTutorialCard('gk_forced').then(() => {
        // After GK card dismissed, trigger opponent auto-pick if it's their turn
        const n = currentStep();
        if (n && n.who === 'opp') {
          setTimeout(() => autoPickOpponent(), 800);
        } else if (n && n.type === 'sabotage' && n.who === 'me' && !state._tutShownSabotage) {
          state._tutShownSabotage = true;
          showTutorialCard('sabotage').then(() => {});
        }
      });
      return; // already re-rendered above, skip the renders at the top of afterPick
    }
    // Start of own normal picks (pick 7)
    if (pickNum === 7 && !state._tutShownYourPicks && next && next.type === 'normal' && next.who === 'me') {
      state._tutShownYourPicks = true;
      showTutorialCard('your_picks').then(() => {});
    }
  }

  // If only 1 player left in the pool and it's my turn, auto-draft them
  if (next && next.who === 'me' && next.type === 'normal') {
    const drafted = [...state.myTeam, ...state.oppTeam];
    const available = PLAYERS.filter(p => !drafted.includes(p.id));
    if (available.length === 1 && !state.autoPickLocked) {
      state.autoPickLocked = true;
      const autoPick = available[0];
      clearInterval(state.timerInterval); // stop timer so it can't also fire
      setTimeout(() => {
        state.autoPickLocked = false;
        // Re-check still valid (guard against concurrent picks)
        if (state.myTeam.includes(autoPick.id) || state.oppTeam.includes(autoPick.id)) return;
        showToast(`Only one left — ${autoPick.name} joins your squad!`);
        state.myTeam.push(autoPick.id);
        state.selectedPlayer = null;
        state.currentPick++;
        resetTimer();
        afterPick();
      }, 1200);
      return;
    }
  }

  if (next && next.who === 'opp') {
    setTimeout(() => autoPickOpponent(), 1100);
  }
}

function autoPickGK() {
  const gks = PLAYERS.filter(p => p.pos === 'GK');
  const pick = gks.reduce((best, p) => (CHAOS_VALUES[p.id] || 0) > (CHAOS_VALUES[best.id] || 0) ? p : best, gks[0]);
  const otherGK = gks.find(p => p.id !== pick.id);
  state.oppTeam.push(pick.id);
  state.myTeam.push(otherGK.id);
  state.currentPick++;
  showToast(`Opponent picks ${pick.name} · You get ${otherGK.name}`);
  afterPick();
  startTimer();
}

// Chaos values computed dynamically from EVENTS for the loaded match.
// Higher = more chaos potential (cards, own goals, concedes, early subs)
// Lower = too good (goals, assists = bad for opponent to have)
let CHAOS_VALUES = {};

function computeChaosValues() {
  CHAOS_VALUES = {};

  // Match-level info a football fan would reasonably know or infer:
  // total goals, and which team conceded more (from the scoreline context)
  const homeGoals = EVENTS.filter(e => e.type === 'goal' && PLAYERS.find(p => p.id === e.playerId && p.team === 'home')).length;
  const awayGoals = EVENTS.filter(e => e.type === 'goal' && PLAYERS.find(p => p.id === e.playerId && p.team === 'away')).length;
  const totalGoals = homeGoals + awayGoals;

  // How many goals did each team concede (match-level, not player-level)
  const goalsAgainst = { home: awayGoals, away: homeGoals };

  // Position-based chaos priors — what a knowledgeable fan would expect
  // before knowing exactly what happened
  // Higher = more likely to generate chaos points (cards, subs, own goals)
  // Lower  = more likely to be a "good" contributor (goals, assists)
  const POSITION_PRIOR = {
    GK:  5,   // moderate — could be busy if team conceded, but quiet if clean sheet
    CB:  8,   // defenders often get subbed, carded; rarely score
    RB:  6,
    LB:  6,
    DM:  7,   // holding midfielders: bookings, early subs
    CM:  5,   // could go either way
    AM:  3,   // attacking mid — more likely to contribute positively (bad for us)
    RW:  2,   // wingers and forwards — goal threat, avoid
    LW:  2,
    ST:  1,   // strikers most likely to score — lowest chaos prior
  };

  for (const p of PLAYERS) {
    const prior = POSITION_PRIOR[p.pos] || 5;

    // Contextual adjustment: defenders on the leaky side are more valuable
    // (they'll have conceded goals = chaos points for us)
    // A fan would reason: "that team got battered, their defenders must have had a mare"
    const isBackline = ['GK','CB','RB','LB'].includes(p.pos);
    const concededByTeam = goalsAgainst[p.team] || 0;
    const leakyBonus = isBackline ? concededByTeam * 2.5 : 0;

    // Forwards on the high-scoring side are dangerous to pick (they probably scored)
    // A fan would reason: "their attack was on fire — don't pick them"
    const isAttacker = ['ST','RW','LW','AM'].includes(p.pos);
    const goalsScoredByTeam = p.team === 'home' ? homeGoals : awayGoals;
    const attackerPenalty = isAttacker ? goalsScoredByTeam * 1.5 : 0;

    // Base estimate before noise
    const baseEstimate = prior + leakyBonus - attackerPenalty;

    // Add ±35% noise — the AI is going on gut feel and reputation,
    // not a spreadsheet. Sometimes it'll get it badly wrong.
    const noise = baseEstimate * (Math.random() * 0.7 - 0.35);

    CHAOS_VALUES[p.id] = baseEstimate + noise;
  }
}

function autoPickOpponent() {
  const step = currentStep();
  if (!step || step.who !== 'opp') return;

  const drafted = [...state.myTeam, ...state.oppTeam];
  const available = PLAYERS.filter(p => !drafted.includes(p.id));
  if (available.length === 0) return;

  const sorted = [...available].sort((a, b) => (CHAOS_VALUES[b.id] || 0) - (CHAOS_VALUES[a.id] || 0));

  if (step.type === 'sabotage') {
    // Send the worst player (most harmful to player = lowest chaos) to my team
    const pick = sorted[sorted.length - 1];
    state.myTeam.push(pick.id);
    showToast(`⚡ Opponent sends ${pick.name} to your squad!`);
  } else {
    // Normal pick: take best chaos player
    const pick = sorted[0];
    state.oppTeam.push(pick.id);
  }

  state.currentPick++;
  afterPick();
}


// Timer
function getTimerDuration() {
  // Last 5 picks for the human player = 10 seconds, otherwise 30
  const myPicksSoFar = state.sequence
    ? state.sequence.slice(0, state.currentPick).filter(s => s.who === 'me').length
    : 0;
  const myPicksTotal = state.sequence
    ? state.sequence.filter(s => s.who === 'me').length
    : 11;
  const picksRemaining = myPicksTotal - myPicksSoFar;
  return picksRemaining <= 5 ? 10 : 30;
}

function startTimer(durationOverride) {
  const duration = durationOverride || getTimerDuration();
  state.timerSecs = duration;
  state.timerDuration = duration;
  updateTimerDisplay();
  state.timerInterval = setInterval(() => {
    state.timerSecs--;
    updateTimerDisplay();
    if (state.timerSecs <= 0) {
      clearInterval(state.timerInterval);
      state.timerInterval = null;
      const step = currentStep();
      // In mp mode use mp_isMyStep; in sp use who === 'me'
      const isMyTurn = mp_isMyStep(step);
      if (step && isMyTurn) {
        const drafted = [...state.myTeam, ...state.oppTeam];
        const available = PLAYERS.filter(p => {
          if (drafted.includes(p.id)) return false;
          if (step.type === 'gk') return p.pos === 'GK';
          return true;
        });
        if (available.length > 0) {
          // Auto-pick highest chaos value on timer expiry
          const sorted = [...available].sort((a, b) => (CHAOS_VALUES[b.id] || 0) - (CHAOS_VALUES[a.id] || 0));
          state.selectedPlayer = sorted[0].id;
          window.draftPlayer(); // use patched version (routes through Firebase in mp)
        }
      }
    }
  }, 1000);
}

function resetTimer() {
  clearInterval(state.timerInterval);
  startTimer();
}

function updateTimerDisplay() {
  const circ = document.getElementById('timer-circle');
  const num = document.getElementById('timer-num');
  const duration = state.timerDuration || 30;
  const circumference = 100;
  num.textContent = state.timerSecs;
  const pct = state.timerSecs / duration;
  circ.style.strokeDashoffset = circumference * (1 - pct);
  circ.style.stroke = state.timerSecs > (duration * 0.33) ? '#f5a623' : '#e8290b';
}

// ═══════════════════════════════════════════════════════════════
// SIMULATION ENGINE
// ═══════════════════════════════════════════════════════════════

// ── Commentary tier system ─────────────────────────────────────────
// Tier 1: dry/flat (used for quiet moments, meh players)
// Tier 2: warm dry humour with a knowing wink (most events)
// Tier 3: genuinely losing it briefly (big moments, once or twice a game)
// Tier 4: complete meltdown Easter egg (rate-limited, rare across sessions)
//
// getComment() picks a tier based on event type and game state.
// Tier 4 is only available if state.commentaryMeltdownUsed is false,
// AND a random roll passes (40% chance when eligible), preventing it
// firing every game. Once used, it's locked for the rest of the game.

const COMMENTARY = {
  // ── GOALS ──
  goal: [
    // Tier 1 — flat/dry
    (name) => `<strong>${name}</strong>. Goal. It's in. Ball's in the net.`,
    (name) => `<strong>${name}</strong> finds the back of the net. Nothing the keeper could do, apparently.`,
    (name) => `And it's <strong>${name}</strong>. Clinical. Or something like it.`,
    (name) => `<strong>${name}</strong> scores. As forwards occasionally do.`,
    (name) => `<strong>${name}</strong>. In off the post. It's in.`,
    (name) => `Goal. <strong>${name}</strong>. Simple as that.`,
    (name) => `<strong>${name}</strong>. One touch. Top corner. In.`,
    (name) => `Net. <strong>${name}</strong>. That's a goal.`,
    // Tier 2 — warm
    (name) => `Oh that's a goal. <strong>${name}</strong>. Clean finish, no complaints, plenty of chaos implications.`,
    (name) => `<strong>${name}</strong> pulls the trigger and it's in. The keeper had a look at it and decided against intervening.`,
    (name) => `<strong>${name}</strong> — well, he's supposed to score, isn't he. And yet somehow here we are, surprised.`,
    (name) => `Lovely finish from <strong>${name}</strong>. Textbook. Aesthetically pleasing. Whether it helps you is another matter.`,
    (name) => `There it is. <strong>${name}</strong>. The net ripples. The crowd reacts. The chaos points shift accordingly.`,
    (name) => `<strong>${name}</strong> with the finish. He'll be pleased with that. Whether you are depends entirely on his shirt colour.`,
    (name) => `<strong>${name}</strong> makes it look easy. Sweeps it home. Absolutely no drama. Which is either great or terrible.`,
    (name) => `Low drive from <strong>${name}</strong> — keeper guessed wrong, ball went the other way. Goal. Simple, effective, conclusive.`,
    (name) => `<strong>${name}</strong> arrives late into the box and tucks it away. Where was the marking. Doesn't matter. It's in.`,
    (name) => `Header from <strong>${name}</strong>. Planted. Keeper had no chance. The physics of it were very clear.`,
    (name) => `<strong>${name}</strong> cuts inside, shapes for the shot, and finds the bottom corner. The crowd didn't see it coming. The keeper didn't either.`,
    (name) => `It bobbles, it squirms, it crosses the line. <strong>${name}</strong> claims it. Ugly. Effective. On the board.`,
    (name) => `<strong>${name}</strong> from close range — it was always going in. No credit to the finish. Full credit for being there.`,
    (name) => `Free kick. <strong>${name}</strong> over the ball. Up. Over the wall. In. That's what free kicks are supposed to do.`,
    // Tier 2 — knowing/Worst Eleven aware
    (name) => `<strong>${name}</strong> with the goal. Whether that's good or bad for your score depends entirely on whose team he's in. You know what you did.`,
    (name) => `<strong>${name}</strong> scores and somewhere out there a Worst Eleven player is either celebrating or staring at the ceiling.`,
    (name) => `<strong>${name}</strong> on the scoresheet. This is either exactly what you wanted or the opposite. No middle ground in this game.`,
    (name) => `Goal for <strong>${name}</strong>. The chaos ledger updates itself. You'll see the number change. Make of it what you will.`,
  ],

  // ── OWN GOALS ──
  own_goal: [
    // Tier 1 — deadpan
    (name) => `<strong>${name}</strong> — own goal. Ball in his own net. These things happen.`,
    (name) => `Oh. <strong>${name}</strong> has turned that one in. Unfortunate.`,
    // Tier 2 — warm
    (name) => `<strong>${name}</strong> with the own goal. He assessed the options and selected the worst one with some conviction.`,
    (name) => `That is going in off <strong>${name}</strong>. He came for it, he didn't get it, and now we all have to think about what just happened.`,
    (name) => `<strong>${name}</strong> — own goal. A flap, a fumble, a moment of chaos for the ages. The keeper won't be mentioning this one.`,
    (name) => `Oh no. <strong>${name}</strong> has redirected that perfectly into his own net. Technically quite impressive. Entirely the wrong goal.`,
    // Tier 3 — losing it briefly
    (name) => `That is an own goal. That is absolutely an own goal. <strong>${name}</strong> has scored for the other team. In his own net. With his knee. At a corner. I have questions.`,
    (name) => `<strong>${name}</strong> — own goal. The keeper came for a cross he had absolutely no business attempting, missed it by a yard, and the ball rolled in apologetically. I need a moment.`,
  ],

  // ── RED CARDS ──
  red: [
    // Tier 1
    (name) => `<strong>${name}</strong> is off. Red card. He's walking.`,
    (name) => `Red for <strong>${name}</strong>. No arguments. Off he goes.`,
    // Tier 2
    (name) => `<strong>${name}</strong> shown a straight red and given his marching orders. He looks surprised. Nobody else is.`,
    (name) => `Two yellows. <strong>${name}</strong> is off. He saw the first one coming and decided to do it anyway. Bold.`,
    (name) => `<strong>${name}</strong> — off. The referee had seen enough, and honestly so had we.`,
    (name) => `<strong>${name}</strong> goes in late, referee reaches for his pocket, and off comes the red. He didn't try to make it look accidental. Some respect for the craft would have been appreciated.`,
    (name) => `Straight red for <strong>${name}</strong>. He'll have plenty of time to think about that one on the way home.`,
    // Tier 3
    (name) => `Straight red. Straight red. <strong>${name}</strong> didn't even try to make it look accidental. Some respect for the craft would be appreciated.`,
    (name) => `Two yellows. <strong>${name}</strong> is walking. He had a complete shocker and he is walking and I genuinely feel something. I'm not sure what. But something.`,
  ],

  // ── YELLOW CARDS ──
  yellow: [
    // Tier 1
    (name) => `<strong>${name}</strong> booked. In the book.`,
    (name) => `Yellow for <strong>${name}</strong>. He's lucky it's not more.`,
    (name) => `<strong>${name}</strong> in the referee's notebook.`,
    // Tier 2
    (name) => `<strong>${name}</strong> booked for that. The referee had a word. Several words. The card came out. A predictable sequence of events.`,
    (name) => `Oh that's a yellow. <strong>${name}</strong> knew it was a yellow. The referee knew it was a yellow. Everyone in the ground knew it was a yellow.`,
    (name) => `<strong>${name}</strong> went in a bit there. Booked. He's appealing which, given what he just did, takes some nerve.`,
    (name) => `Yellow card for <strong>${name}</strong> — something about unsporting conduct. Bit rich, but the referee's made his decision.`,
    (name) => `Booked. <strong>${name}</strong>. Frustration spilling over into poor decision-making. A relatable sequence.`,
  ],

  // ── SUBSTITUTIONS ──
  sub: [
    // Tier 1
    (name) => `<strong>${name}</strong> coming off. Substitution.`,
    (name) => `Off comes <strong>${name}</strong>. Change made.`,
    // Tier 2
    (name) => `<strong>${name}</strong> withdrawn. The manager's seen enough. The manager has definitely seen enough.`,
    (name) => `<strong>${name}</strong> hauled off before the hour. The dugout had been watching. They did not enjoy what they saw.`,
    (name) => `Off comes <strong>${name}</strong> — early bath. He won't be pleased. The manager almost certainly is.`,
    (name) => `<strong>${name}</strong> gets the hook. Fifty-something minutes and that's your lot. The fans give him a reception that tells its own story.`,
    (name) => `<strong>${name}</strong> replaced. Tactical, apparently. We'll leave it at that.`,
  ],

  // ── ASSISTS ──
  assist: [
    (name) => `Lovely ball from <strong>${name}</strong> — that had to be finished.`,
    (name) => `<strong>${name}</strong> with the assist. He's been running this game quietly.`,
    (name) => `<strong>${name}</strong> picks out his man perfectly. Some delivery that.`,
    (name) => `<strong>${name}</strong> threading it through on a plate. Couldn't miss.`,
  ],

  // ── HAT-TRICKS ──
  hat_trick: [
    // Tier 2
    (name) => `Hat-trick. <strong>${name}</strong> completes it. Three goals. In one game. Whether you're happy about that depends entirely on what you were hoping for today.`,
    (name) => `<strong>${name}</strong> — hat-trick. Third goal. The match ball is his. His manager is delighted. Your feelings are more complicated.`,
    // Tier 3 — only fires once per game via rate limit
    (name) => `HAT-TRICK. <strong>${name}</strong>. Three goals. In the same match. I'm going to need someone to explain to me what happened today because I have watched football for thirty years and this — this is something.`,
  ],

  // ── NEUTRAL / QUIET SPELLS ──
  neutral: [
    // Tier 1 — flat/dry (most of these)
    () => `Ball goes sideways. Then sideways again. Football, everyone.`,
    () => `Nothing much happening. Both sides feeling each other out.`,
    () => `The referee checks his watch. We check our phones. A shared moment.`,
    () => `Possession retained. The status quo defended. Another minute passes.`,
    () => `A corner, swung in, headed away. The cycle continues.`,
    () => `He looks up. He plays it safe. He'll sleep well tonight.`,
    () => `Tight game so far. Plenty of running but little creativity.`,
    () => `A free kick in a dangerous area. Dangerous for whom remains unclear.`,
    () => `The full back overlaps. Comes to nothing. He'll be back.`,
    // Tier 2 — a bit warmer
    () => `Late tension building. Everything still to play for. Theoretically.`,
    () => `The referee's having a quiet afternoon. For now.`,
    () => `Tactical foul. Yellow card. The shape is maintained. Everyone moves on.`,
  ],
};

// Tracks whether the tier-3 "losing it" lines and tier-4 meltdown have fired this game
// Reset in startSimulation
// state.commentaryTier3Count — how many tier-3 lines have fired (max 2 per game)
// state.commentaryMeltdownUsed — whether tier-4 has fired (max 1 per game, 40% roll)

function getComment(type, name) {
  const lines = COMMENTARY[type] || COMMENTARY.neutral;

  // For event types that have tier-3 lines (own_goal, red, hat_trick),
  // only use them if under the per-game limit
  const tier3Types = ['own_goal', 'red', 'hat_trick'];
  if (tier3Types.includes(type)) {
    if (!state.commentaryTier3Count) state.commentaryTier3Count = 0;

    // Tier-3 lines are the last 1-2 entries in each array
    const tier3Start = { own_goal: 6, red: 7, hat_trick: 2 };
    const t3idx = tier3Start[type];

    const regularLines = lines.slice(0, t3idx);
    const tier3Lines   = lines.slice(t3idx);

    // Try tier-4 meltdown for hat_trick only (rarest, most dramatic)
    if (type === 'hat_trick' && !state.commentaryMeltdownUsed && Math.random() < 0.4) {
      state.commentaryMeltdownUsed = true;
      return tier3Lines[tier3Lines.length - 1](name); // last line is tier-4
    }

    // Use tier-3 line if under limit (max 2 per game) and random roll passes
    if (state.commentaryTier3Count < 2 && tier3Lines.length && Math.random() < 0.55) {
      state.commentaryTier3Count++;
      const t3line = tier3Lines[Math.floor(Math.random() * (tier3Lines.length - 1))]; // exclude last (tier-4)
      return t3line(name);
    }

    // Fall back to regular lines
    return regularLines[Math.floor(Math.random() * regularLines.length)](name);
  }

  return lines[Math.floor(Math.random() * lines.length)](name);
}

// Near-miss fake beats — { setup, build, resolve, emoji }
const NEAR_MISSES = {
  shot: [
    { setup: (n) => `<strong>${n}</strong> picks it up on the edge of the box, nobody closing him down…`,        build: (n) => `<strong>${n}</strong> shaping up for a shot here…`,                resolve: (n) => `…just over the bar. <strong>${n}</strong> puts his hands on his head.`,                    emoji: '😬' },
    { setup: (n) => `<strong>${n}</strong> driving at goal, defenders backing off, inviting the shot…`,          build: (n) => `<strong>${n}</strong> cuts inside, pulls the trigger…`,              resolve: (n) => `…straight at the keeper. He'll be disappointed with that.`,                                emoji: '🧤' },
    { setup: (n) => `Free kick awarded, dangerous position. <strong>${n}</strong> standing over it…`,            build: (n) => `<strong>${n}</strong> steps up from the free kick…`,                resolve: (n) => `…into the wall. Nothing comes of it. The wall does its one job.`,                          emoji: '🧱' },
    { setup: (n) => `<strong>${n}</strong> played in behind — it's just him and the keeper now…`,                build: (n) => `<strong>${n}</strong> through on goal here, one on one…`,            resolve: (n) => `…keeper spreads himself and saves it. Not today, not ever.`,                               emoji: '🧤' },
    { setup: (n) => `Corner coming in, <strong>${n}</strong> getting across his man at the back stick…`,         build: (n) => `Header from <strong>${n}</strong>!`,                                resolve: (n) => `…off the post! Agonising. The woodwork saves them once again.`,                            emoji: '😩' },
    { setup: (n) => `<strong>${n}</strong> has space, 30 yards out, eyeing up the top corner…`,                  build: (n) => `<strong>${n}</strong> lines up from distance, worth a go…`,          resolve: (n) => `…blazes it wide. Not his finest moment. Not his finest day, frankly.`,                    emoji: '😅' },
    { setup: (n) => `<strong>${n}</strong> peeling off his marker at the back post, corner coming…`,             build: (n) => `<strong>${n}</strong> lurking at the back post, free header…`,      resolve: (n) => `…over! He'll say he got a touch. Nobody believes him.`,                                   emoji: '🙈' },
    { setup: (n) => `<strong>${n}</strong> receives it in the channel, one touch to set himself…`,               build: (n) => `<strong>${n}</strong> into the area, going for goal…`,              resolve: (n) => `…blocked! Last-ditch defending. The ball bounces clear.`,                                  emoji: '🙅' },
  ],
  card: [
    { setup: (n) => `<strong>${n}</strong> charging in — he's going to be late on this…`,                        build: (n) => `Ooh, <strong>${n}</strong> goes in late there, referee has a look…`,  resolve: (n) => `…plays on. Ref keeps his cards in his pocket. Lucky escape. Very lucky.`,                emoji: '😤' },
    { setup: (n) => `<strong>${n}</strong> fuming after that decision, storming over to the referee…`,           build: (n) => `<strong>${n}</strong> not happy, getting in the ref's face here…`,   resolve: (n) => `…just a word. He's getting away with that. This time.`,                                   emoji: '🫣' },
    { setup: (n) => `Tempers fraying, <strong>${n}</strong> right in the middle of it near the touchline…`,      build: (n) => `Bit of handbags near the touchline, <strong>${n}</strong> involved…`, resolve: (n) => `…ref steps in. No card, but he's noted the name. The notebook is out.`,                  emoji: '📋' },
    { setup: (n) => `<strong>${n}</strong> sliding in, studs showing — this looks bad from here…`,               build: (n) => `Nasty challenge from <strong>${n}</strong>, crowd baying for a card…`, resolve: (n) => `…ref says play on. Remarkable decision. Truly remarkable.`,                             emoji: '🤯' },
    { setup: (n) => `<strong>${n}</strong> going in high, the ref is running across from the other side…`,       build: (n) => `<strong>${n}</strong> catches his man studs up, ref coming over…`,   resolve: (n) => `…talking to him. Pointing. No card. He won't be told twice. He's already been told twice.`, emoji: '😬' },
    { setup: (n) => `<strong>${n}</strong> has been walking a tightrope all afternoon. Already on a yellow.`,    build: (n) => `<strong>${n}</strong> goes in again — he cannot do this…`,           resolve: (n) => `…ref waves it away. Incredible. The laws of physics and football have both been suspended.`, emoji: '😱' },
  ],
  var: [
    { setup: (n) => `Play stopped. The officials are huddling, looking at the screen. <strong>${n}</strong> waiting.`, build: (n) => `Hold on — VAR check. <strong>${n}</strong> might be in trouble here…`, resolve: (n) => `…no action. They're waving play on. The crowd express an opinion about this.`, emoji: '📺' },
    { setup: (n) => `VAR intervenes. Everyone's waiting. <strong>${n}</strong> looking at the big screen.`,      build: (n) => `Referee goes to the monitor to review <strong>${n}</strong>'s challenge…`, resolve: (n) => `…no card. Close. Very close. The technology has spoken and the technology is forgiving today.`, emoji: '📺' },
  ],
  injury: [
    { setup: (n) => `<strong>${n}</strong> pulling up short, holding his hamstring…`,                            build: (n) => `<strong>${n}</strong> down injured, physios running on…`,             resolve: (n) => `…up on his feet. Just cramp, apparently. He'll be fine. He doesn't look fine.`,           emoji: '🩺' },
    { setup: (n) => `<strong>${n}</strong> takes a heavy challenge, doesn't look right, staying down…`,          build: (n) => `<strong>${n}</strong> taking a knock, looking sore…`,               resolve: (n) => `…back on his feet. Gets on with it. Hard as nails, apparently.`,                          emoji: '💪' },
    { setup: (n) => `<strong>${n}</strong> holding his ankle after that collision, wincing…`,                    build: (n) => `<strong>${n}</strong> down, referee stops play…`,                  resolve: (n) => `…magic sponge applied. He's back up. The magic sponge remains undefeated.`,              emoji: '🩺' },
  ],
  chance: [
    { setup: (n) => `<strong>${n}</strong> twisting in the area — contact there, surely, arm across him…`,       build: (n) => `Penalty shout! <strong>${n}</strong> goes down in the box…`,          resolve: (n) => `…nothing given. Referee not interested. <strong>${n}</strong> absolutely furious. Rightly so.`, emoji: '😡' },
    { setup: (n) => `Ball strikes an arm in the area — <strong>${n}</strong> already appealing…`,                build: (n) => `<strong>${n}</strong> appeals for handball, both arms in the air…`,  resolve: (n) => `…play continues. The ref isn't buying it. Nobody is buying it. Except <strong>${n}</strong>.`, emoji: '🙅' },
    { setup: (n) => `<strong>${n}</strong> found in acres of space, nobody tracking his run…`,                   build: (n) => `<strong>${n}</strong> arriving late into the box — this looks dangerous…`, resolve: (n) => `…offside! Flag's up. Fractional. He'll be livid. Rightfully so.`,                       emoji: '🚩' },
  ],
};

function pickNearMiss(playerName, allowVar = true) {
  // Weight card scares higher — core jeopardy
  const allTypes = allowVar
    ? ['shot','shot','card','card','card','chance','chance','var','injury']
    : ['shot','shot','card','card','card','chance','chance','injury'];
  const type = allTypes[Math.floor(Math.random() * allTypes.length)];
  const pool = NEAR_MISSES[type];
  const miss = pool[Math.floor(Math.random() * pool.length)];
  return {
    setup:   miss.setup ? miss.setup(playerName) : null,
    build:   miss.build(playerName),
    resolve: miss.resolve(playerName),
    emoji:   miss.emoji,
    type,
  };
}

// Pre-event teasers — planted 1-2 mins before a real dramatic event
const PRE_EVENT_TEASERS = {
  red: [
    { setup: (n) => `<strong>${n}</strong> has been walking a tightrope all afternoon — already in the book, still flying in…`,    trigger: (n) => `<strong>${n}</strong> goes in late again — this time the referee is not letting it go…` },
    { setup: (n) => `<strong>${n}</strong> and the referee have been having words since the first whistle…`,                       trigger: (n) => `Another reckless foul from <strong>${n}</strong>, referee reaching for his pocket…` },
    { setup: (n) => `The crowd on <strong>${n}</strong>'s back every time he touches it. He's not helping himself…`,              trigger: (n) => `<strong>${n}</strong> snaps — challenge from behind, referee blowing immediately…` },
    { setup: (n) => `<strong>${n}</strong> on a yellow, and he's still going into every tackle like it's the last one…`,         trigger: (n) => `Oh here we go — <strong>${n}</strong> in on the keeper, studs up, that cannot be legal…` },
  ],
  yellow: [
    { setup: (n) => `<strong>${n}</strong> has been giving the referee problems all game — this can only go one way…`,           trigger: (n) => `<strong>${n}</strong> pulls back his man cynically, referee's had enough…` },
    { setup: (n) => `Frustration building in <strong>${n}</strong>'s body language — something's coming here…`,                  trigger: (n) => `<strong>${n}</strong> clatters into the challenge — no attempt to play the ball…` },
    { setup: (n) => `<strong>${n}</strong> arguing with the fourth official now. The fourth official. The one with no power.`,   trigger: (n) => `And <strong>${n}</strong> is at it again — goes right through the back of him…` },
  ],
  goal: [
    { setup: (n) => `<strong>${n}</strong> has looked sharp all afternoon — something is definitely building here…`,              trigger: (n) => `<strong>${n}</strong> picks it up in space, carries it forward, beats his man…` },
    { setup: (n) => `The ball keeps finding <strong>${n}</strong> in dangerous positions. It's only a matter of time…`,          trigger: (n) => `<strong>${n}</strong> through on goal — the defender's completely lost him…` },
    { setup: (n) => `<strong>${n}</strong> dropping deep, linking things together, dictating. Something's brewing.`,             trigger: (n) => `<strong>${n}</strong> plays the one-two and bursts into the box…` },
    { setup: (n) => `<strong>${n}</strong> winning every header, dominating this channel — pressure building…`,                  trigger: (n) => `Ball drops to <strong>${n}</strong> in the area, six yards out, first time…` },
  ],
  own_goal: [
    { setup: (n) => `<strong>${n}</strong> has been nervy today — miscontrolling, misdirecting, under pressure constantly…`,     trigger: (n) => `Cross comes in — <strong>${n}</strong> has to deal with this under pressure…` },
    { setup: (n) => `The back line looks shaky. <strong>${n}</strong> hasn't been convincing at all this half.`,                 trigger: (n) => `<strong>${n}</strong> attempting to clear — awkward bounce, going the wrong way…` },
    { setup: (n) => `<strong>${n}</strong> has been miscommunicating with his keeper all game. This is dangerous.`,              trigger: (n) => `Keeper comes — <strong>${n}</strong> goes — neither shouts, both go for it…` },
  ],
};

function getPreTeaser(eventType, playerName) {
  const pool = PRE_EVENT_TEASERS[eventType];
  if (!pool) return null;
  const entry = pool[Math.floor(Math.random() * pool.length)];
  return {
    setup:   entry.setup(playerName),
    trigger: entry.trigger(playerName),
  };
}

// Scoring per event type for a player in a given team (mine vs opp)
function getEventDelta(event, player) {
  if (!player) return 0;
  const priorGoals   = EVENTS.filter(e => e.type === 'goal'   && e.playerId === player.id && e.min < event.min).length;
  const priorAssists = EVENTS.filter(e => e.type === 'assist' && e.playerId === player.id && e.min < event.min).length;
  switch (event.type) {
    case 'goal':   return getScoreForEvent('goal',   player, { nthEvent: priorGoals + 1 });
    case 'assist': return getScoreForEvent('assist', player, { nthEvent: priorAssists + 1 });
    case 'sub':    return getScoreForEvent('sub',    player, { min: event.min });
    default:       return getScoreForEvent(event.type, player);
  }
}

let simTimeout = null;
let _clockTicker = null;
let simBeats = null; // store beats reference for autocomplete

function autoCompleteMatch() {
  if (simTimeout) { clearTimeout(simTimeout); simTimeout = null; }
  if (state.predictionTimerTimeout) { clearTimeout(state.predictionTimerTimeout); state.predictionTimerTimeout = null; }
  closePrediction();
  state._predOnComplete = null;
  const feed = document.getElementById('commentary-feed');
  if (feed) { feed.classList.remove('feed-building', 'feed-halftime'); }

  // Process all remaining events instantly
  const allEvents = EVENTS.filter(e => e.type !== 'full_90');
  for (const e of allEvents) {
    processSimEvent(e);
  }

  // Update live score display to final counts
  const homeGoals = EVENTS.filter(e => e.type === 'goal' && PLAYERS.find(p => p.id === e.playerId && p.team === 'home')).length;
  const awayGoals = EVENTS.filter(e => e.type === 'goal' && PLAYERS.find(p => p.id === e.playerId && p.team === 'away')).length;
  const h = document.getElementById('live-home-score');
  const a = document.getElementById('live-away-score');
  if (h) h.textContent = homeGoals;
  if (a) a.textContent = awayGoals;

  document.getElementById('match-clock').textContent = "90'";
  setCommentary('<strong>Full time.</strong> Skipped to the result.', '🏁');

  applyFull90();
  updateScoreDisplay();
  renderSimPlayers();

  setTimeout(() => showResults(), 800);
}

// ═══════════════════════════════════════════════════════════════
// CAPTAIN SELECTION
// ═══════════════════════════════════════════════════════════════

function showCaptainScreen() {
  showScreen('captain');
  state.myCaptain     = null;
  state.captainRandom = false; // track whether dice was used
  // Tutorial: explain captain mechanic
  if (_tutorialActive) {
    showTutorialCard('captain').then(() => {});
  }

  // ── Opponent captain: highest chaos estimate from their team ──
  const POSITION_PRIOR = { GK:5,CB:8,RB:6,LB:6,DM:7,CM:5,AM:3,RW:2,LW:2,ST:1 };
  const homeGoals = EVENTS.filter(e => e.type==='goal' && PLAYERS.find(q=>q.id===e.playerId&&q.team==='home')).length;
  const awayGoals = EVENTS.filter(e => e.type==='goal' && PLAYERS.find(q=>q.id===e.playerId&&q.team==='away')).length;
  const oppCandidates = state.oppTeam
    .map(id => {
      const p = getPlayer(id);
      if (!p || p.pos === 'GK') return null;
      const prior       = POSITION_PRIOR[p.pos] || 5;
      const isBackline  = ['CB','RB','LB'].includes(p.pos);
      const leakyBonus  = isBackline ? ({ home: awayGoals, away: homeGoals }[p.team] || 0) * 2.5 : 0;
      const isAttacker  = ['ST','RW','LW','AM'].includes(p.pos);
      const attPenalty  = isAttacker ? (p.team==='home' ? homeGoals : awayGoals) * 1.5 : 0;
      return { id, v: prior + leakyBonus - attPenalty };
    }).filter(Boolean).sort((a,b) => b.v - a.v);
  state.oppCaptain = oppCandidates[0]?.id;

  // ── Curated captain candidates: 6 from YOUR team only ──
  // Sorted by chaos potential descending — highest chaos score first,
  // so the player sees their most interesting options at the top.
  const scoredMy = state.myTeam
    .map(id => {
      const p = getPlayer(id);
      if (!p || p.pos === 'GK') return null;
      const prior      = POSITION_PRIOR[p.pos] || 5;
      const isBackline = ['CB','RB','LB'].includes(p.pos);
      const leaky      = isBackline ? ({ home: awayGoals, away: homeGoals }[p.team] || 0) * 2.5 : 0;
      const isAtt      = ['ST','RW','LW','AM'].includes(p.pos);
      const attPen     = isAtt ? (p.team==='home' ? homeGoals : awayGoals) * 1.5 : 0;
      return { id, v: prior + leaky - attPen };
    }).filter(Boolean).sort((a,b) => b.v - a.v); // descending = highest chaos first

  const myCurated = scoredMy.slice(0, 6).map(x => x.id);

  // Render curated tiles
  const grid = document.getElementById('captain-grid');
  grid.innerHTML = '';

  const m = ALL_MATCHES[state.matchIdx];
  for (const id of myCurated) {
    const p = getPlayer(id);
    if (!p) continue;
    const tile = document.createElement('div');
    tile.className = 'captain-tile';
    tile.dataset.id = p.id;
    const teamColour = p.team === 'home'
      ? (m?.meta.homeColour || '#6CABDD')
      : (m?.meta.awayColour || '#FBEE23');
    tile.innerHTML = `
      <div class="captain-tile-pos">${p.pos}</div>
      <div class="captain-tile-name">${p.name.split(' ').pop()}</div>
      <div class="captain-tile-team"><span class="captain-tile-dot" style="background:${teamColour}"></span>${p.teamName}</div>
    `;
    tile.addEventListener('click', () => selectCaptain(p.id, false));
    grid.appendChild(tile);
  }

  // 🎲 Dice tile — +5 flat bonus, no 2× multiplier
  const diceTile = document.createElement('div');
  diceTile.className = 'captain-tile random-tile';
  diceTile.dataset.id = 'random';
  diceTile.innerHTML = `<div class="captain-tile-name">🎲 Roll the Dice</div><div style="font-size:10px;color:#f5a623;margin-top:2px">+5 bonus pts</div>`;
  diceTile.addEventListener('click', () => {
    const outfield = state.myTeam.filter(id => { const p = getPlayer(id); return p && p.pos !== 'GK'; });
    const randomId = outfield[Math.floor(Math.random() * outfield.length)];
    selectCaptain(randomId, true);
  });
  grid.appendChild(diceTile);

  document.getElementById('captain-confirm-btn').disabled = true;
  document.getElementById('captain-hint').textContent = 'Tap a player to nominate';
  document.getElementById('captain-hint').className = 'captain-hint';

  startCaptainTimer();
}

let captainTimerInterval = null;

function startCaptainTimer() {
  if (captainTimerInterval) clearInterval(captainTimerInterval);
  let secs = 10;

  const hint = document.getElementById('captain-hint');
  const btn  = document.getElementById('captain-confirm-btn');

  // Show countdown in hint
  function updateHint() {
    if (!state.myCaptain) {
      hint.textContent = `Tap a player to nominate — ${secs}s`;
    }
  }
  updateHint();

  captainTimerInterval = setInterval(() => {
    secs--;
    updateHint();
    if (secs <= 0) {
      clearInterval(captainTimerInterval);
      if (!state.myCaptain) {
        // Auto-assign random outfield player
        const outfield = state.myTeam.filter(id => { const p = getPlayer(id); return p && p.pos !== 'GK'; });
        const randomId = outfield[Math.floor(Math.random() * outfield.length)];
        selectCaptain(randomId, true);
        // Auto-confirm after brief pause
        setTimeout(() => confirmCaptain(), 800);
      }
    }
  }, 1000);
}

function selectCaptain(id, fromRandom = false) {
  state.myCaptain     = id;
  state.captainRandom = fromRandom;

  document.querySelectorAll('.captain-tile').forEach(t => {
    if (fromRandom) {
      t.classList.toggle('selected', t.dataset.id === 'random');
    } else {
      t.classList.toggle('selected', parseInt(t.dataset.id) === id);
    }
  });

  const p    = getPlayer(id);
  const hint = document.getElementById('captain-hint');
  const name = p ? p.name.split(' ').pop() : '?';
  hint.textContent = fromRandom
    ? `🎲 ${name} drawn — +5 bonus pts locked in`
    : `${name} will wear the armband`;
  hint.className = 'captain-hint chosen';

  document.getElementById('captain-confirm-btn').disabled = false;
}

function confirmCaptain() {
  if (!state.myCaptain) return;
  if (captainTimerInterval) clearInterval(captainTimerInterval);

  // Dice bonus: +5 flat, applied immediately to score before sim
  if (state.captainRandom) {
    state.captainDiceBonus = 5;
    showToast('🎲 +5 dice bonus locked in!');
  } else {
    state.captainDiceBonus = 0;
  }

  if (state.mp) {
    showToast(state.captainRandom ? '🎲 +5 dice bonus! Waiting for opponent…' : 'Captain locked in — waiting for opponent…');
    const btn = document.getElementById('captain-confirm-btn');
    if (btn) { btn.disabled = true; btn.textContent = 'Waiting…'; }
    mpConfirmCaptainAndSim(state.myCaptain);
  } else {
    startSimulation();
  }
}

function isCaptain(playerId) {
  return playerId === state.myCaptain || playerId === state.oppCaptain;
}

function captainMultiplier(playerId) {
  return isCaptain(playerId) ? 2 : 1;
}

function startSimulation() {
  initPlayerData();
  state.myScore  = state.captainDiceBonus || 0; // dice bonus applied before sim
  state.oppScore = 0;
  state.liveHomeScore = 0;
  state.liveAwayScore = 0;
  state.pendingFlashes = [];
  state.deltaHistory = [];
  state.commentaryTier3Count    = 0;   // tier-3 "losing it" lines — max 2 per game
  state.commentaryMeltdownUsed  = false; // tier-4 Easter egg — max 1 per game

  // Reset timeline strip
  const tl1 = document.getElementById('tl-events1');
  const tl2 = document.getElementById('tl-events2');
  const p1  = document.getElementById('tl-progress1');
  const p2  = document.getElementById('tl-progress2');
  const h2  = document.getElementById('tl-half2');
  if (tl1) tl1.innerHTML = '';
  if (tl2) tl2.innerHTML = '';
  if (p1)  p1.style.width = '0%';
  if (p2)  p2.style.width = '0%';
  if (h2)  h2.classList.remove('active');
  showScreen('sim');

  // Re-apply live scoreline team names (HTML default is hardcoded, needs refresh)
  const m = ALL_MATCHES[state.matchIdx];
  if (m) {
    const liveTeams = document.querySelector('.live-teams');
    if (liveTeams) liveTeams.innerHTML = `${m.meta.home} <strong id="live-home-score">0</strong> – <strong id="live-away-score">0</strong> ${m.meta.away}`;
    const commEl = document.getElementById('commentary');
    if (commEl) commEl.textContent = `${m.meta.home} vs ${m.meta.away} kicks off…`;
  }

  // Apply team name to scoreboard label and tab
  // Scoreboard: just the raw name without emoji (it's tiny, emoji breaks mono spacing)
  // Tab: emoji only to keep tabs balanced
  const teamName  = state.teamName  || 'You';
  const teamEmoji = state.teamEmoji || '';
  const shortName = teamName.replace(/^\S+\s/, ''); // strip leading emoji token
  const myLabel = document.getElementById('sim-my-label');
  if (myLabel) myLabel.textContent = shortName || teamName;
  const graphYouLabel = document.getElementById('sim-graph-you-label');
  if (graphYouLabel) graphYouLabel.textContent = shortName || teamName;
  const myTab = document.getElementById('sim-tab-me');
  if (myTab) myTab.textContent = (teamEmoji ? teamEmoji + ' ' : '') + 'Your XI';

  updateScoreDisplay();
  setSimView('pitch');

  let beats;
  try {
    beats = buildBeats();
  } catch(err) {
    console.error('buildBeats error:', err);
    beats = [];
  }
  if (!beats || beats.length === 0) {
    // Fallback: skip straight to results after a brief delay
    setTimeout(() => showResults(), 2000);
    return;
  }
  runBeats(beats, 0);
}

// ═══════════════════════════════════════════════════════════════
// PREDICTION MOMENTS
// ═══════════════════════════════════════════════════════════════

const PREDICTION_QUESTIONS = {
  goal:     (n) => `${n} is in space — does he score?`,
  own_goal: (n) => `${n} is under pressure — does he put it in his own net?`,
  red:      (n) => `${n} is on the edge — does he get sent off?`,
  yellow:   (n) => `${n} is pushing his luck — does he get booked?`,
  shot:     (n) => `${n} pulls the trigger — does it go in?`,
  card:     (n) => `${n} goes in late — does he see a card?`,
};

function getPredictionQuestion(eventType, playerName) {
  const fn = PREDICTION_QUESTIONS[eventType] || PREDICTION_QUESTIONS.shot;
  return fn(playerName);
}

// Called from runBeats when a prediction beat fires
function showPrediction(beat, onComplete) {
  const overlay  = document.getElementById('prediction-overlay');
  const qEl      = document.getElementById('prediction-question');
  const fillEl   = document.getElementById('prediction-timer-fill');
  const yesBtn   = document.querySelector('.pred-yes');
  const noBtn    = document.querySelector('.pred-no');

  if (!overlay) { onComplete(null); return; }

  state.predictionAnswer  = null;
  state.predictionPending = beat;

  // Tutorial: explain the prediction mechanic before the first question
  if (_tutorialActive && !state._tutShownQuestion) {
    state._tutShownQuestion = true;
    showTutorialCard('question', false).then(() => {
      _runShowPrediction(overlay, qEl, fillEl, yesBtn, noBtn, beat, onComplete);
    });
    return;
  }
  _runShowPrediction(overlay, qEl, fillEl, yesBtn, noBtn, beat, onComplete);
}

function _runShowPrediction(overlay, qEl, fillEl, yesBtn, noBtn, beat, onComplete) {

  qEl.textContent = beat.predQuestion;

  // For card-colour questions, relabel buttons; for yes/no use defaults
  const btnA = document.getElementById('pred-btn-a');
  const btnB = document.getElementById('pred-btn-b');
  if (beat.predIsCard && beat.predOptions) {
    if (btnA) { btnA.textContent = beat.predOptions[0]; btnA.onclick = () => submitPrediction(0); }
    if (btnB) { btnB.textContent = beat.predOptions[1]; btnB.onclick = () => submitPrediction(1); }
  } else {
    if (btnA) { btnA.textContent = '✅ Yes'; btnA.onclick = () => submitPrediction(true); }
    if (btnB) { btnB.textContent = '❌ No';  btnB.onclick = () => submitPrediction(false); }
  }

  // Reset buttons
  if (yesBtn) { yesBtn.disabled = false; yesBtn.classList.remove('selected'); }
  if (noBtn)  { noBtn.disabled  = false; noBtn.classList.remove('selected'); }

  overlay.style.display = '';

  // Timer bar: full → empty over 3s
  fillEl.style.transition = 'none';
  fillEl.style.width = '100%';
  requestAnimationFrame(() => requestAnimationFrame(() => {
    fillEl.style.transition = 'width 3s linear';
    fillEl.style.width = '0%';
  }));

  // Auto-resolve after 3s if no answer
  state.predictionTimerTimeout = setTimeout(() => {
    closePrediction();
    onComplete(null); // no answer — 0 pts
  }, 3000);

  // Store callback for button taps
  state._predOnComplete = onComplete;
}

function submitPrediction(answer) {
  if (state.predictionTimerTimeout) {
    clearTimeout(state.predictionTimerTimeout);
    state.predictionTimerTimeout = null;
  }
  const yesBtn = document.querySelector('.pred-yes');
  const noBtn  = document.querySelector('.pred-no');
  if (yesBtn) { yesBtn.disabled = true; (answer ? yesBtn : noBtn).classList.add('selected'); }
  if (noBtn)  { noBtn.disabled  = true; }

  closePrediction();
  if (state._predOnComplete) {
    state._predOnComplete(answer);
    state._predOnComplete = null;
  }
}

function closePrediction() {
  const overlay = document.getElementById('prediction-overlay');
  const feed    = document.getElementById('commentary-feed');
  const sub     = document.getElementById('commentary-sub');
  if (overlay) overlay.style.display = 'none';
  if (feed)    feed.classList.remove('feed-building');
  if (sub)     { sub.innerHTML = ''; sub.style.display = 'none'; }
}

function applyPredictionResult(playerAnswer, isReal) {
  if (playerAnswer === null) {
    setCommentary('No answer — play continues.', '⏩');
    return;
  }
  const beat = state.predictionPending;
  let correct;

  // Card-colour question: answer is an index (0=red, 1=yellow)
  if (beat && beat.predIsCard) {
    correct = (playerAnswer === beat.predCorrectOption);
  } else {
    // Yes/No question: playerAnswer is true/false, isReal is whether it happened
    correct = (playerAnswer === isReal);
  }

  if (correct) {
    state.myScore += 10;
    updateScoreDisplay();
    setCommentary('<strong>✅ Correct!</strong> +10 pts added to your score.', '🎯');
    showToast('+10 CORRECT!');
    flashPredResult('+10 CORRECT!', 'correct');
  } else {
    state.myScore -= 5;
    updateScoreDisplay();
    setCommentary('<strong>❌ Wrong!</strong> −5 pts deducted from your score.', '💸');
    showToast('−5 WRONG');
    flashPredResult('−5 WRONG', 'wrong');
  }
}

// ══════════════════════════════════════════════════════════
// 3-OPTION SCORER QUESTION
// ══════════════════════════════════════════════════════════

// Build plausible distractors: same position group as scorer, from same team
function getScorerOptions(scorerId, eventType) {
  const scorer = getPlayer(scorerId);
  if (!scorer) return null;

  // Position groups for non-trivial distractors
  const POS_GROUP = {
    GK: ['GK'],
    CB: ['CB','RB','LB'], RB: ['CB','RB','LB'], LB: ['CB','RB','LB'],
    DM: ['DM','CM'], CM: ['DM','CM'],
    AM: ['AM','RW','LW','CM'], RW: ['AM','RW','LW','ST'], LW: ['AM','RW','LW','ST'],
    ST: ['ST','RW','LW','AM'],
  };
  const group = POS_GROUP[scorer.pos] || [scorer.pos];

  // Pool: same team, same position group, excluding scorer
  const allPlayers = PLAYERS.filter(p =>
    p.team === scorer.team &&
    p.id !== scorer.id &&
    group.includes(p.pos)
  );

  // Shuffle and take 2 distractors; fall back to any same-team outfield if needed
  const shuffle = arr => [...arr].sort(() => Math.random() - 0.5);
  let pool = shuffle(allPlayers);
  if (pool.length < 2) {
    const fallback = shuffle(PLAYERS.filter(p => p.team === scorer.team && p.id !== scorer.id && p.pos !== 'GK'));
    pool = [...pool, ...fallback.filter(p => !pool.find(q => q.id === p.id))];
  }

  const distractors = pool.slice(0, 2);
  if (distractors.length < 2) return null; // not enough players to make question

  // Shuffle all 3 so correct answer isn't always first
  const options = shuffle([scorer, ...distractors]);
  return { options, correctId: scorer.id };
}

// onComplete(isCorrect, playerId) — playerId is what the user tapped (for mp write)
// In single-player, onComplete fires immediately after answer and handles scoring.
// In mp, mpShowScorerQuestion wraps this and intercepts the callback.
function showScorerQuestion(beat, onComplete) {
  const overlay = document.getElementById('scorer-overlay');
  const qEl     = document.getElementById('scorer-question');
  const labelEl = document.getElementById('scorer-label');
  const fillEl  = document.getElementById('scorer-timer-fill');
  const btnWrap = document.getElementById('scorer-buttons');
  if (!overlay || !beat.scorerOptions) { onComplete(null, null); return; }

  const { options, correctId } = beat.scorerOptions;
  const isMp       = !!state.mp;
  const eventLabel = beat.scorerEventType === 'red' ? '🟥 Red card!' : '⚽ Goal!';

  qEl.textContent     = beat.scorerEventType === 'red' ? 'Who saw red?' : 'Who scored?';
  labelEl.textContent = isMp
    ? `${eventLabel} · Race your opponent · +15 / −5`
    : `${eventLabel} · +15 correct · −5 wrong`;

  btnWrap.innerHTML = '';
  let answered = false;

  options.forEach(p => {
    const btn       = document.createElement('button');
    btn.className   = 'scorer-btn';
    btn.textContent = p.name.split(' ').pop();
    btn.dataset.id  = p.id;
    btn.onclick = () => {
      if (answered) return;
      answered = true;
      clearTimeout(state.scorerTimerTimeout);
      const isCorrect = (p.id === correctId);
      // Highlight tapped button; reveal correct
      document.querySelectorAll('.scorer-btn').forEach(b => {
        b.disabled = true;
        if (parseInt(b.dataset.id) === correctId) b.classList.add('correct');
        if (b === btn && !isCorrect) b.classList.add('wrong');
      });
      onComplete(isCorrect, p.id);
    };
    btnWrap.appendChild(btn);
  });

  overlay.style.display = '';

  fillEl.style.transition = 'none';
  fillEl.style.width = '100%';
  requestAnimationFrame(() => requestAnimationFrame(() => {
    fillEl.style.transition = 'width 5s linear';
    fillEl.style.width = '0%';
  }));

  state.scorerTimerTimeout = setTimeout(() => {
    if (!answered) {
      answered = true;
      document.querySelectorAll('.scorer-btn').forEach(b => {
        b.disabled = true;
        if (parseInt(b.dataset.id) === correctId) b.classList.add('correct');
      });
      onComplete(null, null);
    }
  }, 5000);
}

// Apply scored result and close overlay. msg = optional override message (e.g. "Too slow!")
function submitScorerAnswer(correct, correctId, onComplete, overrideMsg, beat) {
  const overlay = document.getElementById('scorer-overlay');

  // Ensure correct answer is always highlighted when resolving
  document.querySelectorAll('.scorer-btn').forEach(b => {
    b.disabled = true;
    if (parseInt(b.dataset.id) === correctId) b.classList.add('correct');
  });

  if (overrideMsg) {
    setCommentary(overrideMsg, '⚡');
    showToast(overrideMsg);
  } else if (correct === null) {
    setCommentary('No answer in time — no points.', '⏩');
    showToast('Too slow!');
  } else if (correct) {
    state.myScore += 15;
    updateScoreDisplay();
    setCommentary('<strong>✅ Correct!</strong> +15 pts — you knew it!', '🎯');
    showToast('+15 CORRECT!');
    flashPredResult('+15 CORRECT!', 'correct');
  } else {
    state.myScore -= 5;
    updateScoreDisplay();
    setCommentary('<strong>❌ Wrong!</strong> −5 pts — tough one.', '💸');
    showToast('−5 WRONG');
    flashPredResult('−5 WRONG', 'wrong');
  }

  // After brief result display, reveal the real commentary (who scored/got red)
  setTimeout(() => {
    if (overlay) overlay.style.display = 'none';
    if (beat && beat.revealCommentary) {
      setCommentary(beat.revealCommentary, beat.revealEmoji || '⚽');
      setTimeout(() => onComplete(), 1500);
    } else {
      onComplete();
    }
  }, 1800);
}

function flashPredResult(text, cls) {
  const el = document.getElementById('pred-result-flash');
  if (!el) return;
  el.textContent = text;
  // Reset first to re-trigger animation
  el.className = 'pred-result-flash';
  el.style.opacity = '0';
  el.style.transform = 'translate(-50%, -50%) scale(0.8)';
  void el.offsetWidth;
  requestAnimationFrame(() => {
    el.className = `pred-result-flash ${cls} show`;
    el.style.opacity = '';
    el.style.transform = '';
    setTimeout(() => {
      el.classList.remove('show');
    }, 2000);
  });
}

// ═══════════════════════════════════════════════════════════════
// BEAT BUILDER
// ═══════════════════════════════════════════════════════════════
function buildBeats() {
  const beats = [];
  const m = ALL_MATCHES[state.matchIdx]; // declare once at top

  beats.push({ realTime: 2000,  matchMin: 0,  events: [], commentary: getComment('neutral'), emoji: '🏟️' });
  beats.push({ realTime: 6000,  matchMin: 10, events: [], commentary: getComment('neutral'), emoji: '🏟️' });

  const eventsToShow = EVENTS.filter(e => e.type !== 'full_90' && e.type !== 'assist');

  for (const e of eventsToShow) {
    const realTime = mapMatchMinToReal(e.min);
    let beat = beats.find(b => !b.fake && Math.abs(b.realTime - realTime) < 2000);
    if (!beat) {
      beat = { realTime, matchMin: e.min, events: [], commentary: '', emoji: '🏟️' };
      beats.push(beat);
    } else {
      beat.matchMin = Math.max(beat.matchMin, e.min);
    }
    beat.events.push(e);
    const p = getPlayer(e.playerId);
    if (!beat.commentary || e.type === 'goal' || e.type === 'own_goal') {
      const isHatTrick = e.type === 'goal' &&
        EVENTS.filter(ev => ev.type === 'goal' && ev.playerId === e.playerId && ev.min < e.min).length === 2;
      beat.commentary = isHatTrick
        ? getComment('hat_trick', p ? p.name : '')
        : getComment(e.type, p ? p.name : '');
      beat.emoji = isHatTrick ? EVENT_EMOJI.hat_trick : (EVENT_EMOJI[e.type] || '🏟️');
    }
  }

  // ── Inject scorer questions onto goal/red beats (max 2 per game) ──
  // Eligible = goal or red card; must have enough players for 3 options
  // Pick up to 2, spread across game (prefer 1st half + 2nd half if possible)
  const scorerEligible = beats.filter(b =>
    !b.fake &&
    b.events.some(e => e.type === 'goal' || e.type === 'red')
  );
  const shuffle3 = arr => [...arr].sort(() => Math.random() - 0.5);
  const firstHalfS  = scorerEligible.filter(b => b.matchMin < 45);
  const secondHalfS = scorerEligible.filter(b => b.matchMin >= 45);
  const scorerPicks = [];
  const s1 = shuffle3(firstHalfS)[0];
  const s2 = shuffle3(secondHalfS)[0];
  if (s1) scorerPicks.push(s1);
  if (s2) scorerPicks.push(s2);
  if (scorerPicks.length < 2) {
    const extra = shuffle3(scorerEligible.filter(b => !scorerPicks.includes(b)))[0];
    if (extra) scorerPicks.push(extra);
  }
  for (const b of scorerPicks) {
    const e = b.events.find(ev => ev.type === 'goal' || ev.type === 'red');
    if (!e) continue;
    const opts = getScorerOptions(e.playerId, e.type);
    if (!opts) continue; // not enough players
    b.isScorerQuestion    = true;
    b.scorerOptions       = opts;
    b.scorerEventType     = e.type;
    // Save PAST-TENSE commentary to reveal AFTER the question is answered
    const pastTenseGoals = [
      (n) => `<strong>${n}</strong> pulled the trigger — and it was in. The keeper never had a chance.`,
      (n) => `<strong>${n}</strong> found the bottom corner. Composed finish. Net confirmed.`,
      (n) => `<strong>${n}</strong> arrived late and tucked it away. Right place, right time.`,
      (n) => `<strong>${n}</strong> shaped up and drove it low. Keeper went the wrong way.`,
      (n) => `<strong>${n}</strong> met it sweetly. Planted. Off the post and in.`,
      (n) => `<strong>${n}</strong> cut inside and curled it home. The keeper got a hand to it. Didn't matter.`,
      (n) => `<strong>${n}</strong> took one touch and finished. Simple. Effective. On the board.`,
      (n) => `<strong>${n}</strong> nodded it in. Six yards out. Had to score. Scored.`,
      (n) => `<strong>${n}</strong> struck it first time. No hesitation. Back of the net.`,
      (n) => `<strong>${n}</strong> stepped over it, let it run, then buried the corner. The keeper was somewhere else entirely.`,
    ];
    const pastTenseReds = [
      (n) => `<strong>${n}</strong> went in two-footed and the referee had no choice. Off.`,
      (n) => `<strong>${n}</strong> caught him late. Raised studs. Straight red. Down to ten.`,
      (n) => `<strong>${n}</strong> argued. The referee didn't argue back. He just showed the card.`,
      (n) => `<strong>${n}</strong> made the tackle and immediately knew it was wrong. So did everyone else.`,
    ];
    const ptBank = e.type === 'goal' ? pastTenseGoals : pastTenseReds;
    const ptLine = ptBank[Math.floor(Math.random() * ptBank.length)];
    const scorer = getPlayer(e.playerId);
    const sName  = scorer ? scorer.name.split(' ').pop() : '';
    b.revealCommentary    = ptLine(sName);
    b.revealEmoji         = e.type === 'goal' ? '⚽' : '🟥';
    // Replace with a generic suspense line so we don't give the answer away
    if (e.type === 'goal') {
      const generics = [
        `Something's happening here…`,
        `The ball is in the net!`,
        `Goal at the ground!`,
        `The crowd erupts!`,
        `Someone's just scored!`,
        `Net ripples. Flags checked. It's a goal.`,
      ];
      b.commentary = generics[Math.floor(Math.random() * generics.length)];
      b.emoji = '⚽';
    } else {
      const redGenerics = [
        `Off! Someone's walking!`,
        `Red card shown!`,
        `Down to ten men!`,
        `The referee reaches for his pocket — it's red!`,
      ];
      b.commentary = redGenerics[Math.floor(Math.random() * redGenerics.length)];
      b.emoji = '🟥';
    }
  }

  // ── Inject 2-answer prediction beats ──────────────────────────
  // These attach to REAL events: yellow/red cards get "red or yellow?" question,
  // goals that are NOT already scorer questions get "will they score?" question.
  // These fire AS the pre-event teaser (2 min before), not on the event itself.
  // Limited to 2 per game, spread across halves.

  const predCandidates = [];

  // Card events: yellow or red → "Which colour?" question
  for (const e of eventsToShow) {
    if (e.type !== 'yellow' && e.type !== 'red') continue;
    const p = getPlayer(e.playerId);
    if (!p) continue;
    const teaserMin  = Math.max(1, e.min - 2);
    const teaserReal = mapMatchMinToReal(teaserMin);
    const tooClose   = beats.some(b => Math.abs(b.realTime - teaserReal) < 1500);
    if (tooClose) continue;

    const surname = p.name.split(' ').pop();
    // Build the pre-card atmosphere commentary
    const setups = {
      red:    [
        `${surname} has been walking a tightrope all afternoon…`,
        `The referee is watching ${surname} very closely now…`,
        `${surname} goes in again — this looks dangerous…`,
      ],
      yellow: [
        `${surname} has been giving the referee problems all game…`,
        `Frustration building — ${surname} is pushing his luck here…`,
        `${surname} clatters into another one — the ref's patience is running out…`,
      ],
    };
    const ttype = e.type;
    const setupPool = setups[ttype];
    const setup = setupPool[Math.floor(Math.random() * setupPool.length)];

    predCandidates.push({
      realTime:    teaserReal,
      matchMin:    teaserMin,
      events:      [],
      fake:        true,
      isPrediction: true,
      predIsReal:   true,  // correct answer is YES (card is coming)
      predIsCard:   true,  // flag: this is a card-colour question
      predCardCorrect: ttype, // 'red' or 'yellow'
      commentary:  setup,
      emoji:       '👀',
      predQuestion: ttype === 'red'
        ? `${surname} goes in — red or yellow?`
        : `${surname} fouls again — red or yellow?`,
      predOptions:  ['🟥 Red', '🟨 Yellow'],
      predCorrectOption: ttype === 'red' ? 0 : 1,
      linkedEventType:  ttype,
      linkedPlayerName: surname,
    });
  }

  // Goal events (not already scorer questions) → "Will they score?" question (YES)
  for (const e of eventsToShow) {
    if (e.type !== 'goal') continue;
    const beatForEvent = beats.find(b => b.isScorerQuestion && b.events.some(ev => ev === e));
    if (beatForEvent) continue; // already has a scorer question
    const p = getPlayer(e.playerId);
    if (!p) continue;
    const teaserMin  = Math.max(1, e.min - 2);
    const teaserReal = mapMatchMinToReal(teaserMin);
    const tooClose   = beats.some(b => Math.abs(b.realTime - teaserReal) < 2500)
                    || predCandidates.some(b => Math.abs(b.realTime - teaserReal) < 2500);
    if (tooClose) continue;
    const surname = p.name.split(' ').pop();
    const yesSetups = [
      `${surname} picks it up in space — this could be dangerous…`,
      `${surname} through on goal — only the keeper to beat…`,
      `${surname} arrives late into the box — will he finish?…`,
      `${surname} is clean through — one on one with the keeper…`,
    ];
    const setup = yesSetups[Math.floor(Math.random() * yesSetups.length)];
    predCandidates.push({
      realTime: teaserReal, matchMin: teaserMin, events: [], fake: true,
      isPrediction: true, predIsReal: true, predIsYesNo: true,
      commentary: setup, emoji: '👀',
      predQuestion: `${surname} is bearing down on goal — does he score?`,
      linkedEventType: 'goal', linkedPlayerName: surname,
    });
  }

  // Also add some NO-answer fake goal questions — tied to non-goal moments
  // Pick from fake near-miss beats OR invent positions in gaps with no real event
  // Use a drafted outfield player NOT in a real goal event for these
  const goalScorers = new Set(eventsToShow.filter(e => e.type === 'goal').map(e => e.playerId));
  const noQuestionPool = (state.myTeam.concat(state.oppTeam))
    .filter(id => { const p = getPlayer(id); return p && p.pos !== 'GK' && !goalScorers.has(id); });

  if (noQuestionPool.length > 0) {
    // Try to find 1–2 clean gaps for fake questions
    const fakeGapMins = [22, 67].filter(targetMin => {
      const targetReal = mapMatchMinToReal(targetMin);
      return !beats.some(b => Math.abs(b.realTime - targetReal) < 4000)
          && !predCandidates.some(b => Math.abs(b.realTime - targetReal) < 4000);
    });
    for (const targetMin of fakeGapMins) {
      const fp = noQuestionPool[Math.floor(Math.random() * noQuestionPool.length)];
      const surname = fp.name.split(' ').pop();
      const noSetups = [
        `${surname} shapes to shoot — keeper braced…`,
        `${surname} gets in behind — crowd on their feet…`,
        `${surname} cuts inside — looks dangerous…`,
        `${surname} strikes from range — screamer on…`,
      ];
      predCandidates.push({
        realTime: mapMatchMinToReal(targetMin), matchMin: targetMin, events: [], fake: true,
        isPrediction: true, predIsReal: false, predIsYesNo: true,  // NO is correct
        commentary: noSetups[Math.floor(Math.random() * noSetups.length)], emoji: '👀',
        predQuestion: `${surname} has a chance here — does he score?`,
        resolve: `${surname} skies it. Miles over. Nothing. Play continues.`,
        linkedEventType: 'goal', linkedPlayerName: surname,
      });
    }
  }

  // Shuffle and pick at most 2, spread across halves — mix YES and NO naturally
  const shuffle2 = arr => [...arr].sort(() => Math.random() - 0.5);
  // Pick one from each half if available; guarantee at least 1 total
  let pred1st  = shuffle2(predCandidates.filter(b => b.matchMin < 45))[0];
  let pred2nd  = shuffle2(predCandidates.filter(b => b.matchMin >= 45))[0];

  // If neither half has a candidate, try globally
  if (!pred1st && !pred2nd) {
    pred1st = shuffle2(predCandidates)[0];
  }
  // If we only have one, that's fine — better than none
  const chosenPreds = [pred1st, pred2nd].filter(Boolean);
  beats.push(...chosenPreds);

  // ── Inject near-miss fake beats into gaps ───────────────────────
  // Get all drafted player names for realistic fake commentary
  const draftedIds = [...new Set([...state.myTeam, ...state.oppTeam])];
  const draftedPlayers = draftedIds.map(id => getPlayer(id)).filter(Boolean);
  const outfield = draftedPlayers.filter(p => p.pos !== 'GK');
  const candidatePool = outfield.length > 0 ? outfield : draftedPlayers;

  // Work out if this match is VAR-era (PL VAR started 2019/20 season)
  const matchYear = m ? parseInt(m.meta.date.split(' ').pop()) : 2000;
  const allowVar  = matchYear >= 2019;

  // Sort real beats so we can find gaps and upcoming events
  beats.sort((a, b) => a.realTime - b.realTime);

  if (candidatePool.length > 0) {
    const usedMinutes = new Set();
    const fakesToInsert = [];

    // ── 1. Pre-event teasers: for each dramatic real event, plant a
    //       teaser beat ~2 min before using THAT player's name
    const dramaticTypes = ['red', 'yellow', 'goal', 'own_goal'];
    for (const e of eventsToShow) {
      if (!dramaticTypes.includes(e.type)) continue;
      const p = getPlayer(e.playerId);
      if (!p) continue;
      const teaser = getPreTeaser(e.type, p.name.split(' ').pop());
      if (!teaser) continue;

      const teaserMin     = Math.max(1, e.min - 2);
      const teaserRealTime = mapMatchMinToReal(teaserMin);

      // Don't crowd another beat
      const tooClose = beats.some(b => Math.abs(b.realTime - teaserRealTime) < 2500);
      if (tooClose || usedMinutes.has(teaserMin)) continue;
      usedMinutes.add(teaserMin);

      fakesToInsert.push({
        realTime:          teaserRealTime,
        matchMin:          teaserMin,
        events:            [],
        fake:              true,
        isTeaser:          true,
        setup:             teaser.setup,
        build:             teaser.trigger,
        resolve:           teaser.trigger,
        commentary:        teaser.setup,
        emoji:             '👀',
        linkedEventType:   e.type,
        linkedPlayerName:  p.name.split(' ').pop(),
      });
    }

    // ── 2. Near-miss fakes in gaps: 1 per medium gap, 2 per long gap
    const realBeats = beats.filter(b => !b.fake);
    for (let i = 0; i < realBeats.length - 1; i++) {
      const gap = realBeats[i+1].realTime - realBeats[i].realTime;
      if (gap < 4500) continue;

      const howMany = gap > 14000 ? 2 : 1;

      for (let k = 0; k < howMany; k++) {
        // Spread across the gap: 30% and 65%
        const ratio = howMany === 1 ? 0.4 : (k === 0 ? 0.28 : 0.65);
        const fakeRealTime = realBeats[i].realTime + Math.round(gap * ratio);
        const fakeMin = Math.round(
          realBeats[i].matchMin +
          (realBeats[i+1].matchMin - realBeats[i].matchMin) * ratio
        );

        const tooClose = [...beats, ...fakesToInsert].some(b => Math.abs(b.realTime - fakeRealTime) < 2200);
        if (tooClose || usedMinutes.has(fakeMin)) continue;
        usedMinutes.add(fakeMin);

        const player = candidatePool[Math.floor(Math.random() * candidatePool.length)];
        const miss   = pickNearMiss(player.name.split(' ').pop(), allowVar);

        fakesToInsert.push({
          realTime:    fakeRealTime,
          matchMin:    fakeMin,
          events:      [],
          fake:        true,
          isTeaser:    false,
          setup:       miss.setup,
          build:       miss.build,
          resolve:     miss.resolve,
          commentary:  miss.build,
          emoji:       '…',
          linkedPlayerName: player.name.split(' ').pop(),
          linkedEventType:  miss.type,
        });
      }
    }

    beats.push(...fakesToInsert);

    // ── 3. Guarantee 2–3 predictions per game ────────────────────
    const shuffle = arr => [...arr].sort(() => Math.random() - 0.5);

    const teaserOnly = fakesToInsert.filter(b => b.isTeaser);
    const firstHalf  = teaserOnly.filter(b => b.matchMin < 45);
    const secondHalf = teaserOnly.filter(b => b.matchMin >= 45);

    const pick1st = shuffle(firstHalf)[0];
    const pick2nd = shuffle(secondHalf)[0];
    const chosen  = [pick1st, pick2nd].filter(Boolean);

    if (chosen.length < 3) {
      const remaining = teaserOnly.filter(b => !chosen.includes(b));
      const extra = shuffle(remaining)[0];
      if (extra) chosen.push(extra);
    }

    for (const pb of chosen) {
      pb.isPrediction = true;
      pb.predIsReal   = true;
      const type = pb.linkedEventType || 'goal';
      const name = pb.linkedPlayerName || '';
      pb.predQuestion = getPredictionQuestion(type, name);
    }

    // ── Fallback: if we have fewer than 2 predictions, create standalone ones ──
    // These use drafted players and ask YES/NO about a random event type.
    // predIsReal = false means "no" is always the correct answer.
    if (chosen.length < 2) {
      const FALLBACK_TYPES = ['shot', 'card', 'yellow', 'goal'];
      const shuffledPool = shuffle(outfield.length > 0 ? outfield : candidatePool);
      const needed = 2 - chosen.length;

      for (let fi = 0; fi < needed && fi < shuffledPool.length; fi++) {
        const fp = shuffledPool[fi];
        const fType = FALLBACK_TYPES[Math.floor(Math.random() * FALLBACK_TYPES.length)];
        // Place in a gap — try 22' and 68'
        const targetMin = fi === 0 ? 22 : 68;
        const targetReal = mapMatchMinToReal(targetMin);
        const tooClose = [...beats, ...fakesToInsert, ...chosen].some(
          b => Math.abs(b.realTime - targetReal) < 3000
        );
        if (tooClose) continue;

        const fallbackBeat = {
          realTime:         targetReal,
          matchMin:         targetMin,
          events:           [],
          fake:             true,
          isTeaser:         false,
          isPrediction:     true,
          predIsReal:       false,
          predQuestion:     getPredictionQuestion(fType, fp.name.split(' ').pop()),
          commentary:       `${fp.name.split(' ').pop()} bursts into the box…`,
          emoji:            '👀',
          linkedPlayerName: fp.name.split(' ').pop(),
          linkedEventType:  fType,
        };
        fakesToInsert.push(fallbackBeat);
        chosen.push(fallbackBeat);
      }
    }
  }

  // ── Half-time beat — always inserted ───────────────────────────
  // Nudge any non-HT beats that fall within 2500ms of HT real time
  // so they don't collide with the swap screen
  const htRealTime = mapMatchMinToReal(45);
  for (const b of beats) {
    if (b.isHalfTime) continue;
    const diff = b.realTime - htRealTime;
    if (Math.abs(diff) < 2500) {
      b.realTime = diff < 0
        ? htRealTime - 2800  // push before HT
        : htRealTime + 2800; // push after HT
    }
  }
  beats.push({
    realTime:   htRealTime,
    matchMin:   45,
    events:     [],
    isHalfTime: true,
    fake:       true,
    commentary: `<strong>Half time.</strong> Referee blows for the break.`,
    emoji:      '🟡',
  });

  beats.push({ realTime: 57500, matchMin: 88, events: [], commentary: m ? m.meta.lateCommentary : "Late pressure. Time running out.", emoji: '⏱️' });
  beats.push({ realTime: 62000, matchMin: 90, events: [], commentary: m ? m.meta.finalCommentary : "<strong>Full time.</strong>", emoji: '🏁' });

  beats.sort((a, b) => a.realTime - b.realTime);
  return beats;
}

function mapMatchMinToReal(min) {
  return Math.round((min / 90) * 62000);
}

function runBeats(beats, idx) {
  if (idx >= beats.length) {
    applyFull90();
    setTimeout(() => showResults(), 2000);
    return;
  }

  // Apply tip penalty on the very first beat
  if (idx === 0 && state.tipTaken) {
    applyTipPenalty();
  }

  const beat = beats[idx];
  // Clamp delay: min 300ms to prevent synchronous cascade, max 8000ms to keep game moving
  const rawDelay = idx === 0 ? 500 : (beat.realTime - beats[idx-1].realTime);
  const delay = Math.min(8000, Math.max(300, rawDelay));

  simTimeout = setTimeout(() => {
    // Animate clock from previous minute to current beat minute
    const clockEl = document.getElementById('match-clock');
    if (clockEl) {
      const prevMin = idx === 0 ? 0 : beats[idx-1].matchMin;
      const targetMin = beat.matchMin;
      const spanMins = Math.max(1, targetMin - prevMin);
      // Speed up when gap is large (sparse events), slow when tight (busy)
      // delay = ms between beats; we fill it with smooth ticking
      const tickDuration = idx === 0 ? 400 : Math.max(400, delay - 300);
      const msPerMin = tickDuration / spanMins;
      
      if (_clockTicker) clearInterval(_clockTicker);
      let tickMin = prevMin;
      _clockTicker = setInterval(() => {
        tickMin = Math.min(tickMin + 1, targetMin);
        // Show 46' for first minute of second half 
        const displayMin = tickMin;
        clockEl.textContent = displayMin + "'";
        if (tickMin >= targetMin) {
          clearInterval(_clockTicker);
          _clockTicker = null;
        }
      }, Math.max(40, msPerMin)); // never faster than 40ms/tick
    }

    if (beat.fake) {
      if (beat.isHalfTime) {
        const htOverlay = document.getElementById('ht-overlay');
        const htScore   = document.getElementById('ht-score');
        const feed      = document.getElementById('commentary-feed');

        // Reset to announce phase
        const announcePhase = document.getElementById('ht-phase-announce');
        const swapPhase     = document.getElementById('ht-phase-swap');
        if (announcePhase) announcePhase.style.display = 'flex';
        if (swapPhase)     swapPhase.style.display = 'none';

        if (htScore) {
          const my  = Math.round(state.myScore);
          const opp = Math.round(state.oppScore);
          const name = state.teamName || 'You';
          htScore.textContent = `${name}  ${my > 0 ? '+' : ''}${my}  ·  Opp  ${opp > 0 ? '+' : ''}${opp}`;
        }

        if (htOverlay) htOverlay.style.display = '';
        if (feed) feed.classList.add('feed-halftime');
        if (_clockTicker) { clearInterval(_clockTicker); _clockTicker = null; }
        setCommentary('<strong>Half time.</strong> Referee blows for the break.', '⏸️');

        // Start multiplayer swap listener
        if (state.mp) mpListenForHtSwap();

        // Brief announce then show swap UI
        simTimeout = setTimeout(() => {
          showHtSwapUI(() => {
            // Swap done (or skipped) — resume second half
            if (feed) { feed.classList.remove('feed-halftime'); }
            const sub = document.getElementById('commentary-sub');
            if (sub) sub.style.display = 'none';
            // If in MP, show opp swap notification before 2nd half starts
            if (state.mp) showOppSwapNotification();
            setCommentary('Second half underway.', '🏟️');
            simTimeout = setTimeout(() => runBeats(beats, idx + 1), 800);
          });
        }, 2000);
        return;
      }

      if (beat.isPrediction) {
        const feed = document.getElementById('commentary-feed');
        if (feed) feed.classList.add('feed-building');
        // Use setup/build for teaser-style beats, commentary for card/yes-no beats
        const atmosLine = beat.setup || beat.build || beat.commentary || '';
        const triggerLine = beat.build || beat.commentary || atmosLine;
        setCommentary(atmosLine, '👁️');
        simTimeout = setTimeout(() => {
          setCommentary(triggerLine, '…');
          simTimeout = setTimeout(() => {
            showPrediction(beat, (playerAnswer) => {
              if (feed) feed.classList.remove('feed-building');
              if (beat.predIsReal) {
                setCommentary('Watch this space…', '👀');
              } else {
                setCommentary(beat.resolve || 'Nothing doing. Play continues.', beat.emoji || '💨');
              }
              applyPredictionResult(playerAnswer, beat.predIsReal);
              simTimeout = setTimeout(() => runBeats(beats, idx + 1), 2800);
            });
          }, 1400);
        }, 1800);
        return;
      }

      if (beat.isTeaser) {
        setCommentary(beat.commentary || beat.build, '👀');
        simTimeout = setTimeout(() => runBeats(beats, idx + 1), 2000);
        return;
      }

      // Standard near-miss: show build, pause, resolve
      setCommentary(beat.build, '…');
      simTimeout = setTimeout(() => {
        setCommentary(beat.resolve, beat.emoji);
        simTimeout = setTimeout(() => runBeats(beats, idx + 1), 1800);
      }, 2800);
      return;
    }

    // Helper: process all events for this beat and trigger flashes
    function applyBeatEvents() {
      state.pendingFlashes = [];
      for (const e of beat.events) {
        processSimEvent(e);
        if (e.type === 'goal') {
          const scorer = getPlayer(e.playerId);
          if (scorer && scorer.team === 'home') {
            state.liveHomeScore = (state.liveHomeScore || 0) + 1;
            const h = document.getElementById('live-home-score');
            if (h) h.textContent = state.liveHomeScore;
          } else if (scorer && scorer.team === 'away') {
            state.liveAwayScore = (state.liveAwayScore || 0) + 1;
            const a = document.getElementById('live-away-score');
            if (a) a.textContent = state.liveAwayScore;
          }
        }
      }
      const primaryEventType = beat.events.length
        ? beat.events.find(e => e.type === 'red')?.type
          || beat.events.find(e => e.type === 'goal')?.type
          || beat.events.find(e => e.type === 'yellow')?.type
          || beat.events[0]?.type
        : null;
      updateScoreDisplay(beat.matchMin, primaryEventType);
      renderSimPlayers();
      const flashes = state.pendingFlashes || [];
      flashes.forEach(({ id, delta }) => flashPlayer(id, delta));
      state.pendingFlashes = [];
    }

    if (beat.isScorerQuestion) {
      // Show suspense commentary FIRST (ball is in the net / someone saw red)
      // but don't reveal the scorer. Then ask the question. Then apply events + reveal.
      setCommentary(beat.commentary, beat.emoji);
      // Attach the event-application function to the beat so the mp path can call it too
      beat._applyEvents = applyBeatEvents;
      simTimeout = setTimeout(() => {
        if (state.mp) {
          mpShowScorerQuestion(beat, () => runBeats(beats, idx + 1));
        } else {
          showScorerQuestion(beat, (isCorrect, playerId) => {
            const { correctId } = beat.scorerOptions;
            // NOW apply events (scores, flashes, tiles) AFTER question answered
            applyBeatEvents();
            submitScorerAnswer(isCorrect, correctId, () => runBeats(beats, idx + 1), null, beat);
          });
        }
      }, 1000);
      return;
    }

    // Standard real event — process immediately and show commentary
    applyBeatEvents();
    if (beat.commentary) {
      setCommentary(beat.commentary, beat.emoji);
    }
    // Always use setTimeout to prevent synchronous stack overflow on clustered events
    simTimeout = setTimeout(() => runBeats(beats, idx + 1), 1500);
  }, delay);
}

function processSimEvent(event) {
  const player = getPlayer(event.playerId);
  if (!player) return;

  const baseD = getEventDelta(event, player);
  const mult  = captainMultiplier(player.id);
  const delta = baseD * mult;
  const inMyTeam  = state.myTeam.includes(player.id);
  const inOppTeam = state.oppTeam.includes(player.id);

  // Tutorial: first card and first goal explainers
  if (_tutorialActive) {
    if ((event.type === 'yellow' || event.type === 'red') && !state._tutShownCard) {
      state._tutShownCard = true;
      setTimeout(() => showTutorialCard('first_card', false).then(() => {}), 1200);
    } else if (event.type === 'goal' && !state._tutShownGoal) {
      state._tutShownGoal = true;
      setTimeout(() => showTutorialCard('first_goal', false).then(() => {}), 1200);
    }
  }

  if (inMyTeam) {
    state.myScore += delta;
    if (state.playerData[player.id]) {
      state.playerData[player.id].pts += delta;
      state.playerData[player.id].events.push(event.type);
      if (event.type === 'sub') state.playerData[player.id].subbed = true;
    }
  }
  if (inOppTeam) {
    state.oppScore += delta;
    if (state.playerData[player.id]) {
      state.playerData[player.id].pts += delta;
      state.playerData[player.id].events.push(event.type);
      if (event.type === 'sub') state.playerData[player.id].subbed = true;
    }
  }

  // Goals conceded: defenders & GK of the conceding team get bonus pts per goal
  if (event.type === 'goal') {
    const scoringTeam = player.team;
    const concedingTeam = scoringTeam === 'home' ? 'away' : 'home';
    const defenders = PLAYERS.filter(p =>
      p.team === concedingTeam && ['GK','CB','RB','LB'].includes(p.pos)
    );
    for (const dp of defenders) {
      const concedeDelta = getScoreForEvent('concede', dp) * captainMultiplier(dp.id);
      if (concedeDelta === 0) continue;
      const dpInMine = state.myTeam.includes(dp.id);
      const dpInOpp  = state.oppTeam.includes(dp.id);
      if (!dpInMine && !dpInOpp) continue;
      if (dpInMine && state.playerData[dp.id]) {
        state.myScore += concedeDelta;
        state.playerData[dp.id].pts += concedeDelta;
      }
      if (dpInOpp && state.playerData[dp.id]) {
        state.oppScore += concedeDelta;
        state.playerData[dp.id].pts += concedeDelta;
      }
    }
  }

  if (delta !== 0) state.pendingFlashes = (state.pendingFlashes || []).concat({ id: player.id, delta });
}

function applyFull90() {
  const allDrafted = [...new Set([...state.myTeam, ...state.oppTeam])];
  for (const id of allDrafted) {
    const player = getPlayer(id);
    const pd = state.playerData[id];
    if (!pd.subbed) {
      const delta = getScoreForEvent('full_90', player) * captainMultiplier(id);
      if (state.myTeam.includes(id)) state.myScore += delta;
      if (state.oppTeam.includes(id)) state.oppScore += delta;
      pd.pts += delta;
    }
  }
  updateScoreDisplay();
  renderSimPlayers();
}

function chaosLabel(pts, isWinning, isTied) {
  if (isTied)      return { text: 'LEVEL',      cls: 'level' };
  if (!isWinning)  return { text: 'BEHIND',      cls: 'losing' };
  const gap = Math.abs(pts - (isWinning ? state.oppScore : state.myScore));
  if (gap < 5)     return { text: 'EDGING IT',   cls: 'winning' };
  if (gap < 12)    return { text: 'AHEAD',        cls: 'winning' };
  if (gap < 22)    return { text: 'PULLING AWAY', cls: 'winning' };
  return             { text: 'RUNNING RIOT',  cls: 'winning' };
}

// ── Event timeline strip ─────────────────────────────────────
// Called from updateScoreDisplay on every beat.
// Progressively reveals events as they fire — no spoilers ahead of current minute.
function updateTimeline(currentMin, eventType) {
  if (currentMin === undefined) return;

  const isFirstHalf  = currentMin <= 45;
  const half2El      = document.getElementById('tl-half2');

  // Activate second half track once we cross HT
  if (!isFirstHalf && half2El) {
    half2El.classList.add('active');
  }

  // Update progress bar for current half
  if (isFirstHalf) {
    const pct = Math.min(100, (currentMin / 45) * 100);
    const bar = document.getElementById('tl-progress1');
    if (bar) bar.style.width = pct + '%';
  } else {
    const pct = Math.min(100, ((currentMin - 45) / 45) * 100);
    const bar = document.getElementById('tl-progress2');
    if (bar) bar.style.width = pct + '%';
  }

  // Map event types to emoji
  const EMOJI = { goal: '⚽', own_goal: '⚽', red: '🟥', yellow: '🟨', sub: '🔄' };
  const emoji = EMOJI[eventType] || null;
  if (!emoji) return; // non-visual beat (near-miss, prediction etc.) — no dot

  // Determine if this event is good or bad for the player
  // "good" = score went up vs opp; "bad" = score went down or opp benefited
  const delta    = state.myScore - state.oppScore;
  const prevDelta = state.deltaHistory.length >= 2
    ? state.deltaHistory[state.deltaHistory.length - 2].delta
    : 0;
  const improved = delta > prevDelta;
  const dotClass = improved ? 'good' : 'bad';

  // Pin event dot at correct horizontal position within the half track
  const container = isFirstHalf
    ? document.getElementById('tl-events1')
    : document.getElementById('tl-events2');
  if (!container) return;

  const halfMin   = isFirstHalf ? currentMin : (currentMin - 45);
  const pctPos    = Math.min(96, Math.max(2, (halfMin / 45) * 100)); // clamp so emoji doesn't clip edge

  const ev = document.createElement('div');
  ev.className = 'sim-timeline-event';
  ev.style.left = pctPos + '%';
  ev.innerHTML = `
    <div class="sim-timeline-emoji">${emoji}</div>
    <div class="sim-timeline-dot ${dotClass}"></div>
  `;
  container.appendChild(ev);
}

function updateScoreDisplay(matchMin, eventType) {
  // Record delta + update timeline
  if (matchMin !== undefined) {
    recordDelta(matchMin, eventType || null);
    updateTimeline(matchMin, eventType || null);
  }

  const my  = state.myScore;
  const opp = state.oppScore;
  const tied = my === opp;
  const meWin = my > opp;
  const gap = Math.abs(my - opp);

  const myEl    = document.getElementById('sim-my-status');
  const oppPts  = document.getElementById('sim-opp-pts');
  const gapLine = document.getElementById('sim-gap-line');

  // Left: YOUR score with status colour
  if (myEl) {
    const myRounded = Math.round(my);
    myEl.textContent = (myRounded >= 0 ? '+' : '') + myRounded;
    if (tied)   myEl.className = 'sim-score-status level';
    else if (meWin) myEl.className = 'sim-score-status winning';
    else        myEl.className = 'sim-score-status losing';
  }

  // Right: opponent raw score
  if (oppPts) {
    const oppRounded = Math.round(opp);
    oppPts.textContent = (oppRounded >= 0 ? '+' : '') + oppRounded;
  }

  // Middle: gap label
  if (gapLine) {
    if (tied) {
      gapLine.textContent = 'level';
    } else if (meWin) {
      if (gap < 5)       gapLine.textContent = 'edging it';
      else if (gap < 12) gapLine.textContent = 'ahead';
      else if (gap < 22) gapLine.textContent = 'pulling away';
      else               gapLine.textContent = 'running riot';
    } else {
      gapLine.textContent = `behind by ${Math.round(gap)}`;
    }
  }

  // Bar: shift both scores to be positive for percentage calculation
  const min = Math.min(my, opp, 0);
  const myAdj  = my  - min;
  const oppAdj = opp - min;
  const total  = myAdj + oppAdj;
  const myPct  = total > 0 ? (myAdj / total) * 100 : 50;
  const bar = document.getElementById('score-bar-fill');
  if (bar) bar.style.width = myPct + '%';
}

function setSimView(view) {
  state.simView = view;
  document.getElementById('sim-tab-me').classList.toggle('active', view === 'me');
  document.getElementById('sim-tab-pitch').classList.toggle('active', view === 'pitch');
  document.getElementById('sim-tab-opp').classList.toggle('active', view === 'opp');

  const pitchWrap = document.getElementById('sim-pitch-wrap');
  const playerList = document.getElementById('sim-players-list');

  if (view === 'pitch') {
    if (pitchWrap) pitchWrap.classList.add('active');
    if (playerList) playerList.style.display = 'none';
  } else {
    if (pitchWrap) pitchWrap.classList.remove('active');
    if (playerList) playerList.style.display = '';
    renderSimPlayers();
  }
}

function renderSimPlayers() {
  if (state.simView === 'pitch') return; // pitch view handles its own display
  const list = document.getElementById('sim-players-list');
  if (!list) return;
  const teamIds = state.simView === 'me' ? state.myTeam : state.oppTeam;

  // Sort by position: GK → DEF → MID → ATT
  const posOrder = { GK: 0, CB: 1, RB: 1, LB: 1, DM: 2, CM: 2, AM: 3, RW: 4, LW: 4, ST: 5 };
  const sorted = [...teamIds].sort((a, b) => {
    const pa = getPlayer(a), pb = getPlayer(b);
    return (posOrder[pa?.pos] ?? 9) - (posOrder[pb?.pos] ?? 9);
  });

  list.innerHTML = '';
  for (const id of sorted) {
    const p = getPlayer(id);
    if (!p) continue;
    const pd = state.playerData[id] || { pts: 0, events: [] };

    const row = document.createElement('div');
    const teamClass = p.team === 'home' ? 'team-home' : 'team-away';
    row.className = 'sim-player-row ' + teamClass + (pd.subbed ? ' subbed-off' : '');
    row.id = 'sim-row-' + id;

    const eventIcons = pd.events.map(e => ({
      goal: '⚽', assist: '🎯', yellow: '🟨', red: '🟥',
      own_goal: '😬', missed_pen: '❌', sub: '🔄'
    }[e] || '')).filter(Boolean);

    const ptsClass = pd.pts > 0 ? 'pts-positive' : pd.pts < 0 ? 'pts-negative' : 'pts-neutral';

    const captainBadge = isCaptain(id)
      ? `<span style="display:inline-flex;align-items:center;justify-content:center;background:#f5a623;color:white;font-family:'Bebas Neue',sans-serif;font-size:10px;letter-spacing:1px;width:18px;height:18px;border-radius:50%;margin-left:5px;vertical-align:middle;line-height:1;flex-shrink:0;">C</span>`
      : '';

    row.innerHTML = `
      <div class="sim-player-pos">${p.pos}</div>
      <div class="sim-player-name">${p.name}${captainBadge}${pd.htSubIn ? ' <span style="font-size:13px" title="Subbed in at HT">🔄</span>' : ''}${pd.subbed ? ' <span style="font-size:11px;color:#bbb">↓</span>' : ''}</div>
      <div class="sim-player-events">${eventIcons.slice(-3).map(i => `<span class="event-icon">${i}</span>`).join('')}</div>
      <div class="sim-player-pts ${ptsClass}">${pd.pts >= 0 ? '+' : ''}${pd.pts}</div>
    `;
    list.appendChild(row);
  }
}

const EVENT_EMOJI = {
  goal: '⚽', assist: '🎯', yellow: '🟨', red: '🟥',
  own_goal: '😬', missed_pen: '❌', sub: '🔄', hat_trick: '🎩',
  neutral: '🏟️', concede: '🥅', pen_save: '🧤',
};

function setCommentary(text, emoji, subText) {
  const el  = document.getElementById('commentary');
  const sub = document.getElementById('commentary-sub');
  const emo = document.getElementById('commentary-emoji');
  el.style.opacity  = '0';
  if (emo) emo.style.opacity = '0';
  setTimeout(() => {
    el.innerHTML = text;
    el.style.opacity = '1';
    if (sub) {
      if (subText) {
        sub.innerHTML = subText;
        sub.style.display = '';
      } else {
        sub.innerHTML = '';
        sub.style.display = 'none';
      }
    }
    if (emo) {
      emo.textContent  = emoji || '🏟️';
      emo.style.opacity = '1';
    }
  }, 200);
}

// ── Pitch event tile animation ───────────────────────────────
// Spawns a flying tile on the pitch for significant events (|delta| >= 3)
let _pitchTileQueue = []; // stagger multiple simultaneous tiles
let _pitchTileTimer = null;

const PITCH_EVENT_EMOJI = {
  goal: '⚽', assist: '🤝', yellow: '🟨', red: '🟥',
  own_goal: '🤦', missed_pen: '❌', sub: '🔄', full_90: '💪',
  hat_trick: '🎩', concede: '🥅', pen_save: '🧤',
};

function spawnPitchTile(playerId, delta) {
  const field = document.getElementById('pitch-field');
  if (!field) return;

  const player    = getPlayer(playerId);
  if (!player) return;

  const inMyTeam  = state.myTeam.includes(playerId);
  const inOppTeam = state.oppTeam.includes(playerId);
  if (!inMyTeam && !inOppTeam) return;

  // Determine which half of the pitch (top = opp, bottom = me)
  const isMyTeam  = inMyTeam;
  const isOppTeam = inOppTeam && !inMyTeam; // could be in both if something weird

  // Positive delta = good for the team that owns them
  // Green = positive points, Red = negative points
  const isPositive = delta > 0;
  const colClass = isPositive ? 'col-green' : 'col-red';

  // Direction: fly from left or right, alternate to avoid clumps
  const flyClass = (Math.random() < 0.5) ? 'fly-right' : 'fly-left';
  
  // Vertical position: opp half = top 40%, my half = bottom 40%
  // Add some random jitter within the half
  let topPct;
  if (isMyTeam && !isOppTeam) {
    topPct = 55 + Math.random() * 30; // 55–85% (bottom half)
  } else if (isOppTeam) {
    topPct = 10 + Math.random() * 30; // 10–40% (top half)  
  } else {
    topPct = 40 + Math.random() * 20; // both? middle
  }

  // Horizontal start position (left edge if fly-right, right edge if fly-left)
  // but we animate from off-screen so just set a middle landing zone
  const leftPct = 15 + Math.random() * 55; // land anywhere in 15–70% width

  // Get last event type for emoji
  const pd = state.playerData[playerId];
  const lastEvt = pd?.events?.[pd.events.length - 1];
  const emoji = PITCH_EVENT_EMOJI[lastEvt] || '';

  const name = player.name.split(' ').pop();
  const ptsStr = (delta > 0 ? '+' : '') + Math.round(delta);

  const tile = document.createElement('div');
  tile.className = `pitch-event-tile ${colClass} ${flyClass}`;
  tile.style.top  = topPct + '%';
  tile.style.left = leftPct + '%';
  tile.innerHTML = `
    <span class="pitch-tile-name">${name}</span>
    <span class="pitch-tile-pts">${ptsStr}</span>
    ${emoji ? `<span class="pitch-tile-emoji">${emoji}</span>` : ''}
  `;

  field.appendChild(tile);
  // Remove after animation completes
  setTimeout(() => tile.remove(), 2000);
}

function _drainPitchQueue() {
  if (_pitchTileQueue.length === 0) { _pitchTileTimer = null; return; }
  const { id, delta } = _pitchTileQueue.shift();
  spawnPitchTile(id, delta);
  _pitchTileTimer = setTimeout(_drainPitchQueue, 320);
}

function queuePitchTile(playerId, delta) {
  if (Math.abs(delta) < 2) return; // threshold: only ±2 or more
  _pitchTileQueue.push({ id: playerId, delta });
  if (!_pitchTileTimer) _drainPitchQueue();
}

function flashPlayer(playerId, delta) {
  // Always flash the commentary bar so something always visible reacts
  const feed = document.querySelector('.commentary-feed');
  if (feed) {
    const feedCls = delta > 0 ? 'feed-flash-pos' : 'feed-flash-neg';
    feed.classList.remove('feed-flash-pos', 'feed-flash-neg'); // reset if already animating
    void feed.offsetWidth; // force reflow to restart animation
    feed.classList.add(feedCls);
    setTimeout(() => feed.classList.remove(feedCls), 1600);
  }

  // Also flash the player row if it happens to be in the current view
  const row = document.getElementById('sim-row-' + playerId);
  if (row) {
    const cls = delta > 0 ? 'flash-positive' : 'flash-negative';
    row.classList.add(cls);
    setTimeout(() => row.classList.remove(cls), 800);

    const popup = document.createElement('div');
    popup.className = 'delta-popup ' + (delta > 0 ? 'positive' : 'negative');
    popup.textContent = (delta > 0 ? '+' : '') + delta;
    row.appendChild(popup);
    setTimeout(() => popup.remove(), 1200);
  }

  // Spawn a pitch tile animation for significant events
  queuePitchTile(playerId, delta);
}

// ═══════════════════════════════════════════════════════════════
// RESULTS
// ═══════════════════════════════════════════════════════════════
function showResults() {
  // Tutorial: end-of-game explainer, then mark tutorial complete
  if (_tutorialActive) {
    _tutorialActive = false;
    showTutorialCard('post_match', false).then(() => {});
  }
  // In mp mode: write our score to Firebase first, then wait for opponent's
  if (state.mp) {
    mpWriteScore(state.myScore);
    // Listen for opponent score to show final comparison
    // Register via _mpUnsubs so mpCleanup() can kill it if needed
    let _resultsRendered = false;
    const _resultsUnsub = window._fb.onValue(state.mp.sessionRef, (snap) => {
      const d = snap.val();
      if (!d || _resultsRendered) return;
      const myScore  = state.mp.role === 'A' ? d.scoreA : d.scoreB;
      const oppScore = state.mp.role === 'A' ? d.scoreB : d.scoreA;
      const myTs     = state.mp.role === 'A' ? d.scoreATs : d.scoreBTs;
      const oppTs    = state.mp.role === 'A' ? d.scoreBTs : d.scoreATs;
      const sessionStart = d.createdAt || 0;
      // Both scores must be present AND written after session started (prevents stale cache)
      const myFresh  = myScore  !== null && myScore  !== undefined && (!myTs  || myTs  >= sessionStart);
      const oppFresh = oppScore !== null && oppScore !== undefined && (!oppTs || oppTs >= sessionStart);
      if (myFresh && oppFresh) {
        _resultsRendered = true;
        try { _resultsUnsub(); } catch(e) {}
        // Use Firebase scores as source of truth for both players
        // so winner/loser is always consistent across devices
        state.myScore  = myScore;
        state.oppScore = oppScore;
        _renderResults();
      }
    });
    window._mpUnsubs.push(_resultsUnsub);
    // Timeout fallback: if opponent score never arrives after 20s, use local scores
    setTimeout(() => {
      if (!_resultsRendered) {
        _resultsRendered = true;
        try { _resultsUnsub(); } catch(e) {}
        console.warn('MP results timeout - using local scores');
        _renderResults();
      }
    }, 20000);
    // Show loading state while waiting
    showScreen('results');
    document.getElementById('result-headline').textContent = 'CALCULATING…';
    document.getElementById('result-sub').textContent = 'Waiting for opponent score…';
    return;
  }

  _renderResults();
}

function _renderResults() {
  const myWon = state.myScore > state.oppScore;
  const tied  = state.myScore === state.oppScore;

  // ── Save result to active profile ────────────────────────────
  const m = ALL_MATCHES[state.matchIdx];
  if (m && _activeProfileId) {
    const captain = state.myCaptain ? PLAYERS.find(p => p.id === state.myCaptain) : null;
    recordMatchResult({
      matchId:      m.id,
      matchLabel:   `${m.meta.home} ${m.meta.score} ${m.meta.away}`,
      result:       myWon ? 'W' : tied ? 'D' : 'L',
      myScore:      state.myScore,
      oppScore:     state.oppScore,
      captainName:  captain ? captain.name.split(' ').pop() : null,
    });
    renderPostMatchFormTile();
  }

  // Headline
  const headlines = {
    win:  ['YOU BEAUTY', 'DRAFTED PERFECTLY', 'CHAOS MERCHANT'],
    lose: ['TOO SENSIBLE MATE', 'NICE GUYS FINISH LAST', 'BACK TO SCHOOL'],
    tie:  ['HONOURS EVEN', "A GENTLEMAN'S DRAW"],
  };
  const hl = myWon ? headlines.win : tied ? headlines.tie : headlines.lose;
  document.getElementById('result-headline').textContent = hl[Math.floor(Math.random() * hl.length)];

  // Render team badges in results header
  const resBadgeRow = document.getElementById('results-badges-row');
  if (resBadgeRow && m) {
    const hc = state.resolvedHomeColour || m.meta.homeColour || '#6CABDD';
    const ac = state.resolvedAwayColour || m.meta.awayColour || '#FBEE23';
    resBadgeRow.innerHTML = `
      <div class="results-badge-item">
        ${getTeamBadge(m.meta.home, hc, 38)}
        <div class="results-badge-name">${m.meta.home}</div>
      </div>
      <div class="results-badge-score">${m.meta.score}</div>
      <div class="results-badge-item">
        ${getTeamBadge(m.meta.away, ac, 38)}
        <div class="results-badge-name">${m.meta.away}</div>
      </div>
    `;
  }

  // Single full-width result tile
  // Guard against NaN in mp mode where scores are async
  if (state.myScore == null) state.myScore = 0;
  if (state.oppScore == null) state.oppScore = 0;
  const gap = Math.abs(Math.round(state.myScore) - Math.round(state.oppScore));

  function resultEmoji(won, isTied) {
    if (isTied) return '🤝';
    if (!won) {
      if (gap >= 21) return '💀';
      if (gap >= 18) return '😵';
      if (gap >= 15) return '😩';
      if (gap >= 12) return '😤';
      if (gap >= 9)  return '😬';
      if (gap >= 6)  return '😅';
      return '🤌';
    } else {
      if (gap >= 21) return '🐐';
      if (gap >= 18) return '👑';
      if (gap >= 15) return '🏆';
      if (gap >= 12) return '💪';
      if (gap >= 9)  return '🔥';
      if (gap >= 6)  return '😄';
      return '😏';
    }
  }

  function resultWord(won, isTied) {
    if (isTied) return 'ALL SQUARE';
    if (won) {
      if (gap <= 3)  return 'JUST ABOUT';
      if (gap <= 10) return 'WINNER';
      if (gap <= 15) return 'DOMINANT';
      return 'OBLITERATED';
    } else {
      if (gap <= 3)  return 'SO CLOSE';
      if (gap <= 10) return 'BEATEN';
      if (gap <= 15) return 'OUTCLASSED';
      return 'SCHOOLED';
    }
  }

  function resultDetail(won, isTied) {
    if (isTied) return 'All square on chaos points';
    if (won) return `You won by ${gap} chaos point${gap === 1 ? '' : 's'}`;
    return `You lost by ${gap} chaos point${gap === 1 ? '' : 's'}`;
    // Note: gap is always a whole number (rounded above)
  }

  const myCard = document.getElementById('my-score-card');
  if (myCard) {
    const stateClass = tied ? 'tied' : myWon ? 'winner' : 'loser';
    myCard.className = `result-score-card full ${stateClass}`;

    const myLabel = document.getElementById('my-score-label');
    if (myLabel) {
      myLabel.textContent = state.teamName || 'You';
    }
    document.getElementById('my-result-emoji').textContent   = resultEmoji(myWon, tied);
    document.getElementById('my-result-outcome').textContent = resultWord(myWon, tied);
    document.getElementById('my-score-detail').textContent   = resultDetail(myWon, tied);
  }

  // ── MATCH REPORT ──────────────────────────────────────────────
  const allDrafted = [...new Set([...state.myTeam, ...state.oppTeam])];
  const withPts = allDrafted.map(id => ({
    player: getPlayer(id),
    pts: state.playerData[id] ? state.playerData[id].pts : 0,
    events: state.playerData[id] ? state.playerData[id].events : [],
    mine: state.myTeam.includes(id)
  })).filter(item => item.player);

  withPts.sort((a, b) => b.pts - a.pts);

  const reportEl = document.getElementById('match-report');
  if (reportEl && m) {

    // ── Stats table ──────────────────────────────────────────────
    const countEvt = (team, type) =>
      EVENTS.filter(e => e.type === type && PLAYERS.find(p => p.id === e.playerId && p.team === team)).length;

    const homeGoals   = countEvt('home', 'goal');
    const awayGoals   = countEvt('away', 'goal');
    const homeYellows = countEvt('home', 'yellow');
    const awayYellows = countEvt('away', 'yellow');
    const homeReds    = countEvt('home', 'red');
    const awayReds    = countEvt('away', 'red');
    const homePens    = countEvt('home', 'missed_pen');
    const awayPens    = countEvt('away', 'missed_pen');
    const homeOGs     = countEvt('home', 'own_goal');
    const awayOGs     = countEvt('away', 'own_goal');

    function statRow(label, home, away) {
      const hStr = home > 0 ? `<span class="stat-val-active">${home}</span>` : `<span class="stat-val-zero">0</span>`;
      const aStr = away > 0 ? `<span class="stat-val-active">${away}</span>` : `<span class="stat-val-zero">0</span>`;
      return `<div class="stat-row"><div class="stat-home">${hStr}</div><div class="stat-label">${label}</div><div class="stat-away">${aStr}</div></div>`;
    }

    const statsHtml = `
      <div class="stats-table">
        <div class="stats-header">
          <div class="stats-team-name">${m.meta.home}</div>
          <div></div>
          <div class="stats-team-name">${m.meta.away}</div>
        </div>
        ${statRow('Goals', homeGoals, awayGoals)}
        ${statRow('Yellow cards', homeYellows, awayYellows)}
        ${statRow('Red cards', homeReds, awayReds)}
        ${statRow('Missed pens', homePens, awayPens)}
        ${statRow('Own goals', homeOGs, awayOGs)}
      </div>
    `;

    // ══════════════════════════════════════════════════════════════
    // MATCH REPORT BOXES — your team only, rotating label sets
    // ══════════════════════════════════════════════════════════════

    function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

    // Only your drafted players, sorted by pts
    const myOnly   = withPts.filter(item => item.mine);
    const mySorted = [...myOnly].sort((a, b) => b.pts - a.pts);
    const topItem  = mySorted[0];
    const midItem  = mySorted[Math.floor(mySorted.length / 2)];
    const botItem  = mySorted[mySorted.length - 1];

    // ── Label sets — one chosen at random per game ──
    // [chaosLabel, mehLabel, competentLabel]
    const LABEL_SETS = [
      ['🔥 CHAOS KING',          '😐 JUST THERE',           '😤 TOO GOOD'],
      ['💀 DISASTER',            '📋 PASSENGER',             '🙄 EMBARRASSINGLY GOOD'],
      ['🌪️ BEAUTIFUL DISASTER',  '🥱 AVERAGE JOE',           '🫠 SICKENINGLY COMPETENT'],
      ['😈 GLORIOUSLY TERRIBLE', '🤷 MEH',                   '😒 ANNOYINGLY DECENT'],
      ['⚡ CERTIFIED MENACE',    '👻 GHOST',                  '💔 ABSOLUTE BETRAYAL'],
      ['🏆 HALL OF FAME',        '🪑 BENCH WARMER ENERGY',   '😡 UNFORGIVABLE'],
    ];
    const labelSet = LABEL_SETS[Math.floor(Math.random() * LABEL_SETS.length)];

    // Tier assignment — flat game means everyone drifts meh
    const ptRange = (topItem?.pts || 0) - (botItem?.pts || 0);
    function getTier(item) {
      if (ptRange < 6) return 'meh';
      if (item === topItem && item.pts > 4)  return 'chaos';
      if (item === botItem && item.pts < 2)  return 'competent';
      return 'meh';
    }
    function getLabelForTier(tier) {
      if (tier === 'chaos')     return labelSet[0];
      if (tier === 'competent') return labelSet[2];
      return labelSet[1];
    }

    // ── CHAOS BLURBS ──
    function chaosBlurb(item) {
      const evts      = item.events || [];
      const n         = item.player.name;
      const pts       = item.pts;
      const redCard   = evts.includes('red');
      const ownGoal   = evts.includes('own_goal');
      const dblYellow = evts.filter(e => e === 'yellow').length >= 2;
      const yellow    = evts.includes('yellow');
      const hookedOff = evts.includes('sub') && !redCard;
      const missedPen = evts.includes('missed_pen');

      if (redCard && ownGoal) return pick([
        `<strong>${n}</strong> managed to score an own goal AND get sent off in the same game. In the same <em>half</em>. You could not have scripted this. <strong>+${pts} pts</strong> — an all-time performance.`,
        `<strong>${n}</strong> put one in his own net, collected a red card, and left the pitch early. A complete and utter masterpiece. <strong>+${pts} pts</strong>. Frame it.`,
      ]);
      if (redCard) return pick([
        `<strong>${n}</strong> was shown a straight red and given his marching orders before most people had finished their half-time tea. Commitment to the cause. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> lasted ${pick(['58','44','51','67'])} minutes before deciding the laws of football no longer applied to him personally. Off he went. Brilliant. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> went in two-footed, appealed, got booked, appealed again, got sent off, and trudged away looking furious about the whole thing. <strong>+${pts} pts</strong>. Hall of fame.`,
        `Two yellows. Same half. <strong>${n}</strong> saw the first one coming and did it anyway. Bold. Stupid. Beautiful. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> collected a straight red for something the referee described as reckless. We'd describe it as generous. <strong>+${pts} pts</strong>.`,
      ]);
      if (ownGoal) return pick([
        `<strong>${n}</strong> assessed all his options, considered the situation carefully, and put the ball into his own net. Technically an assist for the other side. We're counting it. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> took one touch and scored — tragically, for the wrong team. A flap, a fumble, the ball rolled over the line apologetically. Poetry. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> did not mean to score. He scored anyway. This game rewards accidental genius and we are all richer for it. <strong>+${pts} pts</strong>.`,
        `The keeper came for a cross he had absolutely no business attempting, missed it by a yard, and the rest followed naturally. <strong>${n}</strong>. Magnificent. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> redirected it perfectly into his own net. Technically difficult. Entirely unwanted. Absolutely beautiful. <strong>+${pts} pts</strong>.`,
      ]);
      if (dblYellow) return pick([
        `<strong>${n}</strong> picked up two yellows in nine minutes. The first was debatable. The second was a lifestyle choice. <strong>+${pts} pts</strong>.`,
        `Booked. Booked again. Off. <strong>${n}</strong> had a complete shocker and we are here for every second of it. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> somehow convinced himself a second yellow was a good idea. It was not a good idea. It was a great idea. <strong>+${pts} pts</strong>.`,
      ]);
      if (missedPen) return pick([
        `<strong>${n}</strong> stepped up from the spot, sent the keeper the wrong way, and hit the post. Stood there. Walked back. An entire story told in twelve yards. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> ballooned it over from twelve yards. Over the bar. From the penalty spot. An art form. <strong>+${pts} pts</strong>.`,
        `The penalty was there for the taking. <strong>${n}</strong> chose not to take it. He chose chaos instead. Correct decision. <strong>+${pts} pts</strong>.`,
      ]);
      if (hookedOff) return pick([
        `<strong>${n}</strong> was hauled off before the hour mark and the manager looked relieved about it. So were we. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> lasted ${pick(['52','61','48','55','43'])} minutes before the dugout had seen enough. The feeling was mutual. <strong>+${pts} pts</strong>.`,
        `Subbed off at half time. <strong>${n}</strong> did enough damage in 45 minutes that the manager clearly felt the rest of the team needed a rest from him. <strong>+${pts} pts</strong>.`,
      ]);
      if (yellow) return pick([
        `<strong>${n}</strong> booked himself into the referee's notebook with a challenge that fooled absolutely nobody. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> went in a bit there. The referee had several words. The card came out. Entirely predictable. Entirely welcome. <strong>+${pts} pts</strong>.`,
        `A booking for <strong>${n}</strong> — something about unsporting conduct. Sporting conduct was never really the goal here. <strong>+${pts} pts</strong>.`,
      ]);
      return pick([
        `<strong>${n}</strong> spent 90 minutes being an absolute liability in the most committed, professional way possible. You drafted him for this moment. He delivered. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> created more problems for his own side than the opposition managed all afternoon. A rare gift. An absolute treasure. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> had a complete and utter nightmare and we mean that as the highest possible compliment. <strong>+${pts} pts</strong>.`,
        `<strong>${n}</strong> contributed chaos at every turn, in every phase of the game, with admirable consistency. The total package. <strong>+${pts} pts</strong>.`,
      ]);
    }

    // ── MEH BLURBS ──
    function mehBlurb(item) {
      const evts   = item.events || [];
      const n      = item.player.name;
      const pts    = item.pts;
      const pStr   = `<strong>${pts >= 0 ? '+' : ''}${pts} pts</strong>`;

      if (evts.length === 0) return pick([
        `<strong>${n}</strong> completed his passes. Kept his shape. Went home. A man at complete peace with his own mediocrity. ${pStr}.`,
        `<strong>${n}</strong> was technically on the pitch for 90 minutes. Spiritually, he checked out around the hour mark. ${pStr}.`,
        `<strong>${n}</strong> touched it fourteen times. None of those touches will live long in the memory. This entry is the most attention he'll ever receive. ${pStr}.`,
        `<strong>${n}</strong> jogged, passed sideways, jogged back. Repeat. For ninety minutes. The circle of life. ${pStr}.`,
        `<strong>${n}</strong> positioned himself correctly on every set piece. Nothing came of any of them. A career in miniature. ${pStr}.`,
        `<strong>${n}</strong> was available for the ball at all times. The ball was not particularly interested. A mutual understanding. ${pStr}.`,
        `The match happened around <strong>${n}</strong> rather than involving him. Like a rock in a stream. ${pStr}.`,
        `<strong>${n}</strong> existed. Professionally. For ninety minutes. Collected his wages and went home without incident. ${pStr}.`,
        `<strong>${n}</strong> made one tackle. Won it. That's the whole story. That's genuinely everything. ${pStr}.`,
        `The cameras barely found <strong>${n}</strong> all afternoon. The editors knew something we didn't. ${pStr}.`,
        `<strong>${n}</strong> was neither a help nor a hindrance. A human traffic cone. A man-shaped placeholder. ${pStr}.`,
        `Ninety minutes. One touch map that looks like someone dropped their phone on the pitch. <strong>${n}</strong>. ${pStr}.`,
      ]);
      const bits = [];
      if (evts.includes('yellow')) bits.push(pick(['a booking that surprised nobody','a yellow card, eventually','getting into the referee\'s notebook briefly']));
      if (evts.includes('sub'))    bits.push(pick(['coming off on the hour','getting the hook — presumably for tactical reasons','being replaced, to little fanfare']));
      if (evts.includes('goal'))   bits.push(pick(['a goal — noted, filed, forgotten','finding the net once, which is once more than expected']));
      if (evts.includes('assist')) bits.push(pick(['an assist of sorts','laying one on, technically']));
      const desc = bits.join(' and ') || 'a deeply average afternoon';
      return pick([
        `<strong>${n}</strong> gave us ${desc}. ${pStr}. Neither one thing nor the other.`,
        `<strong>${n}</strong> — ${desc}. ${pStr}. Could have been worse. Wasn't much better.`,
        `${desc.charAt(0).toUpperCase() + desc.slice(1)} from <strong>${n}</strong>. ${pStr}. Make of that what you will.`,
      ]);
    }

    // ── COMPETENT BLURBS ──
    function competentBlurb(item) {
      const evts      = item.events || [];
      const n         = item.player.name;
      const pts       = item.pts;
      const goalCount = evts.filter(e => e === 'goal').length;
      const astCount  = evts.filter(e => e === 'assist').length;
      const pStr      = `<strong>${pts >= 0 ? '+' : ''}${pts} pts</strong>`;

      if (goalCount >= 3) return pick([
        `<strong>${n}</strong> scored a hat-trick. A hat-trick. You drafted him to be a liability and he scored a hat-trick. You are not okay. ${pStr}.`,
        `Three goals. <strong>${n}</strong>. In your squad. Helping the wrong cause with extraordinary efficiency and zero self-awareness. ${pStr}. Unforgivable.`,
      ]);
      if (goalCount === 2) return pick([
        `<strong>${n}</strong> bagged a brace. Like someone who actually wanted to be useful. The absolute nerve. ${pStr}.`,
        `Two goals from <strong>${n}</strong>. Two. You needed him distracted and ineffective. He had completely other ideas. ${pStr}.`,
      ]);
      if (goalCount === 1 && astCount >= 1) return pick([
        `<strong>${n}</strong> scored and assisted. Contributing at both ends of the attacking phase like some kind of professional footballer. Disgusting. ${pStr}.`,
        `A goal and an assist from <strong>${n}</strong>, who apparently did not receive the brief. ${pStr}. Composed. Useful. Completely wrong for this squad.`,
      ]);
      if (goalCount === 1) return pick([
        `<strong>${n}</strong> scored a goal. Obviously. Because of course he did. You drafted him specifically to fail and he found the net. ${pStr}. Cheers for that.`,
        `<strong>${n}</strong> chipped in with a goal like it was nothing. Like it was the most natural thing in the world. ${pStr}. It was not welcome.`,
        `A goal from <strong>${n}</strong>. Cool. Great. Fantastic. Not what we needed at all but here we are. ${pStr}.`,
      ]);
      if (astCount >= 2) return pick([
        `<strong>${n}</strong> set up ${astCount} goals. ${astCount}. Running the game, laying things on, making himself useful in ways that actively hurt you. ${pStr}.`,
        `Two assists from <strong>${n}</strong>, who spent the afternoon doing exactly what you did not want him to do. ${pStr}. Sickeningly competent.`,
      ]);
      if (astCount === 1) return pick([
        `<strong>${n}</strong> laid one on a plate and that was more than enough of a contribution. An assist. From your squad. ${pStr}.`,
        `<strong>${n}</strong> set one up with a pass that the commentators called intelligent. Intelligent. In a Worst Eleven squad. ${pStr}.`,
      ]);
      return pick([
        `<strong>${n}</strong> kept his position, won his headers, and completed passes with alarming frequency. You needed a disaster. You got a professional. ${pStr}.`,
        `There was nothing wrong with <strong>${n}</strong>'s performance. That is the problem. That is the whole, entire problem. ${pStr}.`,
        `<strong>${n}</strong> played the full 90, made no mistakes, and looked like he actually wanted to be there. Completely unusable. ${pStr}.`,
        `Professional. Composed. Reliable. Three words that should never appear in a Worst Eleven report. And yet. <strong>${n}</strong>. ${pStr}.`,
        `<strong>${n}</strong> dominated his position so thoroughly the opposition gave up trying to go through him. You did not want that. ${pStr}.`,
        `You picked <strong>${n}</strong> specifically for his reputation for trouble. He appeared to have read the scouting report and done the opposite. ${pStr}.`,
        `<strong>${n}</strong> read the game beautifully, stepped in at exactly the right moments, and was quietly excellent for the full 90. You are furious. He is oblivious. ${pStr}.`,
        `<strong>${n}</strong> made his opposite number look ordinary. You did not want him making anyone look ordinary. You wanted him looking ordinary. ${pStr}.`,
      ]);
    }

    // ── Assemble tiles ──
    function buildTile(item) {
      if (!item) return '';
      const tier      = getTier(item);
      const label     = getLabelForTier(tier);
      const blurb     = tier === 'chaos' ? chaosBlurb(item) : tier === 'meh' ? mehBlurb(item) : competentBlurb(item);
      const tileClass = tier === 'chaos' ? 'gbu-good' : tier === 'competent' ? 'gbu-ugly' : 'gbu-bad';
      return `<div class="gbu-tile ${tileClass}"><div class="gbu-label">${label}</div><div class="gbu-text">${blurb}</div></div>`;
    }

    const gbuHtml = `<div class="gbu-grid">${buildTile(topItem)}${buildTile(midItem)}${buildTile(botItem)}</div>`;
    reportEl.innerHTML = statsHtml + gbuHtml;
  }

  // ── WORST ELEVEN LEADERBOARD ─────────────────────────────────
  // Top 11 players by pts across both teams
  withPts.sort((a, b) => b.pts - a.pts);
  const top11 = withPts.slice(0, 11);
  const contList = document.getElementById('contributors-list');
  if (contList) {
    contList.innerHTML = '';
    for (const item of top11) {
      const row = document.createElement('div');
      row.className = 'contributor-row';
      const ownerLabel = item.mine
        ? '<span style="color:var(--blue);font-size:10px;font-weight:700;">YOU</span>'
        : '<span style="color:var(--red);font-size:10px;font-weight:700;">OPP</span>';
      const ptsColor = item.pts > 0 ? '#22c55e' : item.pts < 0 ? 'var(--red)' : 'var(--muted)';
      row.innerHTML = `
        <div class="contributor-pos">${item.player.pos}</div>
        <div class="contributor-name">${item.player.name} <span class="contributor-team">${item.player.teamName}</span></div>
        <div style="margin-right:8px;">${ownerLabel}</div>
        <div class="contributor-pts" style="color:${ptsColor}">${item.pts >= 0 ? '+' : ''}${item.pts}</div>
      `;
      contList.appendChild(row);
    }
  }

  // ── BADGES ────────────────────────────────────────────────────
  const badges = [];
  const myOwnGoals = state.myTeam.filter(id => state.playerData[id] && state.playerData[id].events.includes('own_goal')).length;
  const myYellows  = state.myTeam.filter(id => state.playerData[id] && state.playerData[id].events.includes('yellow')).length;
  if (state.myScore >= 40) badges.push({ icon: '💥', name: 'Chaos Lord', desc: '40+ points' });
  if (myOwnGoals >= 1)     badges.push({ icon: '😬', name: 'Own Goal FC', desc: 'Own goal in squad' });
  if (myYellows  >= 2)     badges.push({ icon: '🟨', name: 'Card Magnet', desc: '2+ yellows' });
  if (myWon)               badges.push({ icon: '🏆', name: 'Worst Winner', desc: 'Outscored opponent' });
  if (badges.length === 0) badges.push({ icon: '😴', name: 'Too Sensible', desc: 'Pick worse next time' });

  const badgeList = document.getElementById('badges-list');
  if (badgeList) {
    badgeList.innerHTML = '';
    for (const b of badges) {
      const el = document.createElement('div');
      el.className = 'badge';
      el.innerHTML = `<span class="badge-icon">${b.icon}</span><span class="badge-name">${b.name}</span><span class="badge-desc">${b.desc}</span>`;
      badgeList.appendChild(el);
    }
  }

  showScreen('results');
  // Double rAF + small timeout ensures the canvas is laid out before we draw
  requestAnimationFrame(() => requestAnimationFrame(() => {
    setTimeout(() => drawResultGraph(), 50);
  }));
}

function shareResult() {
  const won = state.myScore > state.oppScore;
  const text = `⚽ WORST ELEVEN — MCI 8-0 WAT\n${won ? '🏆 I won!' : '😅 I lost...'}\nMe: ${state.myScore} vs Opp: ${state.oppScore}\n\nChaos rating: top ${state.myScore > 140 ? '5%' : '20%'}\n\nPlay at worst-eleven.com`;
  if (navigator.share) {
    navigator.share({ text });
  } else {
    navigator.clipboard.writeText(text).then(() => showToast('Result copied to clipboard!'));
  }
}

// ═══════════════════════════════════════════════════════════════
// UTILS
// ═══════════════════════════════════════════════════════════════
function getPlayer(id) {
  return PLAYERS.find(p => p.id === id);
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2200);
}

// ═══════════════════════════════════════════════════════════════
// LIVE DELTA GRAPH
// ═══════════════════════════════════════════════════════════════

function getDeltaEmoji(delta) {
  if (delta >= 20)  return '🐐';
  if (delta >= 10)  return '📈';
  if (delta >= 3)   return '😏';
  if (delta >= -2)  return '🤝';
  if (delta >= -10) return '😬';
  if (delta >= -20) return '📉';
  return '💀';
}

function recordDelta(matchMin, eventType) {
  const delta = state.myScore - state.oppScore;
  state.deltaHistory.push({ min: matchMin, delta, eventType: eventType || null });
  drawLiveGraph(matchMin);
}

function drawLiveGraph(currentMin) {
  const canvas = document.getElementById('sim-graph');
  if (!canvas) return;

  // Size canvas to element
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width  = Math.round(rect.width  * window.devicePixelRatio);
  canvas.height = Math.round(rect.height * window.devicePixelRatio);
  const W = canvas.width;
  const H = canvas.height;
  const ctx = canvas.getContext('2d');
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  const w = rect.width;
  const h = rect.height;

  ctx.clearRect(0, 0, W, H);

  // Rolling 30-min window
  const windowSize = 30;
  const winStart = Math.max(0, currentMin - 15);
  const winEnd   = winStart + windowSize;

  const Y_MAX = 25;
  const PAD_L = 28;
  const PAD_R = 28;
  const PAD_T = 6;
  const PAD_B = 6;
  const plotW = w - PAD_L - PAD_R;
  const plotH = h - PAD_T - PAD_B;

  function xPos(min)   { return PAD_L + ((min - winStart) / windowSize) * plotW; }
  function yPos(delta) { return PAD_T + plotH * 0.5 - (delta / Y_MAX) * (plotH * 0.5); }

  // Zero line
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(PAD_L, yPos(0));
  ctx.lineTo(w - PAD_R, yPos(0));
  ctx.stroke();
  ctx.setLineDash([]);

  // Y axis labels
  ctx.font = '9px DM Mono, monospace';
  ctx.fillStyle = '#333';
  ctx.textAlign = 'right';
  ctx.fillText('+25', PAD_L - 3, yPos(25) + 3);
  ctx.fillText('0',   PAD_L - 3, yPos(0)  + 3);
  ctx.fillText('−25', PAD_L - 3, yPos(-25) + 3);

  // Build point list — start at 0,0 always visible in window
  const pts = [{ min: Math.max(0, winStart), delta: 0 }];

  // Add history points that fall in or before window
  for (const p of state.deltaHistory) {
    if (p.min >= winStart && p.min <= winEnd) pts.push(p);
    else if (p.min < winStart) {
      // last point before window sets the starting delta
      pts[0] = { min: winStart, delta: p.delta };
    }
  }

  // Add current position (trailing edge)
  const lastDelta = state.deltaHistory.length
    ? state.deltaHistory[state.deltaHistory.length - 1].delta
    : 0;
  if (currentMin <= winEnd) {
    pts.push({ min: currentMin, delta: lastDelta });
  }

  // Sort by minute
  pts.sort((a, b) => a.min - b.min);

  if (pts.length < 2) {
    // Just a dot at zero
    ctx.fillStyle = '#444';
    ctx.beginPath();
    ctx.arc(xPos(currentMin), yPos(0), 3, 0, Math.PI * 2);
    ctx.fill();
    return;
  }

  // Draw filled area under line
  const grad = ctx.createLinearGradient(0, PAD_T, 0, h - PAD_B);
  grad.addColorStop(0,   'rgba(74,222,128,0.15)');
  grad.addColorStop(0.5, 'rgba(74,222,128,0)');
  grad.addColorStop(0.5, 'rgba(248,113,113,0)');
  grad.addColorStop(1,   'rgba(248,113,113,0.15)');

  ctx.beginPath();
  ctx.moveTo(xPos(pts[0].min), yPos(0));
  for (const p of pts) ctx.lineTo(xPos(p.min), yPos(p.delta));
  ctx.lineTo(xPos(pts[pts.length-1].min), yPos(0));
  ctx.closePath();
  ctx.fillStyle = grad;
  ctx.fill();

  // Draw line
  ctx.beginPath();
  ctx.moveTo(xPos(pts[0].min), yPos(pts[0].delta));
  for (let i = 1; i < pts.length; i++) {
    ctx.lineTo(xPos(pts[i].min), yPos(pts[i].delta));
  }
  ctx.strokeStyle = lastDelta > 0 ? '#4ade80' : lastDelta < 0 ? '#f87171' : '#666';
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.stroke();

  // Dot at current position
  const tipX = xPos(pts[pts.length-1].min);
  const tipY = yPos(pts[pts.length-1].delta);
  ctx.fillStyle = lastDelta > 0 ? '#4ade80' : lastDelta < 0 ? '#f87171' : '#666';
  ctx.beginPath();
  ctx.arc(tipX, tipY, 4, 0, Math.PI * 2);
  ctx.fill();

  // Event icons on the line
  for (const p of state.deltaHistory) {
    if (p.min < winStart || p.min > winEnd) continue;
    if (!p.eventType) continue;
    const icon = p.eventType === 'red' ? '🟥' : p.eventType === 'goal' ? '⚽' : p.eventType === 'yellow' ? '🟨' : null;
    if (!icon) continue;
    ctx.font = '10px serif';
    ctx.textAlign = 'center';
    ctx.fillText(icon, xPos(p.min), yPos(p.delta) - 7);
  }

  // Update emoji tip position
  const emojiEl = document.getElementById('sim-graph-emoji');
  if (emojiEl) {
    emojiEl.textContent = getDeltaEmoji(lastDelta);
    const pct = (tipY / h) * 100;
    emojiEl.style.top = `${Math.max(5, Math.min(85, pct))}%`;
  }
}

function drawResultGraph() {
  const canvas = document.getElementById('result-graph');
  if (!canvas) return;

  // Need enough data points — ensure we have at least start + all history + end
  const finalDelta = Math.round(state.myScore) - Math.round(state.oppScore);
  const rawPts = [
    { min: 0, delta: 0 },
    ...state.deltaHistory,
    { min: 90, delta: finalDelta }
  ];
  if (rawPts.length < 2) return;

  // ── Soft-scale: use signed sqrt to compress large values but keep shape ──
  // This prevents huge deltas from making the chart flat near zero
  function softScale(v) {
    return Math.sign(v) * Math.sqrt(Math.abs(v));
  }

  // Compute scaled points
  const scaledPts = rawPts.map(p => ({ ...p, sv: softScale(p.delta) }));
  const allSv = scaledPts.map(p => p.sv);
  const svMax = Math.max(...allSv.map(Math.abs), 1); // at least 1 to avoid div/0

  // ── Canvas setup ──
  const wrap = canvas.parentElement;
  const wrapW = wrap.getBoundingClientRect().width || wrap.offsetWidth || 320;
  canvas.style.width  = '100%';
  const DPR = window.devicePixelRatio || 1;
  const w = wrapW;
  const h = 160;
  canvas.width  = Math.round(w * DPR);
  canvas.height = Math.round(h * DPR);
  const ctx = canvas.getContext('2d');
  ctx.scale(DPR, DPR);
  ctx.clearRect(0, 0, w, h);

  const PAD_L = 8;
  const PAD_R = 8;
  const PAD_T = 16;
  const PAD_B = 20;
  const plotW = w - PAD_L - PAD_R;
  const plotH = h - PAD_T - PAD_B;

  function xPos(min)  { return PAD_L + (min / 90) * plotW; }
  function yPos(sv)   {
    // Centre is plotH*0.5; positive sv goes up, negative goes down
    return PAD_T + plotH * 0.5 - (sv / svMax) * (plotH * 0.48);
  }

  // ── Zero line ──
  ctx.strokeStyle = '#d4d0c8';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(PAD_L, yPos(0));
  ctx.lineTo(w - PAD_R, yPos(0));
  ctx.stroke();
  ctx.setLineDash([]);

  // ── HT divider ──
  ctx.strokeStyle = '#e8e4dc';
  ctx.lineWidth = 1;
  ctx.setLineDash([2, 4]);
  ctx.beginPath();
  ctx.moveTo(xPos(45), PAD_T);
  ctx.lineTo(xPos(45), h - PAD_B);
  ctx.stroke();
  ctx.setLineDash([]);

  // ── Minute labels ──
  ctx.font = `${8 * 1}px DM Mono, monospace`;
  ctx.fillStyle = '#bbb';
  ctx.textAlign = 'center';
  ctx.fillText("0'",  xPos(0),  h - 4);
  ctx.fillText("HT",  xPos(45), h - 4);
  ctx.fillText("90'", xPos(90), h - 4);

  // ── Smooth catmull-rom spline through all points ──
  function catmullRom(pts) {
    // Returns array of {x,y} interpolated at fine resolution
    const result = [];
    for (let i = 0; i < pts.length - 1; i++) {
      const p0 = pts[Math.max(i - 1, 0)];
      const p1 = pts[i];
      const p2 = pts[i + 1];
      const p3 = pts[Math.min(i + 2, pts.length - 1)];
      const steps = Math.max(8, Math.round((p2.x - p1.x) / 4));
      for (let t = 0; t <= steps; t++) {
        const s = t / steps;
        const s2 = s * s;
        const s3 = s2 * s;
        const x = 0.5 * ((2*p1.x) + (-p0.x+p2.x)*s + (2*p0.x-5*p1.x+4*p2.x-p3.x)*s2 + (-p0.x+3*p1.x-3*p2.x+p3.x)*s3);
        const y = 0.5 * ((2*p1.y) + (-p0.y+p2.y)*s + (2*p0.y-5*p1.y+4*p2.y-p3.y)*s2 + (-p0.y+3*p1.y-3*p2.y+p3.y)*s3);
        result.push({ x, y });
      }
    }
    return result;
  }

  const splinePts = scaledPts.map(p => ({ x: xPos(p.min), y: yPos(p.sv) }));
  const smooth = catmullRom(splinePts);

  const zeroY = yPos(0);

  // ── Segment-split fill: green above zero, red below zero ──
  // We clip the canvas into two halves (above zero / below zero) and fill each colour
  function drawSegmentedFill(colour, clipAbove) {
    ctx.save();
    ctx.beginPath();
    if (clipAbove) {
      // Clip to region above zero line
      ctx.rect(PAD_L, PAD_T, plotW, zeroY - PAD_T);
    } else {
      // Clip to region below zero line
      ctx.rect(PAD_L, zeroY, plotW, (h - PAD_B) - zeroY);
    }
    ctx.clip();

    ctx.beginPath();
    ctx.moveTo(smooth[0].x, zeroY);
    for (const pt of smooth) ctx.lineTo(pt.x, pt.y);
    ctx.lineTo(smooth[smooth.length - 1].x, zeroY);
    ctx.closePath();
    ctx.fillStyle = colour;
    ctx.fill();
    ctx.restore();
  }

  drawSegmentedFill('rgba(34,197,94,0.22)',  true);   // green above zero
  drawSegmentedFill('rgba(239,68,68,0.20)',  false);  // red below zero

  // ── Segment-split line: green above zero, red below zero ──
  function drawSegmentedLine(colour, clipAbove) {
    ctx.save();
    ctx.beginPath();
    if (clipAbove) {
      ctx.rect(PAD_L - 2, PAD_T, plotW + 4, zeroY - PAD_T + 1);
    } else {
      ctx.rect(PAD_L - 2, zeroY - 1, plotW + 4, (h - PAD_B) - zeroY + 2);
    }
    ctx.clip();
    ctx.beginPath();
    ctx.moveTo(smooth[0].x, smooth[0].y);
    for (let i = 1; i < smooth.length; i++) ctx.lineTo(smooth[i].x, smooth[i].y);
    ctx.strokeStyle = colour;
    ctx.lineWidth = 2.5;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();
    ctx.restore();
  }

  drawSegmentedLine('#22c55e', true);   // green above
  drawSegmentedLine('#ef4444', false);  // red below

  // ── Event icons — DOM overlays (canvas emoji unreliable on mobile) ──
  const chartWrap = canvas.parentElement;
  chartWrap.querySelectorAll('.rc-event-icon').forEach(el => el.remove());
  for (const p of scaledPts) {
    if (!p.eventType) continue;
    const icon = p.eventType === 'red' ? '🟥'
               : p.eventType === 'goal' ? '⚽'
               : p.eventType === 'own_goal' ? '🤦'
               : p.eventType === 'yellow' ? '🟨' : null;
    if (!icon) continue;
    const pctX = (xPos(p.min) / w) * 100;
    const pctY = ((yPos(p.sv) - 16) / h) * 100;
    const span = document.createElement('span');
    span.className = 'rc-event-icon';
    span.textContent = icon;
    span.style.cssText = `position:absolute;left:${pctX}%;top:${pctY}%;transform:translateX(-50%);font-size:12px;line-height:1;pointer-events:none;z-index:2;`;
    chartWrap.appendChild(span);
  }

  // ── Emoji at the END of the line (not overlaid on canvas — use DOM element) ──
  const emojiEl = document.getElementById('result-graph-emoji');
  if (emojiEl && smooth.length > 0) {
    const lastPt = smooth[smooth.length - 1];
    const lastPtRaw = splinePts[splinePts.length - 1];
    const pctX = (lastPtRaw.x / w) * 100;
    const pctY = (lastPtRaw.y / h) * 100;
    emojiEl.textContent = getDeltaEmoji(finalDelta);
    emojiEl.style.left = pctX + '%';
    emojiEl.style.top  = pctY + '%';
  }
}

// ═══════════════════════════════════════════════════════════════
// HALFTIME SWAP
// ═══════════════════════════════════════════════════════════════

// ── Build the computer's swap offer ──────────────────────────
function buildHtSwapOffer() {
  const secondHalfEvents = EVENTS.filter(e => e.min > 45 && e.type !== 'full_90' && e.type !== 'assist');
  const weights = { goal: 3, red: 4, own_goal: 3, yellow: 2, missed_pen: 2, sub: 1 };

  // My worst outfield performer in first half (non-captain)
  const myOutfield = state.myTeam.filter(id => {
    const p = getPlayer(id);
    return p && p.pos !== 'GK' && id !== state.myCaptain;
  }).sort((a, b) => (state.playerData[a]?.pts || 0) - (state.playerData[b]?.pts || 0));

  // Opp best projected 2nd-half performer (non-captain), top 25% of their squad
  const oppScored = state.oppTeam
    .filter(id => { const p = getPlayer(id); return p && p.pos !== 'GK' && id !== state.oppCaptain; })
    .map(id => {
      const score = secondHalfEvents.filter(e => e.playerId === id)
        .reduce((s, e) => s + (weights[e.type] || 1), 0);
      return { id, score };
    })
    .sort((a, b) => b.score - a.score);

  // Pick worst from my team, best from opp (with 75% chance it's truly top 25% of opp)
  const outId = myOutfield[0];
  const topQuarter = Math.max(1, Math.ceil(oppScored.length * 0.25));
  const inPool = Math.random() < 0.75 ? oppScored.slice(0, topQuarter) : oppScored;
  const inId = inPool[Math.floor(Math.random() * inPool.length)]?.id;

  return outId && inId ? { outId, inId } : null;
}

function showHtSwapUI(onComplete) {
  state.htSwapOut  = null;
  state.htSwapIn   = null;
  state.htSwapDone = false;

  const announce = document.getElementById('ht-phase-announce');
  const swapPhase = document.getElementById('ht-phase-swap');
  if (announce) announce.style.display = 'none';
  if (swapPhase) swapPhase.style.display = 'flex';

  // Build the offer
  const offer = buildHtSwapOffer();
  state._htOffer = offer;

  if (!offer) {
    // No valid offer possible — skip straight to second half
    finishHtSwap();
    if (onComplete) onComplete();
    return;
  }

  const outPlayer = getPlayer(offer.outId);
  const inPlayer  = getPlayer(offer.inId);
  const outPts    = Math.round(state.playerData[offer.outId]?.pts || 0);
  const inPts     = Math.round(state.playerData[offer.inId]?.pts || 0);

  // Populate offer card
  const outName = document.getElementById('ht-offer-out-name');
  const outPtsEl = document.getElementById('ht-offer-out-pts');
  const inName  = document.getElementById('ht-offer-in-name');
  const inPtsEl = document.getElementById('ht-offer-in-pts');

  if (outName)  outName.textContent  = outPlayer ? outPlayer.name.split(' ').pop() : '?';
  if (outPtsEl) outPtsEl.textContent = `${outPlayer?.pos || ''} · ${outPts >= 0 ? '+' : ''}${outPts} pts this half`;
  if (inName)   inName.textContent   = inPlayer  ? inPlayer.name.split(' ').pop()  : '?';
  if (inPtsEl)  inPtsEl.textContent  = `${inPlayer?.pos || ''} · ${inPts >= 0 ? '+' : ''}${inPts} pts this half`;

  // Tutorial: explain the swap mechanic
  if (_tutorialActive) {
    showTutorialCard('ht_swap', false).then(() => {});
  }

  // 15s timer
  let secs = 15;
  const timerLabel = document.getElementById('ht-timer-label');
  const timerBar   = document.getElementById('ht-timer-bar');
  if (timerLabel) timerLabel.textContent = secs;
  if (timerBar)   timerBar.style.width = '100%';

  state._htTimerSecsRemaining = secs;
  state.htTimerInterval = setInterval(() => {
    secs--;
    state._htTimerSecsRemaining = secs;
    if (timerLabel) timerLabel.textContent = secs;
    if (timerBar)   timerBar.style.width = (secs / 15 * 100) + '%';
    if (secs <= 0) {
      clearInterval(state.htTimerInterval);
      if (!state.htSwapDone) declineHtSwap(); // timer = auto-decline
    }
  }, 1000);

  state._htSwapCallback = onComplete;
}

function acceptHtSwap() {
  if (state.htSwapDone) return;
  clearInterval(state.htTimerInterval);
  state.htSwapDone = true;

  const offer = state._htOffer;
  if (!offer) { finishHtSwap(); return; }

  // Immediate −5 cost
  state.myScore -= 5;
  updateScoreDisplay();
  showToast('🔄 Swap accepted · −5 pts');

  if (state.mp) {
    mpWriteHtSwap(offer.outId, offer.inId);
  } else {
    applyHtSwap(offer.outId, offer.inId, true);
  }
}

function declineHtSwap() {
  if (state.htSwapDone) return;
  clearInterval(state.htTimerInterval);
  state.htSwapDone = true;
  // In MP: write a "no swap" signal so the other player knows we're ready
  if (state.mp) {
    mpWriteHtSwap(null, null); // null = declined
  } else {
    finishHtSwap();
  }
}

// Keep skipHtSwap as alias for backward compat (tutorial etc.)
function skipHtSwap() { declineHtSwap(); }
function autoCompleteHtSwap() { declineHtSwap(); }

function applyHtSwap(outId, inId, isMe) {
  if (!outId || !inId) { finishHtSwap(); return; } // declined
  if (isMe) {
    state.myTeam  = state.myTeam.filter(id => id !== outId);
    state.myTeam.push(inId);
    state.oppTeam = state.oppTeam.filter(id => id !== inId);
    state.oppTeam.push(outId);
  }
  if (!state.playerData[inId])  state.playerData[inId]  = { pts: 0, events: [] };
  if (!state.playerData[outId]) state.playerData[outId] = { pts: 0, events: [] };
  if (isMe) {
    state.playerData[inId].htSubIn   = true;
    state.playerData[outId].htSubOut = true;
  }
  finishHtSwap();
}

function finishHtSwap() {
  const htOverlay = document.getElementById('ht-overlay');
  const swapPhase = document.getElementById('ht-phase-swap');
  if (swapPhase) swapPhase.style.display = 'none';

  const announce = document.getElementById('ht-phase-announce');
  if (announce) {
    announce.style.display = 'flex';
    const sub = document.getElementById('ht-announce-sub');
    if (sub) sub.textContent = 'Second half kicks off shortly…';
  }

  if (state._htSwapCallback) {
    const cb = state._htSwapCallback;
    state._htSwapCallback = null;
    setTimeout(() => {
      if (htOverlay) htOverlay.style.display = 'none';
      cb();
    }, 1800);
  }
}

// ── Multiplayer halftime swap sync ────────────────────────────
async function mpWriteHtSwap(outId, inId) {
  const mp = state.mp;
  if (!mp) return;
  const field = mp.role === 'A' ? 'htSwapA' : 'htSwapB';
  // Write decision (null/null = declined)
  await window._fb.update(mp.sessionRef, {
    [field]: { outId: outId || null, inId: inId || null, lockedAt: Date.now() }
  });
  // Apply my own swap immediately (or skip if declined)
  applyHtSwap(outId, inId, true);
}

function mpListenForHtSwap() {
  const mp = state.mp;
  if (!mp) return;
  const oppField    = mp.role === 'A' ? 'htSwapB' : 'htSwapA';
  const myField     = mp.role === 'A' ? 'htSwapA' : 'htSwapB';

  // Listen for opponent's decision — store it so we can show the notification
  // at start of second half
  window._fb.onValue(window._fb.ref('sessions/' + mp.code + '/' + oppField), (snap) => {
    const d = snap.val();
    if (!d) return;
    // Save opp swap info for the second-half notification
    state._oppHtSwap = d; // { outId, inId } or { outId: null, inId: null }
  });
}

// Called at start of 2nd half — shows notification if opp made a swap
function showOppSwapNotification() {
  const d = state._oppHtSwap;
  if (!d || !d.outId || !d.inId) return; // opp declined or no data
  const outP = getPlayer(d.outId);
  const inP  = getPlayer(d.inId);
  if (!outP || !inP) return;
  const outName = outP.name.split(' ').pop();
  const inName  = inP.name.split(' ').pop();
  showToast(`Opponent swapped ${outName} → ${inName}`);
  setCommentary(`Opponent made a swap: <strong>${outName}</strong> out, <strong>${inName}</strong> in.`, '🔄');
}


// ── Helpers ──────────────────────────────────────────────────
function genCode() {
  // 4-char alphanumeric code, easy to type on mobile
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // no I/O/1/0
  let code = '';
  for (let i = 0; i < 4; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

function getPlayerId() {
  // Persistent anonymous ID stored in localStorage
  let id = localStorage.getItem('worst-eleven-pid');
  if (!id) { id = 'p_' + Date.now() + '_' + Math.random().toString(36).slice(2, 7); localStorage.setItem('worst-eleven-pid', id); }
  return id;
}

function fbReady() {
  return window._fbReady && window._fb;
}

function showLobbyError(msg) {
  const el = document.getElementById('lobby-error');
  if (el) { el.textContent = msg; el.style.display = ''; }
}

function hideLobbyError() {
  const el = document.getElementById('lobby-error');
  if (el) el.style.display = 'none';
}

function showLobbyPhase(phase) {
  ['choose','waiting','joined'].forEach(p => {
    const el = document.getElementById('lobby-phase-' + p);
    if (el) el.style.display = p === phase ? 'flex' : 'none';
  });
}

// ── Entry points ──────────────────────────────────────────────
function openLobby() {
  if (!fbReady()) { showToast('Multiplayer not available — Firebase not configured'); return; }
  showLobbyPhase('choose');
  hideLobbyError();
  showScreen('lobby');
}

function leaveLobby() {
  mpCleanup();
  state.mp = null;
  showScreen('home');
}

// ── Create game (Player A / Host) ─────────────────────────────
async function createGame() {
  if (!fbReady()) return;
  const profile = getActiveProfile();
  if (!profile) return;

  let code, snap, attempts = 0;
  do {
    code = genCode();
    snap = await window._fb.get(window._fb.ref('sessions/' + code));
    attempts++;
  } while (snap.exists() && attempts < 10);

  if (snap.exists()) { showLobbyError('Could not create a game — try again'); return; }

  const pid = getPlayerId();

  // Pick the match now so both players get the same one
  let matchIdx;
  do { matchIdx = Math.floor(Math.random() * ALL_MATCHES.length); }
  while (ALL_MATCHES.length > 1 && matchIdx === state.matchIdx);

  const session = {
    status:    'waiting',
    matchIdx,
    createdAt: Date.now(),
    playerA: { id: pid, name: profile.name, emoji: profile.emoji, ready: true },
    playerB: null,
    picks:    [],
    captainA: null,
    captainB: null,
    simStartTimestamp: null,
    scoreA: null,
    scoreB: null,
  };

  await window._fb.set(window._fb.ref('sessions/' + code), session);

  state.mp = {
    code,
    role:       'A',
    playerId:   pid,
    sessionRef: window._fb.ref('sessions/' + code),
  };

  // Update UI
  document.getElementById('lobby-code-display').textContent = code;
  document.getElementById('lobby-name-a').textContent = profile.emoji + ' ' + profile.name;
  showLobbyPhase('waiting');

  // Single listener handles both: B joining UI update + auto-start
  let bJoined = false;
  window._fb.onValue(state.mp.sessionRef, async (snap) => {
    const data = snap.val();
    if (!data) return;

    // Update UI when B appears
    if (data.playerB && !bJoined) {
      bJoined = true;
      const nameEl = document.getElementById('lobby-name-b');
      if (nameEl) nameEl.textContent = data.playerB.emoji + ' ' + data.playerB.name;
      const dot = document.querySelector('#lobby-phase-waiting .lobby-player-row:last-child .lobby-player-dot');
      if (dot) { dot.classList.remove('waiting'); dot.classList.add('ready'); }
      const tag = document.querySelector('#lobby-phase-waiting .lobby-player-row:last-child');
      if (tag && !tag.querySelector('.lobby-ready-tag')) {
        const t = document.createElement('span'); t.className = 'lobby-ready-tag'; t.textContent = 'Ready';
        tag.appendChild(t);
      }
      // Auto-start after brief pause for UI
      await new Promise(r => setTimeout(r, 1200));
      await window._fb.update(window._fb.ref('sessions/' + code), { status: 'drafting' });
    }

    if (data.status === 'drafting') {
      mpStartDraft(data); // internally calls mpCleanup() first
    }
  });
}

// ── Join game (Player B / Guest) ──────────────────────────────
async function joinGame() {
  if (!fbReady()) return;
  const code = (document.getElementById('join-code-input').value || '').trim().toUpperCase();
  if (code.length !== 4) { showLobbyError('Enter a 4-letter code'); return; }

  const profile = getActiveProfile();
  if (!profile) return;

  const pid = getPlayerId();
  hideLobbyError();

  const sessionRef = window._fb.ref('sessions/' + code);
  const snap = await window._fb.get(sessionRef);

  if (!snap.exists()) { showLobbyError('Game not found — check the code'); return; }
  const data = snap.val();
  if (data.status !== 'waiting') { showLobbyError('Game already started'); return; }
  if (data.playerB) { showLobbyError('Game is full'); return; }
  if (data.playerA.id === pid) { showLobbyError("That's your own game — share the code with a friend"); return; }

  await window._fb.update(sessionRef, {
    playerB: { id: pid, name: profile.name, emoji: profile.emoji, ready: true }
  });

  state.mp = {
    code,
    role:       'B',
    playerId:   pid,
    sessionRef,
  };

  // Update UI
  document.getElementById('lobby-joined-name-a').textContent = data.playerA.emoji + ' ' + data.playerA.name;
  document.getElementById('lobby-joined-name-b').textContent = profile.emoji + ' ' + profile.name;
  showLobbyPhase('joined');

  // Listen for game to start
  window._fb.onValue(sessionRef, (snap) => {
    const d = snap.val();
    if (!d) return;
    if (d.status === 'drafting') mpStartDraft(d);
  });
}

// ══════════════════════════════════════════════════════════════
// MULTIPLAYER DRAFT  — complete rewrite for correct turn flow
// ══════════════════════════════════════════════════════════════

// ── Kick off the multiplayer draft ────────────────────────────
function mpStartDraft(sessionData) {
  // Guard against double-fire from the Firebase listener
  if (state.mp && state.mp._draftStarted) return;

  // Kill ALL lobby listeners before entering draft phase
  mpCleanup();

  const mp = state.mp;
  if (!mp) return;
  mp._draftStarted = true;
  mp.matchIdx = sessionData.matchIdx;
  mp.playerA  = sessionData.playerA;   // { name, emoji }
  mp.playerB  = sessionData.playerB;

  // Derive opponent display name (used throughout UI)
  mp.oppName = mp.role === 'A'
    ? (mp.playerB.emoji + ' ' + mp.playerB.name)
    : (mp.playerA.emoji + ' ' + mp.playerA.name);

  // Profile
  const profile = getActiveProfile();
  state.teamName  = profile.emoji + ' ' + profile.name;
  state.teamEmoji = profile.emoji;

  // Load the shared match
  loadMatch(mp.matchIdx);
  state.matchIdx = mp.matchIdx;

  // ── Step 1: Show the VHS loading reel (same as single-player) ──
  showScreen('coin');
  showCoinPhase('loading');

  let t = 0;
  const linesEl = document.getElementById('coin-loading-lines');
  const lineInterval = setInterval(() => {
    if (linesEl) linesEl.textContent = REEL_LINES[t % REEL_LINES.length];
    t++;
  }, 220);

  // ── Step 2: After reel, sync coin countdown via Firebase timestamp ──
  setTimeout(async () => {
    clearInterval(lineInterval);
    const m = ALL_MATCHES[mp.matchIdx];

    // Show the match reveal panel (no countdown starts inside revealMatch for mp)
    revealMatch(m);

    // HOST writes the coinFlipStart timestamp so both clients sync to same moment
    let coinFlipStart;
    if (mp.role === 'A') {
      coinFlipStart = Date.now();
      await window._fb.update(mp.sessionRef, { coinFlipStart });
    } else {
      // Guest: wait for host to write the timestamp (near-instant over LAN/mobile)
      coinFlipStart = await new Promise(resolve => {
        window._fb.onValue(mp.sessionRef, function readStart(snap) {
          const d = snap.val();
          if (d && d.coinFlipStart) {
            mpCleanup(); // detach this one-shot listener
            resolve(d.coinFlipStart);
          }
        });
      });
    }

    // Both clients start their countdown bar from the SAME wall-clock moment
    startCoinCountdown(coinFlipStart);

    // HOST: runCoinFlip() calls _mpCoinDone after its 10s + animation
    if (mp.role === 'A') {
      window._mpCoinDone = async (playerAWins) => {
        const gkWinner = playerAWins ? 'A' : 'B';
        await window._fb.update(mp.sessionRef, { gkWinner });
        // Host already saw the result in runCoinFlip — go to draft
        _mpEnterDraft(mp, gkWinner);
      };
    }

    // GUEST: watch Firebase for the spin animation start + result
    if (mp.role === 'B') {
      let animStarted = false;
      window._fb.onValue(mp.sessionRef, (snap) => {
        const d = snap.val();
        if (!d) return;

        // When host starts spinning, guest starts their spin in sync
        if (d.coinFlipAnimStart && !animStarted) {
          animStarted = true;
          // Show flip phase on guest screen immediately
          showCoinPhase('flip');
          const coin = document.getElementById('coin');
          const status = document.getElementById('coin-status');
          const sub = document.getElementById('coin-sub');
          if (coin) { coin.textContent = '🪙'; coin.style.transform = ''; }
          if (status) status.textContent = '';
          if (sub) sub.textContent = '';

          // Run the same spin animation (~1.2s for 10 flips at 120ms)
          let flips = 0;
          const faces = ['🪙', '⚽'];
          const guestSpin = setInterval(() => {
            if (coin) {
              coin.textContent = faces[flips % 2];
              coin.style.transform = `rotateY(${flips * 180}deg) scale(${flips % 2 === 0 ? 1 : 0.85})`;
            }
            flips++;
            if (flips > 10) {
              clearInterval(guestSpin);
              if (coin) { coin.style.transform = ''; coin.textContent = '🪙'; }
              // Keep showing spinning coin until gkWinner arrives
            }
          }, 120);
        }

        // When result arrives, show it then go to draft
        if (d.gkWinner) {
          mpCleanup();
          const iWinGK = (mp.role === d.gkWinner);
          const coin = document.getElementById('coin');
          const status = document.getElementById('coin-status');
          const sub = document.getElementById('coin-sub');
          if (coin) { coin.style.transform = ''; coin.textContent = iWinGK ? '✅' : '❌'; }
          if (status) status.textContent = iWinGK ? 'YOU WIN' : 'OPPONENT WINS';
          if (sub) sub.textContent = iWinGK
            ? 'You pick the goalkeeper first'
            : mp.oppName + ' picks the goalkeeper first';
          setTimeout(() => _mpEnterDraft(mp, d.gkWinner), 2500);
        }
      });
    }
  }, 1500);
}

// ── Show coin flip result for EITHER player, then call onDone ──
function _mpShowCoinResult(mp, gkWinner, onDone) {
  showCoinPhase('flip');
  const coin   = document.getElementById('coin');
  const status = document.getElementById('coin-status');
  const sub    = document.getElementById('coin-sub');
  const iWinGK = (mp.role === gkWinner);

  if (coin) coin.textContent = '🪙';
  if (status) status.textContent = '';
  if (sub) sub.textContent = '';

  let flips = 0;
  const faces = ['🪙', '⚽'];
  const spinInterval = setInterval(() => {
    if (coin) {
      coin.textContent = faces[flips % 2];
      coin.style.transform = `rotateY(${flips * 180}deg) scale(${flips % 2 === 0 ? 1 : 0.85})`;
    }
    flips++;
    if (flips > 10) {
      clearInterval(spinInterval);
      if (coin) {
        coin.style.transform = '';
        coin.textContent = iWinGK ? '✅' : '❌';
      }
      if (status) status.textContent = iWinGK ? 'YOU WIN' : 'OPPONENT WINS';
      if (sub) sub.textContent = iWinGK
        ? 'You pick the goalkeeper first'
        : mp.oppName + ' picks the goalkeeper first';
      // 2.5s to read result, then call onDone
      setTimeout(onDone, 2500);
    }
  }, 120);
}

// ── Enter the draft screen and wire up Firebase sync ──────────
function _mpEnterDraft(mp, gkWinner) {
  // gkWinner = 'A' or 'B' (absolute role)
  const iWinGK = (mp.role === gkWinner);

  showScreen('draft');

  // Reset draft state completely
  state.myTeam         = [];
  state.oppTeam        = [];
  state.currentPick    = 0;
  state.selectedPlayer = null;
  state.teamFilter     = 'home';
  clearInterval(state.timerInterval);
  state.timerInterval  = null;

  // Build sequence from MY perspective: did I win the GK toss?
  state.sequence = buildDraftSequence(iWinGK ? 'me' : 'opp');

  initPlayerData();

  // Label my zone and opponent zone
  const myLabel = document.getElementById('my-zone-label');
  if (myLabel) {
    const name = state.teamName || 'Your XI';
    myLabel.innerHTML = '<span class="dot yours"></span> ' + name;
  }
  const oppLabel = document.getElementById('opp-zone-label');
  if (oppLabel) {
    oppLabel.innerHTML = '<span class="dot opponent"></span> ' + mp.oppName + "'s XI";
  }

  renderDraftSlots();
  renderCarousel();
  updateTurnUI();

  showToast('🔴 LIVE — playing vs ' + mp.oppName);

  // ── Firebase picks listener — THE single source of truth ──
  // All timer start/stop, UI updates and turn-gating happen here.
  // We use a short delay so state is fully initialised before the
  // first onValue fires (which happens immediately on attach).
  setTimeout(() => {
    const picksRef = window._fb.ref('sessions/' + mp.code + '/picks');
    window._fb.onValue(picksRef, (snap) => {
      const picks = snap.val() || [];
      _mpSyncPicks(mp, picks);
    });
  }, 100);
}

// ── Rebuild state from the canonical Firebase picks array ─────
// Called on every Firebase update (including my own writes).
// This is the ONLY function that starts timers in multiplayer.
function _mpSyncPicks(mp, picks) {
  const seq = state.sequence;
  if (!seq || seq.length === 0) return;

  // ── Rebuild teams ──
  const newMy  = [];
  const newOpp = [];

  for (let i = 0; i < picks.length; i++) {
    const pick = picks[i];
    const step = seq[i];
    if (!step || !pick) continue;

    if (step.type === 'gk') {
      // teamA / teamB are absolute player IDs
      if (pick.teamA !== undefined) {
        newMy.push( mp.role === 'A' ? pick.teamA : pick.teamB);
        newOpp.push(mp.role === 'A' ? pick.teamB : pick.teamA);
      }
    } else if (step.type === 'sabotage') {
      // Sabotage pick goes into the OPPONENT of whoever made it
      if (_mpIsMine(step)) newOpp.push(pick.playerId);
      else                 newMy.push(pick.playerId);
    } else {
      // Normal pick goes to the picker
      if (_mpIsMine(step)) newMy.push(pick.playerId);
      else                 newOpp.push(pick.playerId);
    }
  }

  state.myTeam      = newMy;
  state.oppTeam     = newOpp;
  state.currentPick = picks.length;

  // ── Always stop running timer before deciding what to do next ──
  clearInterval(state.timerInterval);
  state.timerInterval = null;

  renderDraftSlots();
  renderCarousel();
  updateTurnUI();

  // ── Draft complete? ──
  if (picks.length >= seq.length) {
    mpDraftComplete();
    return;
  }

  // ── Start timer only if it is MY turn next ──
  const nextStep = seq[picks.length];
  if (nextStep && _mpIsMine(nextStep)) {
    // Check if there's only 1 player available — auto-pick immediately
    const drafted = [...state.myTeam, ...state.oppTeam];
    const available = PLAYERS.filter(p => {
      if (drafted.includes(p.id)) return false;
      if (nextStep.type === 'gk') return p.pos === 'GK';
      return true;
    });
    if (available.length === 1) {
      // Only one option — auto-assign after brief delay
      setTimeout(() => {
        state.selectedPlayer = available[0].id;
        window.draftPlayer();
      }, 600);
    } else {
      const dur = nextStep.type === 'gk' ? 10 : undefined;
      startTimer(dur);
    }
  }
  // If it is NOT my turn: no timer. We just sit and wait for the
  // opponent's Firebase write which will re-trigger this function.
}

// Helper: is this sequence step mine (accounts for A/B role)?
// 'me' in the sequence always means the GK-toss winner; 'opp' = loser.
// We re-map to absolute roles via the sequence itself — the sequence
// was built with iWinGK already applied, so 'me' literally means me.
function _mpIsMine(step) {
  if (!step) return false;
  if (!state.mp) return step.who === 'me'; // single-player fallback
  // sequence 'me' = the player on THIS device; 'opp' = the other player
  // (This is correct because _mpEnterDraft builds the sequence with
  //  buildDraftSequence(iWinGK ? 'me' : 'opp') from MY perspective)
  return step.who === 'me';
}

// ── Write a pick to Firebase ───────────────────────────────────
async function mpDraftPlayer() {
  const mp   = state.mp;
  const step = currentStep();
  if (!step || !_mpIsMine(step)) {
    if (step) showToast("Not your turn!");
    return;
  }
  if (!state.selectedPlayer) { showToast('Select a player first!'); return; }

  const drafted = [...state.myTeam, ...state.oppTeam];
  if (drafted.includes(state.selectedPlayer)) {
    state.selectedPlayer = null;
    renderCarousel();
    return;
  }

  if (step.type === 'gk') {
    const p = getPlayer(state.selectedPlayer);
    if (!p || p.pos !== 'GK') { showToast('Pick a goalkeeper!'); return; }
  }

  // Kill timer immediately to prevent double-fire
  clearInterval(state.timerInterval);
  state.timerInterval = null;

  // Snapshot to guard against race conditions
  const picksRef   = window._fb.ref('sessions/' + mp.code + '/picks');
  const snapNow    = await window._fb.get(picksRef);
  const picksSoFar = snapNow.val() || [];

  if (picksSoFar.length !== state.currentPick) {
    // Another pick landed while we were awaiting — abort
    return;
  }

  let entry;
  if (step.type === 'gk') {
    // GK step: write BOTH keepers so both clients can read theirs
    const otherGK = PLAYERS.find(q => q.pos === 'GK' && q.id !== state.selectedPlayer);
    if (!otherGK) return;
    // 'me' built the sequence as GK winner = me, so:
    //   if I am Player A → I am teamA; if I am Player B → I am teamB
    entry = {
      teamA: mp.role === 'A' ? state.selectedPlayer : otherGK.id,
      teamB: mp.role === 'A' ? otherGK.id : state.selectedPlayer,
    };
  } else {
    entry = { playerId: state.selectedPlayer };
  }

  state.selectedPlayer = null;

  // Write — the onValue listener on BOTH clients will call _mpSyncPicks
  // which handles all subsequent UI and timer updates.
  await window._fb.update(window._fb.ref('sessions/' + mp.code), {
    picks: [...picksSoFar, entry],
  });
}

// ── Draft complete ─────────────────────────────────────────────
function mpDraftComplete() {
  clearInterval(state.timerInterval);
  if (state.myTeam.length < 11 || state.oppTeam.length < 11) return;
  setTimeout(() => showCaptainScreen(), 600);
}

// ── Captain + sim sync — single merged function ──────────────
// Writes captain, signals ready, waits for both players + shared timestamp.
// Uses ONE listener so nothing can interfere with or kill another.
async function mpConfirmCaptainAndSim(captainId) {
  const mp = state.mp;
  if (!mp) { startSimulation(); return; }

  const myCapField  = mp.role === 'A' ? 'captainA'  : 'captainB';
  const oppCapField = mp.role === 'A' ? 'captainB'  : 'captainA';
  const myReadyField= mp.role === 'A' ? 'simReadyA' : 'simReadyB';

  // Write our captain + ready flag atomically
  await window._fb.update(mp.sessionRef, {
    [myCapField]:   captainId,
    [myReadyField]: true,
  });

  // ONE listener that handles everything remaining
  let simFired = false;
  window._fb.onValue(mp.sessionRef, async (snap) => {
    const d = snap.val();
    if (!d || simFired) return;

    // Grab opponent captain whenever it arrives
    if (d[oppCapField]) state.oppCaptain = d[oppCapField];

    // Player A: once both ready, write the shared start timestamp
    if (mp.role === 'A' && d.simReadyA && d.simReadyB && !d.simStartTimestamp) {
      await window._fb.update(mp.sessionRef, {
        simStartTimestamp: Date.now(),
        status: 'simulating',
      });
      return; // listener will fire again with the timestamp
    }

    // Both players: once timestamp exists, start sim
    // (oppCaptain may arrive slightly after timestamp - use whatever we have)
    if (d.simStartTimestamp) {
      // Grab opp captain if available
      if (d[oppCapField]) state.oppCaptain = d[oppCapField];
      // If opp captain still not set, pick a fallback from their team
      if (!state.oppCaptain && state.oppTeam.length > 0) {
        const outfield = state.oppTeam.filter(id => { const p = getPlayer ? getPlayer(id) : null; return p && p.pos !== 'GK'; });
        state.oppCaptain = outfield[0] || state.oppTeam[0];
      }
      simFired = true;
      mpCleanup();
      const delay = Math.max(0, d.simStartTimestamp + 500 - Date.now());
      setTimeout(() => startSimulation(), delay);
    }
  });
}

// Legacy stubs kept so nothing else breaks if called
function mpSetCaptain(id)          { /* merged into mpConfirmCaptainAndSim */ }
function mpReadyToSim()            { /* merged into mpConfirmCaptainAndSim */ }
function mpWaitForSimStart(cb)     { /* merged into mpConfirmCaptainAndSim */ }

// ── Multiplayer scorer question ───────────────────────────────
// Both clients see the question (sim is time-synced).
// Each player writes their answer to Firebase with a local timestamp.
// First answer wins; tie window = 300ms; both get their result regardless.
function mpShowScorerQuestion(beat, onComplete) {
  const mp = state.mp;
  if (!mp) { showScorerQuestion(beat, onComplete); return; }

  const questionId  = 'sq_' + beat.matchMin + '_' + (beat.scorerEventType || 'g');
  const myField     = mp.role === 'A' ? 'sqAnswerA' : 'sqAnswerB';
  const oppField    = mp.role === 'A' ? 'sqAnswerB' : 'sqAnswerA';
  const questionRef = window._fb.ref('sessions/' + mp.code + '/scorerQ/' + questionId);

  // Clear any previous answer for this question
  window._fb.update(questionRef, { [myField]: null });

  let myAnsweredAt  = null;
  let myCorrect     = null;
  let resolved      = false;

  function resolveQuestion(myAns, oppAns) {
    if (resolved) return;
    resolved = true;
    mpCleanup(); // detach the watcher

    // Determine outcome
    const { correctId } = beat.scorerOptions;
    const myRight  = myAns  !== null && myAns  !== undefined && myAns.playerId  === correctId;
    const oppRight = oppAns !== null && oppAns !== undefined && oppAns.playerId === correctId;

    // Tie check: both answered within 300ms
    const tie = myAns && oppAns &&
      Math.abs((myAns.ts || 0) - (oppAns.ts || 0)) < 300;

    // Apply score — in a tie both get their result
    // In a race, first answerer wins (already applied locally); second gets nothing
    // Apply events now (scores, tiles) before revealing answer
    if (beat._applyEvents) { beat._applyEvents(); beat._applyEvents = null; }

    if (!myAns) {
      // didn't answer
      submitScorerAnswer(null, correctId, onComplete);
      return;
    }
    if (tie || !oppAns) {
      // Tie or opponent didn't answer — apply normally
      submitScorerAnswer(myRight, correctId, onComplete);
    } else {
      // Race: did I win?
      if (myAns.ts <= oppAns.ts) {
        submitScorerAnswer(myRight, correctId, onComplete);
      } else {
        // I was slower — no points either way
        submitScorerAnswer(null, correctId, onComplete, '⚡ Opponent answered first!');
      }
    }
  }

  // Watch for both answers
  window._fb.onValue(questionRef, (snap) => {
    const d = snap.val() || {};
    const myAns  = d[myField]  || null;
    const oppAns = d[oppField] || null;

    // If both answered, resolve immediately
    if (myAns && oppAns) {
      resolveQuestion(myAns, oppAns);
      return;
    }

    // If only opponent answered and I haven't, start a 1.5s window for me to still answer
    if (oppAns && !myAns && !myAnsweredAt) {
      setTimeout(() => {
        if (!resolved && !myAnsweredAt) resolveQuestion(null, oppAns);
      }, 1500);
    }
  });

  // Auto-resolve after 6s (1s grace beyond the 5s UI timer)
  const autoResolve = setTimeout(() => {
    window._fb.get(questionRef).then(snap => {
      if (!resolved) {
        const d = snap.val() || {};
        resolveQuestion(d[myField] || null, d[oppField] || null);
      }
    });
  }, 6000);

  // Show the question UI — on answer, write to Firebase
  showScorerQuestion(beat, (isCorrect, playerId) => {
    // This callback fires when the player taps a button (before resolveQuestion)
    if (resolved) return;
    myAnsweredAt = Date.now();
    myCorrect    = isCorrect;
    window._fb.update(questionRef, {
      [myField]: { playerId, ts: myAnsweredAt, correct: isCorrect }
    });
    // Don't call onComplete here — wait for resolveQuestion
  });
}

// Write final score to Firebase so both clients can see the result
async function mpWriteScore(score) {
  const mp = state.mp;
  if (!mp) return;
  const field = mp.role === 'A' ? 'scoreA' : 'scoreB';
  const rounded = Math.round(score);
  const scoreTs = Date.now(); // timestamp so we can detect stale cached reads
  // Retry up to 3 times in case of network hiccup
  for (let attempt = 0; attempt < 3; attempt++) {
    try {
      await window._fb.update(mp.sessionRef, { [field]: rounded, [field + 'Ts']: scoreTs, status: 'done' });
      return; // success
    } catch(e) {
      console.warn('mpWriteScore attempt', attempt + 1, 'failed:', e);
      if (attempt < 2) await new Promise(r => setTimeout(r, 1000));
    }
  }
  console.error('mpWriteScore failed after 3 attempts - using local fallback');
}

// ── Override draftPlayer in mp mode ──────────────────────────
const _origDraftPlayer = draftPlayer;
const _origAfterPick   = afterPick;

// Patch draftPlayer to route through Firebase in mp mode
window.draftPlayer = function() {
  if (state.mp) { mpDraftPlayer(); }
  else { _origDraftPlayer(); }
};


// ═══════════════════════════════════════════════════════════════
// TUTORIAL SYSTEM
// Fixed match: Newcastle 4-4 Arsenal, Feb 2011
// 10 explainer moments, each dismissible immediately
// ═══════════════════════════════════════════════════════════════

let _tutorialActive  = false;
let _tutorialStep    = 0;
let _tutorialResolve = null; // promise resolver — advances game when dismissed

// Tutorial match index — find Newcastle 4-4 Arsenal in ALL_MATCHES
function getTutorialMatchIdx() {
  return ALL_MATCHES.findIndex(m => m.id === 'new_4-4_ars_2011');
}

// The 10 explainer moments
const TUTORIAL_STEPS = {
  coin_toss: {
    emoji: '🪙',
    title: 'Coin toss — pick your goalkeeper',
    body: `You're picking first. Choose the goalkeeper you think will have the <strong>worst game</strong> — the one most likely to let goals in.<br><br>Remember: bad is good here. Chaos = points.`,
    btn: `Got it — pick my keeper`,
  },
  gk_forced: {
    emoji: '😬',
    title: 'Opponent gets the other keeper',
    body: `The goalkeeper you didn't pick goes straight to your opponent's squad. <strong>No choice for them.</strong><br><br>Pick wisely — send yourself the disaster, not them.`,
    btn: `Understood`,
  },
  sabotage: {
    emoji: '😈',
    title: 'Sabotage round — send them your best',
    body: `Your next 3 picks go to your <strong>opponent's squad</strong>, not yours.<br><br>This is your chance to load them with players who are going to score, assist, and behave themselves. The worst thing you can do to an opponent is give them a hatful of stars.`,
    btn: `Let the sabotage begin`,
  },
  your_picks: {
    emoji: '📋',
    title: 'Now build your disaster XI',
    body: `These picks go into <strong>your squad</strong>. You want the worst performers from this game — the ones who got carded, subbed off early, or just had a nightmare.<br><br>Who do you remember stinking the place out?`,
    btn: `Start picking`,
  },
  captain: {
    emoji: '🎖️',
    title: 'Pick your captain — double points',
    body: `Your captain earns <strong>double points</strong> for everything they do.<br><br>Don't pick your best player. Pick the liability. The one most likely to get a red card, an own goal, or get hooked at half time. That's your captain.`,
    btn: `Choose my liability`,
  },
  first_card: {
    emoji: '🟨',
    title: 'Card! Your score goes UP',
    body: `A yellow card just earned you <strong>chaos points</strong>. Check the top of the screen — your score went green.<br><br>Cards, red cards, own goals, getting subbed off — that's all money in the bank. The worse they behave, the better for you.`,
    btn: `Love to see it`,
  },
  first_goal: {
    emoji: '⚽',
    title: 'Goal. Your score goes DOWN',
    body: `A goal just <strong>cost you points</strong>. Good players scoring is your enemy — it means you drafted someone too competent.<br><br>This is the whole game. Disasters = good. Goals = bad. Keep that inverted logic in your head.`,
    btn: `Pain understood`,
  },
  question: {
    emoji: '🧠',
    title: 'Quick question — chaos points up for grabs',
    body: `Answer before time runs out.<br><br><strong>✅ Correct = +10 pts · ❌ Wrong = −5 pts · Skip = 0 pts</strong><br><br>If you're not sure, skip it — there's no shame in dodging the penalty.`,
    btn: `Let me answer`,
  },
  ht_swap: {
    emoji: '🔄',
    title: 'Half time — swap offer',
    body: `The manager has spotted an opportunity. He wants to drop your <strong>worst performer</strong> and bring in someone from the other team who could cause chaos in the second half.<br><br><strong>Accept</strong> the swap for <strong>−5 pts</strong> upfront — worth it if the new player delivers. <strong>Decline</strong> and keep your squad as is, no cost.`,
    btn: `Got it`,
  },
  post_match: {
    emoji: '🏆',
    title: 'The result is in',
    body: `<strong>Green box</strong> (Chaos King) = top scorer — someone who really delivered the disasters.<br><strong>Red box</strong> (Annoyingly Decent) = the player who behaved too well and cost you points.<br><br>That's Worst Eleven. Now challenge a friend and let the chaos begin.`,
    btn: `Play for real 🔥`,
  },
};

// Show a tutorial card. Returns a promise that resolves when dismissed.
function _pauseAllTimers() {
  // Pause draft timer
  if (state.timerInterval) {
    clearInterval(state.timerInterval);
    _pausedTimerSecs = state.timerSecs;
    _timerWasPaused = true;
  }
  // Pause captain timer
  if (captainTimerInterval) {
    clearInterval(captainTimerInterval);
    _captainTimerPaused = true;
  }
  // Pause HT swap timer
  if (state.htTimerInterval) {
    clearInterval(state.htTimerInterval);
    _htTimerPaused = true;
  }
}

function _resumeAllTimers() {
  if (_timerWasPaused) {
    _timerWasPaused = false;
    state.timerSecs = _pausedTimerSecs || state.timerSecs;
    // Re-start interval from remaining secs
    state.timerInterval = setInterval(() => {
      state.timerSecs--;
      updateTimerDisplay();
      if (state.timerSecs <= 0) {
        clearInterval(state.timerInterval);
        state.timerInterval = null;
        const step = currentStep();
        const isMyTurn = mp_isMyStep(step);
        if (step && isMyTurn) {
          const drafted = [...state.myTeam, ...state.oppTeam];
          const available = PLAYERS.filter(p => {
            if (drafted.includes(p.id)) return false;
            if (step.type === 'gk') return p.pos === 'GK';
            return true;
          });
          if (available.length > 0) {
            const sorted = [...available].sort((a, b) => (CHAOS_VALUES[b.id] || 0) - (CHAOS_VALUES[a.id] || 0));
            state.selectedPlayer = sorted[0].id;
            window.draftPlayer();
          }
        }
      }
    }, 1000);
  }
  if (_captainTimerPaused) {
    _captainTimerPaused = false;
    // Only restart captain timer if we're actually on the captain screen
    if (document.getElementById('screen-captain')?.classList.contains('active')) {
      startCaptainTimer();
    }
  }
  if (_htTimerPaused && state._htTimerSecsRemaining > 0) {
    _htTimerPaused = false;
    const remaining = state._htTimerSecsRemaining;
    const timerLabel = document.getElementById('ht-timer-label');
    const timerBar   = document.getElementById('ht-timer-bar');
    state.htTimerInterval = setInterval(() => {
      state._htTimerSecsRemaining--;
      if (timerLabel) timerLabel.textContent = state._htTimerSecsRemaining;
      if (timerBar)   timerBar.style.width = (state._htTimerSecsRemaining / 20 * 100) + '%';
      if (state._htTimerSecsRemaining <= 0) {
        clearInterval(state.htTimerInterval);
        if (!state.htSwapDone) autoCompleteHtSwap(state._htSwapCallback);
      }
    }, 1000);
  }
}

let _timerWasPaused    = false;
let _pausedTimerSecs   = 0;
let _captainTimerPaused = false;
let _htTimerPaused      = false;

function showTutorialCard(stepKey, showSkip = true) {
  return new Promise(resolve => {
    _tutorialResolve = resolve;
    _pauseAllTimers();
    const step = TUTORIAL_STEPS[stepKey];
    if (!step) { resolve(); return; }

    const totalSteps = Object.keys(TUTORIAL_STEPS).length;
    const stepNum    = Object.keys(TUTORIAL_STEPS).indexOf(stepKey) + 1;

    const overlay = document.createElement('div');
    overlay.className = 'tutorial-overlay';
    overlay.id = 'tutorial-overlay-current';
    overlay.innerHTML = `
      <div class="tutorial-card">
        <div class="tutorial-step-label">Tutorial · Step ${stepNum} of ${totalSteps}</div>
        <span class="tutorial-emoji">${step.emoji}</span>
        <div class="tutorial-title">${step.title}</div>
        <div class="tutorial-body">${step.body}</div>
        <button class="tutorial-got-it" onclick="dismissTutorialCard()">
          ${step.btn}
        </button>
        ${showSkip ? `<span class="tutorial-skip" onclick="skipTutorial()">Skip tutorial</span>` : ''}
      </div>
    `;
    document.body.appendChild(overlay);
  });
}

function dismissTutorialCard() {
  const el = document.getElementById('tutorial-overlay-current');
  if (el) el.remove();
  if (_tutorialResolve) {
    const r = _tutorialResolve;
    _tutorialResolve = null;
    r();
  }
  _resumeAllTimers();
}

function skipTutorial() {
  _tutorialActive = false;
  const el = document.getElementById('tutorial-overlay-current');
  if (el) el.remove();
  _tutorialResolve = null;
  _resumeAllTimers();
  // Return to home so they can start a real game
  restart();
  showToast('Tutorial skipped — start a real game above!');
}

// Entry point — called from the home screen button
async function startTutorial() {
  _tutorialActive = true;
  _tutorialStep = 0;

  // Find the tutorial match
  const idx = getTutorialMatchIdx();
  if (idx === -1) {
    alert('Tutorial match not found — play a regular game instead.');
    return;
  }

  // Set up state as solo vs AI game
  state.mp = null;

  // Force coin toss win so player always picks GK first in tutorial
  state.gkPickerIsMe = true;

  // Load the match
  const m = ALL_MATCHES[idx];
  state.matchIdx = idx;
  loadMatch(idx);

  // Go to draft screen directly (skip coin flip animation)
  showScreen('draft');
  setupDraft();

  // Show coin toss explainer immediately
  await showTutorialCard('coin_toss');
  // Now game is live — next hook fires from tutorialHook() calls
}

// Central hook — called at key moments if tutorial is active
async function tutorialHook(moment) {
  if (!_tutorialActive) return;
  await showTutorialCard(moment);
}

// Tutorial-aware GK pick helper
async function tutorialAfterGkPick() {
  if (!_tutorialActive) return;
  await showTutorialCard('gk_forced');
}

</script>
</body>
</html>
